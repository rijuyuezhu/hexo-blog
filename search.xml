<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021 ICPC Asia Shenyang RC 题解</title>
    <url>/posts/80a48709/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/103427">比赛链接</a></p>
<span id="more"></span>
<h1 id="b---bitwise-exclusive-or-sequence">B - Bitwise Exclusive-OR
Sequence</h1>
<p><strong>题意</strong>: 构造一个长度为 <span
class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a_1,
a_2, \cdots, a_n\)</span>, 满足 <span class="math inline">\(m\)</span>
条限制, 每条限制形如 <span class="math inline">\(a_i\oplus
a_j=w\)</span>. 其中 <span class="math inline">\(\oplus\)</span> 为异或.
求所有满足条件的数列中数列和最小的一个的和.</p>
<p><strong>数据范围</strong>: <span class="math inline">\(1\le n\le
10^5, 0\le m \le 2\times 10^5, 0\le w&lt;2^{30}\)</span>.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>以 <span class="math inline">\(n\)</span> 项数列为 <span
class="math inline">\(n\)</span> 个顶点, <span
class="math inline">\(m\)</span> 条限制为 <span
class="math inline">\(m\)</span> 条带权边建图.</p>
<p>不同位间不互相影响, 分开考虑.</p>
<p>考虑图中每个连通块(显然每个连通块之间互不干扰), 进行 <span
class="math inline">\(0/1\)</span> 染色. 对于该位值为 <span
class="math inline">\(0\)</span> 的边, 相邻顶点颜色相同; 值为 <span
class="math inline">\(1\)</span> 的边, 相邻顶点颜色不同. 若染色冲突,
则不存在这样的数列. 否则, 染色值为 <span
class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span> 的节点中有一个该位赋值为 <span
class="math inline">\(0\)</span>, 一个赋值为 <span
class="math inline">\(1\)</span>, 选择少的那个.</p>
<p>时间复杂度 <span class="math inline">\(O(B(n+m))\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> B = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, nxt, w;</span><br><span class="line">&#125;e[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="type">int</span> fail, siz[<span class="number">2</span>], col[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;v, head[u], w&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> C, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    col[u] = C;</span><br><span class="line">    siz[C]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i &amp;&amp; !fail; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v, nc = C ^ ((e[i].w &gt;&gt; b) &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(col[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v, nc, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nc != col[v])</span><br><span class="line">                fail = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        col[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !fail; i++)</span><br><span class="line">        <span class="keyword">if</span>(col[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            siz[<span class="number">0</span>] = siz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i, <span class="number">0</span>, b);</span><br><span class="line">            ret += <span class="built_in">min</span>(siz[<span class="number">0</span>], siz[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fail ? <span class="number">0</span> : ret;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">        <span class="built_in">addedge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    fail = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B &amp;&amp; !fail; i++)</span><br><span class="line">        ans += (ll)<span class="built_in">calc</span>(i) &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span>(fail) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="d---cross-the-maze">D - Cross the Maze</h1>
<p><strong>题意</strong>: 有一个 <span class="math inline">\(a\times
b\)</span> 个单元格组成的矩形迷宫, 最外围有墙. 里面有 <span
class="math inline">\(n\)</span> 个人, 初始位置分别在 <span
class="math inline">\((s_{xi}, s_{yi})\)</span>; 他们要离开的话, 只能从
<span class="math inline">\(n\)</span> 条绳索离开, 分别在 <span
class="math inline">\((e_{xi}, e_{yi})\)</span>. 每个时刻,
每个人可以向四个方向走, 或留在原地. 每个绳索只能使用一次;
在<strong>任何时刻</strong>, 一个单元格不能停留两个人.
问让所有人离开的最短时间. 保证初始情况不能所有人全部立刻出去.</p>
<p><strong>数据范围</strong>: <span class="math inline">\(1\le n\le
100\)</span>, <span class="math inline">\(1\le a\times b\le
100\)</span>.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>看到各种各样的奇怪的限制, 可以想到网络流.</p>
<p>首先, 对于最终答案, 可以进行二分. 可知最终答案 <span
class="math inline">\(y\)</span> 满足 <span class="math inline">\(1\le
t\le ab\)</span>. (这个上界构造: 把迷宫蛇形展开成一行,
一起往一个方向走即可保证). 二分后改判断.</p>
<p>要判断 <span class="math inline">\(t\)</span> 时间可否完成,
我们网络流建图. 首先, 对于格子, 按照时间建 <span
class="math inline">\(t+1\)</span> 层, 每层还拆成入点和出点. 记 <span
class="math inline">\((t, x, y)\)</span> 表示 <span
class="math inline">\(t\)</span> 时刻的 <span class="math inline">\((x,
y)\)</span> 点的入点, <span class="math inline">\([t, x, y]\)</span>
为出点. 另外, 对于每根绳子, 我们也拆成入点和出点. 记 <span
class="math inline">\(\langle i \rangle\)</span> 为入点, <span
class="math inline">\(\lbrace i\rbrace\)</span> 为出点.
我们如下建图:</p>
<p><span class="math inline">\(S\to (0, s_{xi}, s_{yi})\)</span>, 容量为
<span class="math inline">\(1\)</span>.
这意为一开始这里有个冒险者.(流量表示冒险者)</p>
<p><span class="math inline">\((t, x, y)\to [t, x, y]\)</span>, 容量为
<span class="math inline">\(1\)</span>.
保证任意时刻每个格子只能有一个人在上面走.</p>
<p><span class="math inline">\([t, x, y] \to (t+1, u, v)\)</span>,
容量为 <span class="math inline">\(1\)</span>, 其中 <span
class="math inline">\((u, v)\)</span> 可由 <span
class="math inline">\((x, y)\)</span> 一步抵达.</p>
<p><span class="math inline">\([t, e_{xi}, e_{yi}] \to \langle i
\rangle\)</span>, 容量为 <span class="math inline">\(1\)</span>,
意为这里有绳索.</p>
<p><span class="math inline">\(\langle i\rangle\to \lbrace i
\rbrace\)</span>, 容量为 <span class="math inline">\(1\)</span>,
保证每个绳索只能用一次.</p>
<p><span class="math inline">\(\lbrace i\rbrace\to T\)</span>, 容量为
<span class="math inline">\(1\)</span> 逃出升天.</p>
<p>然后跑最大流即可, 若最大流为 <span class="math inline">\(n\)</span>
则可行.</p>
<p>构造方案直接沿着流的路径即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXNODE = <span class="number">30005</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXEDGE = <span class="number">150005</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> string dir = <span class="string">&quot;SRLDU&quot;</span>;</span><br><span class="line"><span class="type">int</span> N, S, T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, nxt, w;</span><br><span class="line">&#125;e[MAXEDGE];</span><br><span class="line"><span class="type">int</span> cur[MAXNODE], head[MAXNODE], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;v, head[u], w&#125;; head[u] = cnt;</span><br><span class="line">    e[++cnt] = &#123;u, head[v], <span class="number">0</span>&#125;; head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[MAXNODE], que[MAXNODE], hd, tl, max_flow, ans, outnumber;</span><br><span class="line">string way;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dep[i] = <span class="number">0</span>;</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    hd = <span class="number">1</span>; tl = <span class="number">0</span>;</span><br><span class="line">    que[++tl] = S;</span><br><span class="line">    dep[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(hd &lt;= tl) &#123;</span><br><span class="line">        <span class="type">int</span> u = que[hd++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &amp;&amp; !dep[v]) &#123;</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                que[++tl] = v;</span><br><span class="line">                <span class="keyword">if</span>(v == T) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> rest = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i = cur[u]; i &amp;&amp; rest; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w &amp;&amp; dep[v] == dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(rest, e[i].w));</span><br><span class="line">            <span class="keyword">if</span>(!k) dep[v] = <span class="number">0</span>;</span><br><span class="line">            e[i].w -= k;</span><br><span class="line">            rest -= k;</span><br><span class="line">            e[i^<span class="number">1</span>].w += k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flow;</span><br><span class="line">    max_flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(flow = <span class="built_in">dfs</span>(S, INF))</span><br><span class="line">            max_flow += flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a, b, sx[MAXN], sy[MAXN], ex[MAXN], ey[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t * a * b + i * b + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; a &amp;&amp; y &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N = <span class="number">2</span> * (t<span class="number">+1</span>) * a * b + <span class="number">2</span> * n + <span class="number">2</span>;</span><br><span class="line">    S = N<span class="number">-2</span>;</span><br><span class="line">    T = N<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        head[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">addedge</span>(S, <span class="built_in">get_num</span>(<span class="number">0</span>, sx[i], sy[i]), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (t<span class="number">+1</span>) * a * b; i++)</span><br><span class="line">        <span class="built_in">addedge</span>(i, i + (t<span class="number">+1</span>) * a * b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= t; k++)</span><br><span class="line">            <span class="built_in">addedge</span>((t<span class="number">+1</span>) * a * b + <span class="built_in">get_num</span>(k, ex[i], ey[i]), <span class="number">2</span> * (t<span class="number">+1</span>) * a * b + i<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="number">2</span> * (t<span class="number">+1</span>) * a * b + i<span class="number">-1</span>, <span class="number">2</span> * (t<span class="number">+1</span>) * a * b + n + i<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="number">2</span> * (t<span class="number">+1</span>) * a * b + n + i<span class="number">-1</span>, T, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; a; x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; b; y++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">5</span>; d++) &#123;</span><br><span class="line">                    <span class="type">int</span> nx = x + dx[d], ny = y + dy[d];</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="built_in">legal</span>(nx, ny))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="built_in">addedge</span>((t<span class="number">+1</span>) * a * b + <span class="built_in">get_num</span>(k, x, y), <span class="built_in">get_num</span>(k<span class="number">+1</span>, nx, ny), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">return</span> max_flow == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getway</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    way.<span class="built_in">clear</span>();</span><br><span class="line">    outnumber = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">get_num</span>(t, x, y) + (ans<span class="number">+1</span>) * a * b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[pos]; i; i = e[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(e[i^<span class="number">1</span>].w == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> v = e[i].v;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; (ans<span class="number">+1</span>) * a * b) &#123;</span><br><span class="line">                    <span class="comment">//case 1, next layer</span></span><br><span class="line">                    <span class="type">int</span> vx = v % (a * b) / b, vy = v % (a * b) % b;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">                        <span class="keyword">if</span>(vx == x + dx[k] &amp;&amp; vy == y + dy[k]) &#123;</span><br><span class="line">                            way += dir[k];</span><br><span class="line">                            x = vx;</span><br><span class="line">                            y = vy;</span><br><span class="line">                            t++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//case 2, outside</span></span><br><span class="line">                    outnumber = v - <span class="number">2</span> * (ans<span class="number">+1</span>) * a * b + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; sx[i] &gt;&gt; sy[i];</span><br><span class="line">        sx[i]--; sy[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; ex[i] &gt;&gt; ey[i];</span><br><span class="line">        ex[i]--; ey[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> L = <span class="number">1</span>, R = a * b;</span><br><span class="line">    ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">        <span class="type">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(M)) &#123;</span><br><span class="line">            ans = M;</span><br><span class="line">            R = M - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            L = M + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">check</span>(ans);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">getway</span>(sx[i], sy[i]);<span class="comment">//retrun way, outnumber</span></span><br><span class="line">        cout &lt;&lt; sx[i]<span class="number">+1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; sy[i]<span class="number">+1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ex[outnumber]<span class="number">+1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ey[outnumber]<span class="number">+1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; way;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = way.<span class="built_in">length</span>(); i &lt; ans; i++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="e---edward-gaming-the-champion">E - Edward Gaming, the
Champion</h1>
<p>水题, 不写题解了.</p>
<details>
<summary>
<b>展开代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">length</span>()<span class="number">-4</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">substr</span>(i, <span class="number">5</span>) == <span class="string">&quot;edgnb&quot;</span>)</span><br><span class="line">            ++cnt;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="h---line-graph-matching">H - Line Graph Matching</h1>
<p><strong>题意</strong>: (略加转换)给一个 <span
class="math inline">\(n\)</span> 点 <span
class="math inline">\(m\)</span> 边的无向带权连通简单图,
每次允许的操作是选择共顶点的两条边并删去, 求删去的边权和的最大值.</p>
<p><strong>数据范围:</strong> <span class="math inline">\(3\le n\le
10^5\)</span>, <span class="math inline">\(n-1\le m\le 2\times
10^5\)</span>.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>对于 <span class="math inline">\(m\)</span> 是偶数的情况,
我们可以把全部边删完. 方案如下: dfs 一棵生成树, 从叶子开始向上删.
如果与点 <span class="math inline">\(u\)</span>
相邻的边(包括树边和非树边)是偶数, 则把这些边两两一组全部删完. 否则,
留下一条通向父亲的树边, 到父亲处删. 依次类推, 可以全部删完.</p>
<p>对于 <span class="math inline">\(m\)</span> 是奇数的情况,
则最后一定会剩下一条边(而且容易证明最后剩一条边最优). 枚举留哪条边 <span
class="math inline">\(e\)</span>. 如果 <span
class="math inline">\(e\)</span> 是非割边, 则除去它的图仍是连通图, 可以;
如果 <span class="math inline">\(e\)</span> 是割边,
则要求分成的两个连通块的边数都是偶数. 写个 Tarjan 即可. 时间复杂度 <span
class="math inline">\(O(n+m)\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, w, nxt;</span><br><span class="line">    &#125;e[MAXM];</span><br><span class="line">    <span class="type">int</span> head[MAXN], cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++cnt] = &#123;v, w, head[u]&#125;;</span><br><span class="line">        head[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G, S;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], _dfn, cut[MAXM];</span><br><span class="line"><span class="type">int</span> vis[MAXN], bcc[MAXN], _bcc, bcc_val[MAXN], minw, siz[MAXN];</span><br><span class="line">ll totw;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> toe)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++_dfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = G.head[u]; i; i = G.e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i ^ <span class="number">1</span>) == toe)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v = G.e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v, i);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u])</span><br><span class="line">                cut[i] = cut[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    bcc[u] = _bcc;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = G.head[u]; i; i = G.e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v = G.e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = bcc_val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = S.head[u]; i; i = S.e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = S.e[i].v, w = S.e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">        <span class="keyword">if</span>(siz[v] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            minw = <span class="built_in">min</span>(minw, w);</span><br><span class="line">        siz[u] += <span class="number">1</span> + siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G.<span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">        G.<span class="built_in">addedge</span>(v, u, w);</span><br><span class="line">        totw += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; totw &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    minw = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="comment">//connected, so not necessary.</span></span><br><span class="line">            <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            ++_bcc;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = G.head[u]; i; i = G.e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> v = G.e[i].v, w = G.e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(bcc[u] == bcc[v]) &#123;</span><br><span class="line">                ++bcc_val[bcc[u]];</span><br><span class="line">                minw = <span class="built_in">min</span>(minw, w);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                S.<span class="built_in">addedge</span>(bcc[u], bcc[v], w);</span><br><span class="line">                S.<span class="built_in">addedge</span>(bcc[v], bcc[u], w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; totw - minw &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="i---linear-fractional-transformation">I - Linear Fractional
Transformation</h1>
<p><strong>题意</strong>: 给复数域上的函数 <span
class="math inline">\(f(z)=\dfrac{az+b}{cz+d}(a,b,c,d\in\mathbb C,
ad-bc\ne 0)\)</span>, 其中 <span class="math inline">\(a,b,c,d\)</span>
未知. 给 <span class="math inline">\(z_1, z_2, z_3, w_1, w_2,
w_3\)</span> 满足 <span class="math inline">\(f(z_i)=w_i\)</span>, 并给
<span class="math inline">\(z_0\)</span>, 求 <span
class="math inline">\(f(z_0)\)</span>. 保证解存在且唯一.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>我们发现这是个分数结构, 故可约去个比例. 分两种情况讨论:</p>
<ol type="1">
<li>若 <span class="math inline">\(c=0\)</span>, 则 <span
class="math inline">\(f(z)=\dfrac{az+b}{d}=a&#39;z+b&#39;\)</span>,
是个线性函数. 由 <span class="math inline">\(f(z_1)=w_1,
f(z_2)=w_2\)</span> 可求得 <span class="math inline">\(a&#39;,
b&#39;\)</span>, 再验证 <span class="math inline">\(f(z_3)=w_3\)</span>,
若满足, 则答案就是 <span
class="math inline">\(f(z_0)=a&#39;z_0+b&#39;\)</span>.</li>
<li>若 <span class="math inline">\(c\ne 0\)</span>, 则上下约去 <span
class="math inline">\(c\)</span> 得 <span
class="math inline">\(f(z)=\dfrac{a&#39;z+b&#39;}{z+d&#39;}=w\)</span>,
故 <span class="math inline">\(z_ia&#39;+b&#39;-w_id&#39;=z_iw_i(i=1, 2,
3)\)</span>, 高斯消元即可求得 <span class="math inline">\(a&#39;,
b&#39;, d&#39;\)</span>, 代入 <span
class="math inline">\(f(z_0)\)</span> 即可.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cp</span> &#123;</span><br><span class="line">    db x, y;</span><br><span class="line">    <span class="function">db <span class="title">Mo2</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> x * x + y * y;&#125;</span><br><span class="line">    cp <span class="keyword">operator</span> + (<span class="type">const</span> cp &amp;B)<span class="type">const</span> &#123;<span class="keyword">return</span> &#123;x + B.x, y + B.y&#125;;&#125;</span><br><span class="line">    cp <span class="keyword">operator</span> - (<span class="type">const</span> cp &amp;B)<span class="type">const</span> &#123;<span class="keyword">return</span> &#123;x - B.x, y - B.y&#125;;&#125;</span><br><span class="line">    cp <span class="keyword">operator</span> * (<span class="type">const</span> cp &amp;B)<span class="type">const</span> &#123;<span class="keyword">return</span> &#123;x * B.x - y * B.y, x * B.y + y * B.x&#125;;&#125;</span><br><span class="line">    cp <span class="keyword">operator</span> / (<span class="type">const</span> cp &amp;B)<span class="type">const</span> &#123;<span class="keyword">return</span> &#123;(x * B.x + y * B.y) / B.<span class="built_in">Mo2</span>(), (y * B.x - x * B.y) / B.<span class="built_in">Mo2</span>()&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;in, cp &amp;B) &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    in &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    B.x = a;</span><br><span class="line">    B.y = b;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="type">const</span> cp&amp; B) &#123;</span><br><span class="line">    out &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; B.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; B.y;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">cp z[<span class="number">4</span>], w[<span class="number">4</span>], a[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cp k = (w[<span class="number">1</span>] - w[<span class="number">2</span>]) / (z[<span class="number">1</span>] - z[<span class="number">2</span>]);</span><br><span class="line">    cp b = w[<span class="number">1</span>] - k * z[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>((k * z[<span class="number">3</span>] + b - w[<span class="number">3</span>]).<span class="built_in">Mo2</span>() &lt; eps) &#123;</span><br><span class="line">        cout &lt;&lt; k * z[<span class="number">0</span>] + b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Guass</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="type">int</span> num = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r<span class="number">+1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][c].<span class="built_in">Mo2</span>() &gt; a[num][c].<span class="built_in">Mo2</span>())</span><br><span class="line">                num = i;</span><br><span class="line">        <span class="keyword">if</span>(num != r)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = c; i &lt;= n<span class="number">+1</span>; i++)</span><br><span class="line">                <span class="built_in">swap</span>(a[r][i], a[num][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r<span class="number">+1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cp k = a[i][c] / a[r][c];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = c; j &lt;= n<span class="number">+1</span>; j++)</span><br><span class="line">                a[i][j] = a[i][j] - k * a[r][j];</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt;= n; j++)</span><br><span class="line">            a[i][n<span class="number">+1</span>] = a[i][n<span class="number">+1</span>] - a[j][n<span class="number">+1</span>] * a[i][j];</span><br><span class="line">        a[i][n<span class="number">+1</span>] = a[i][n<span class="number">+1</span>] / a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        cin &gt;&gt; z[i] &gt;&gt; w[i];</span><br><span class="line">    cin &gt;&gt; z[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check1</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        a[i][<span class="number">1</span>] = z[i];</span><br><span class="line">        a[i][<span class="number">2</span>] = &#123;<span class="number">1.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">        a[i][<span class="number">3</span>] = &#123;-w[i].x, -w[i].y&#125;;</span><br><span class="line">        a[i][<span class="number">4</span>] = w[i] * z[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Guass</span>(<span class="number">3</span>);</span><br><span class="line">    cp A = a[<span class="number">1</span>][<span class="number">4</span>], B = a[<span class="number">2</span>][<span class="number">4</span>], D = a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    cout &lt;&lt; (A * z[<span class="number">0</span>] + B) / (z[<span class="number">0</span>] + D) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="j---luggage-lock">J - Luggage Lock</h1>
<p><strong>题意</strong>: 行李箱上的密码 <span
class="math inline">\(a_0a_1a_2a_3\)</span> 转换为 <span
class="math inline">\(b_0b_1b_2b_3\)</span> 至少要几下?
允许的操作是使连续一段同时上移或下移.</p>
<details>
<summary>
<b>愚蠢的原思路(不保证正确)</b>
</summary>
<p>有个猜想(后面证明不完全正确): 我们可以算出每一位向上移和向下移的次数
<span class="math inline">\(up_i\)</span> 和 <span
class="math inline">\(down_i\)</span>. <span
class="math inline">\(2^4\)</span> 枚举每一位是会往上移还是向下移.
显然我们的操作不会横跨 <span class="math inline">\(up\)</span> 和 <span
class="math inline">\(down\)</span> 的区间. 于是用和<a
href="https://www.luogu.com.cn/problem/P5019">这题</a>类似的做法即可完成.</p>
<p>但是, 这样做是错误的. 一个反例如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0000 6405</span><br></pre></td></tr></table></figure>
<p>以我们上面的算法得到的是 <span class="math inline">\(11\)</span>,
但正确答案应该是 <span class="math inline">\(10\)</span>.</p>
<p>过程如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0000</span><br><span class="line">9990</span><br><span class="line">8880</span><br><span class="line">7770</span><br><span class="line">6660</span><br><span class="line">6550</span><br><span class="line">6449</span><br><span class="line">6438</span><br><span class="line">6427</span><br><span class="line">6416</span><br><span class="line">6405</span><br></pre></td></tr></table></figure>
<p>我们发现第三位 <span class="math inline">\(0\)</span> 绕了一圈!
所以我补上了个补丁, 也就是在上面枚举 <span
class="math inline">\(2^4\)</span> 外, 再 <span
class="math inline">\(2^4\)</span> 地枚举每次是调 <span
class="math inline">\(up_i/down_i\)</span> 还是 <span
class="math inline">\(up_i/down_i+10\)</span>.</p>
<p>未证明正确性!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> up[MAXN], down[MAXN];</span><br><span class="line">string a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        up[i] = (<span class="built_in">int</span>(b[i]) - <span class="built_in">int</span>(a[i]) + <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        down[i] = (<span class="built_in">int</span>(a[i]) - <span class="built_in">int</span>(b[i]) + <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt; U; s++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; U; t++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>((t &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">                    up[i] += <span class="number">10</span>, down[i] += <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || (~(s &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>))</span><br><span class="line">                        ret += up[i];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ret += <span class="built_in">max</span>(<span class="number">0</span>, up[i] - up[i<span class="number">-1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || ((s &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>))</span><br><span class="line">                        ret += down[i];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ret += <span class="built_in">max</span>(<span class="number">0</span>, down[i] - down[i<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>((t &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">                    up[i] -= <span class="number">10</span>, down[i] -= <span class="number">10</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>
<b>一个好做法</b>
</summary>
<p>我们发现, 如果 <span class="math inline">\(b_i-a_i\)</span> 全部相同,
则两种情况等价. 所以本质不同的方案只有 <span
class="math inline">\(10000\)</span> 种. 直接预处理 bfs 再 <span
class="math inline">\(O(1)\)</span> 处理询问即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXV = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> pow10[] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="type">int</span> step[MAXV<span class="number">+1</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upbit</span><span class="params">(<span class="type">int</span> &amp;v, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ori = (v / pow10[b]) % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> now = (ori == <span class="number">9</span> ? <span class="number">0</span> : ori + <span class="number">1</span>);</span><br><span class="line">    v += (now - ori) * pow10[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downbit</span><span class="params">(<span class="type">int</span> &amp;v, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ori = (v / pow10[b]) % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> now = (ori == <span class="number">0</span> ? <span class="number">9</span> : ori - <span class="number">1</span>);</span><br><span class="line">    v += (now - ori) * pow10[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAXV; i++)</span><br><span class="line">        step[i] = <span class="number">-1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    step[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> v = u;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">                    <span class="built_in">upbit</span>(v, k);</span><br><span class="line">                <span class="keyword">if</span>(step[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    step[v] = step[u] + <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                v = u;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">                    <span class="built_in">downbit</span>(v, k);</span><br><span class="line">                <span class="keyword">if</span>(step[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    step[v] = step[u] + <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">string a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            x += ((b[i] - a[i] + <span class="number">10</span>) % <span class="number">10</span>) * pow10[i];</span><br><span class="line">        cout &lt;&lt; step[x] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>XCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 844(id 1782) 题解</title>
    <url>/posts/c802badd/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1782">比赛链接</a></p>
<span id="more"></span>
<p>可以参考<a
href="https://www.cnblogs.com/legendstane/p/codeforces-cf-1782-round-844-a-b-c-d-e-f-solution.html">这篇题解</a>.</p>
<h1 id="a---parallel-projection">A - Parallel Projection</h1>
<p><strong>题意</strong>: 给一个长宽高分别为 <span
class="math inline">\(w, d, h\)</span> 的长方体, 并给出下底面上一点
<span class="math inline">\((a, b)\)</span> 和上底面上一点 <span
class="math inline">\((f, g)\)</span>,
求沿着长方体表面两点间的最短距离.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>一道初中题. 容易发现, 仅经过一个侧面最佳, 那就分别沿着四个方向展开,
算出展开后顶面那点到底面的投影, 再求曼哈顿距离即可, 取四个中的最小值.
时间复杂度 <span class="math inline">\(O(1)\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> w, d, h, a, b, f, g;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dist</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a - x) + <span class="built_in">abs</span>(b - y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; d &gt;&gt; h &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">Dist</span>(a, b, f, -h-g));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">Dist</span>(a, b, -h-f, g));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">Dist</span>(a, b, f, d+h+d-g));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">Dist</span>(a, b, w+h+w-f, g));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="b---going-to-the-cinema">B - Going to the Cinema</h1>
<p><strong>题意</strong>: 有 <span class="math inline">\(n\)</span>
个人, 每个人有个 <span class="math inline">\(a_i\)</span>.
每人说一句断言: 我去电影院当且仅当<strong>除我以外</strong>去的人不少于
<span class="math inline">\(a_i\)</span> 个.
现在要使全部人说的断言均为真(请注意到这是一句双蕴含的命题,
这个人本身不一定要去), 则请问有几种去的人的选择?</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>我们把 <span class="math inline">\(a_i\)</span> 从小到大排序, 即保证
<span class="math inline">\(a_1\le a_2\le \cdots \le a_n\)</span>. 设
<span class="math inline">\(i\)</span> 去而 <span
class="math inline">\(j\)</span> 不去, 一共去了 <span
class="math inline">\(t\)</span> 人, 根据上面的断言我们有: 一方面, <span
class="math inline">\(i\)</span> 去, 那么 <span
class="math inline">\(t\ge a_i+1\)</span>; 另一方面, <span
class="math inline">\(j\)</span> 不去, 则 <span class="math inline">\(t
&lt; a_j\)</span>, 可知 <span
class="math inline">\(a_i+1&lt;a_j\)</span>, 一必要条件是 <span
class="math inline">\(i&lt;j\)</span>. 所以我们发现,
这相当于把序列分成两部分, 前一部分全去, 后一部分全不去. 枚举 <span
class="math inline">\(i\)</span>, 设 <span
class="math inline">\(1\)</span> 到 <span class="math inline">\(i(0\le
i\le n)\)</span> 去, <span class="math inline">\(i+1\)</span> 到 <span
class="math inline">\(n\)</span> 不去, 则要求不等式 <span
class="math inline">\(a_i+1\le i&lt;a_{i+1}\)</span> 满足, 验证即可.
注意处理一下边界. 时间复杂度 <span class="math inline">\(O(n\log
n)\)</span>, 瓶颈在于排序.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">-1</span>; a[n<span class="number">+1</span>] = n<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i] + <span class="number">1</span> &lt;= i &amp;&amp; i &lt;= a[i<span class="number">+1</span>] - <span class="number">1</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="c---equal-frequencies">C - Equal Frequencies</h1>
<p><strong>题意</strong>: 给一个长度为 <span
class="math inline">\(n\)</span> 的字符串, 只能含小写字母,
问最少的替换操作, 使得里面所有出现过的字符一样多.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>首先, 我们枚举一下, 最终串中出现的字母种类 <span
class="math inline">\(s\)</span>, 可知 <span class="math inline">\(1\le
s\le 26\)</span> 且 <span class="math inline">\(s\mid n\)</span>,
则最终每种字符要出现 <span class="math inline">\(n/s\)</span> 次.
我们贪心地选择原串中出现次数前 <span class="math inline">\(s\)</span>
多的字母最后变成 <span class="math inline">\(n/s\)</span> 种.
这里可以简单证明一下这个贪心为什么是对的:</p>
<p>设 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 两种字符出现次数分别是 <span
class="math inline">\(c_i\)</span> 和 <span
class="math inline">\(c_j\)</span>, 则选 <span
class="math inline">\(i\)</span> 不选 <span
class="math inline">\(j\)</span> 的代价是 <span
class="math inline">\(c_j+\max\lbrace 0, c_i-n/s\rbrace\)</span>, 选
<span class="math inline">\(j\)</span> 不选 <span
class="math inline">\(i\)</span> 的代价是 <span
class="math inline">\(c_i+\max\lbrace 0, c_j-n/s\rbrace\)</span>. 则选
<span class="math inline">\(i\)</span> 的理由是 <span
class="math inline">\(c_j+\max\lbrace 0, c_i-n/s\rbrace \le
c_i+\max\lbrace 0, c_j-n/s\rbrace\)</span>, 简单化简一下可知 <span
class="math inline">\(c_i\ge c_j\)</span>.</p>
<p>于是排个序后, 把需要减少的字符(对于前 <span
class="math inline">\(s\)</span> 种要保留的字符, 则它比 <span
class="math inline">\(n/s\)</span> 多的次数; 对于后 <span
class="math inline">\(26-s\)</span> 种不保留的字符, 则它比 <span
class="math inline">\(0\)</span> 多的次数)的次数记录下来,
把需要增加的字符(前 <span class="math inline">\(s\)</span> 种中比 <span
class="math inline">\(n/s\)</span> 少的次数)放进一个队列中. 最后,
扫一边原串, 如果当前位置原来的字符需要减少,
那么从队列中拿一个新的字符替换.</p>
<p>总时间复杂度 <span class="math inline">\(O(s(s\log s + n))\)</span>,
此处 <span class="math inline">\(s\)</span> 为字符集大小 <span
class="math inline">\(26\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; snum, id;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; add, mns;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> snum[a] &gt; snum[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    string ansstring;</span><br><span class="line">    snum = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">        snum[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ty = <span class="number">1</span>; ty &lt;= <span class="number">26</span>; ty++)</span><br><span class="line">        <span class="keyword">if</span>(n % ty == <span class="number">0</span>) &#123;</span><br><span class="line">            id = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                id[i] = i;</span><br><span class="line">            <span class="type">int</span> eve = n / ty;</span><br><span class="line">            <span class="built_in">sort</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), cmp);</span><br><span class="line">            add = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            mns = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ty; i++) &#123;</span><br><span class="line">                <span class="type">int</span> c = id[i];</span><br><span class="line">                <span class="keyword">if</span>(snum[c] &lt; eve) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = snum[c]; k &lt; eve; k++)</span><br><span class="line">                        add.<span class="built_in">push_back</span>(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(snum[c] &gt; eve) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = snum[c]; k &gt; eve; k--)</span><br><span class="line">                        mns[c]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = ty; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> c = id[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = snum[c]; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                    mns[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            string retstring = s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : retstring) &#123;</span><br><span class="line">                <span class="type">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(mns[c]) &#123;</span><br><span class="line">                    ch = add.<span class="built_in">back</span>() + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    add.<span class="built_in">pop_back</span>();</span><br><span class="line">                    mns[c]--;</span><br><span class="line">                    ret++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; ans) &#123;</span><br><span class="line">                ans = ret;</span><br><span class="line">                ansstring = retstring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; ansstring &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="d---many-perfect-squares">D - Many Perfect Squares</h1>
<p>给 <span class="math inline">\(n\)</span> 个互不相同的数 <span
class="math inline">\(a_i\)</span>, 对于所有的 <span
class="math inline">\(x\)</span> 满足 <span class="math inline">\(0\le
x\le 10^{18}\)</span>, 求序列 <span class="math inline">\(\lbrace
a_i+x\rbrace\)</span> 中完全平方数的个数的最大值.</p>
<p>数据范围: <span class="math inline">\(1\le n\le 50, 1\le
a_1&lt;a_2&lt;\cdots &lt; a_n\le 10^9\)</span>.</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>首先显然, 答案至少为 <span class="math inline">\(1\)</span>.</p>
<p>我们接下来看答案是否可以 <span class="math inline">\(\ge
2\)</span>.</p>
<p>在这种情况下, 必然存在两个数 <span class="math inline">\(a_p,
a_q\)</span>(不妨设 <span class="math inline">\(p&lt;q\)</span>), 满足
<span class="math inline">\(a_p+x=f^2, a_q+x=g^2\)</span>, 那么 <span
class="math inline">\(a_q-a_p=g^2-f^2=(g-f)(g+f)\)</span>. 我们枚举
<span class="math inline">\(a_q-a_p\)</span> 的小的那个因数 <span
class="math inline">\(t:t\mid (a_q-q_p)\ \textnormal{and}\ t^2\le
a_q-a_p\)</span>, 则令 <span class="math inline">\(g-f=t,
g+f=(a_q-a_p)/t\)</span>, 求出 <span class="math inline">\(g\)</span>,
从而求出这种情况的 <span class="math inline">\(x\)</span> 来. 接下来,
只需要枚举一遍序列看看这个 <span class="math inline">\(x\)</span>
的情况的答案了.</p>
<p>也许你会对这个做法的时间复杂度有疑问. 首先, <span
class="math inline">\(O(n^2)\)</span> 的枚举是必要的. 接下来, 我们会使用
<span class="math inline">\(O(\sqrt V)\)</span> 枚举因数.
如果枚举到因子, 还需要多一个 <span class="math inline">\(O(n)\)</span>.
时间复杂度为 <span class="math inline">\(O(n^2\sqrt
V+n^3\operatorname{Maxd}(V))\)</span>, 其中 <span
class="math inline">\(\operatorname{Maxd}(V)\)</span> 表示 <span
class="math inline">\(1\sim V\)</span> 范围内因数个数函数 <span
class="math inline">\(d(n)\)</span> 的最大值. 这个上界还算松. 其中 <span
class="math inline">\(n\)</span> 取 <span class="math inline">\(\le
50\)</span>, <span class="math inline">\(V\)</span> 取 <span
class="math inline">\(\le 10^9\)</span>.</p>
<blockquote>
<p>关于该函数的一些结论:</p>
<p><a href="http://oeis.org/A066150">OEIS A066150</a> 列出了对于 <span
class="math inline">\(1\le x&lt; 10^n\)</span> 的数, <span
class="math inline">\(d(x)\)</span> 的最大值, 几近可以认为数列第 <span
class="math inline">\(n\)</span> 项 <span
class="math inline">\(a_n\)</span> 就等于 <span
class="math inline">\(\operatorname{Maxd}(10^n)\)</span>.</p>
<p>查表我们发现, 这个函数 比 <span class="math inline">\(t^{\lg
2}\)</span> 增长还慢)</p>
<p>比较有用的结论是, <span
class="math inline">\(a_9=\operatorname{Maxd}(10^9)=1344,
a_{18}=\operatorname{Maxd}(10^{18})=103680\)</span>.</p>
<p>更加具体的问题可以去看 <a
href="https://www.luogu.com.cn/problem/P1463">这道题</a></p>
</blockquote>
<p>有上面的分析后, 一通计算, 我们发现这个时间复杂度确实可以接受...</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n, a[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sqr</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issquare</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqr</span>(<span class="built_in">ll</span>(<span class="built_in">sqrt</span>((<span class="type">double</span>)x) + <span class="number">0.5</span>)) == x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gett</span><span class="params">(ll t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">issquare</span>(a[i] + t))</span><br><span class="line">            ret++;</span><br><span class="line">    <span class="comment">//cerr &lt;&lt; &#x27;(&#x27; &lt;&lt; t &lt;&lt; &#x27; &#x27; &lt;&lt; ret &lt;&lt; &#x27;)&#x27; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = a[q] - a[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; <span class="number">1ll</span> * i * i &lt;= val; i++)</span><br><span class="line">        <span class="keyword">if</span>(val % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> xny = i, xpy = val / i;</span><br><span class="line">            <span class="keyword">if</span>(xny % <span class="number">2</span> != xpy % <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> x = (xpy - xny) / <span class="number">2</span>;</span><br><span class="line">            ll t = <span class="number">1ll</span> * x * x - a[p];</span><br><span class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">gett</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">check</span>(i, j);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>XCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 相关算法 学习笔记</title>
    <url>/posts/497c6bdd/</url>
    <content><![CDATA[<p>简要汇总了 Tarjan 相关的图论算法的资料, 并有所思考.</p>
<span id="more"></span>
<p>Tarjan 的思路是很有代表性的.</p>
<p>运用 Tarjan 的图论算法主要有:</p>
<ul>
<li>求有向图的强连通分量(缩点为 DAG)</li>
<li>求无向图的割点、桥.</li>
<li>求无向图的双连通分量(点、边)</li>
</ul>
<h1 id="tarjan-思路总结">Tarjan 思路总结</h1>
<p>Tarjan 的思路是先找出图的一棵生成树,
则沿着树任意两点构成唯一的一条路径. 剩下的边分为横叉边和返祖边,
这样的边构成环(从而构成强连通/双连通). Tarjan 富有特色地使用了 <span
class="math inline">\(low\)</span> 数组统计了连通性相关的信息.
由于我们要求的是连通分量, 所以信息不会丢失.</p>
<h1 id="求强连通分量scc">求强连通分量(SCC)</h1>
<p><a href="https://www.luogu.com.cn/problem/P3387">题目链接: LG_P3387
缩点</a></p>
<h2 id="理论">理论</h2>
<p>可以想象, 在一棵完整的生成树中, SCC 是分层的(也就是说, SCC
沿着生成树的边也是一种树形结构), 所以我们使用栈记录 SCC 上的节点.
具体地说, 在生成树上, 一个 SCC 是一种类似于"树段"的结构. 它以一个点
<span class="math inline">\(u\)</span> 作为"根", 有 <span
class="math inline">\(u\)</span> 的子树中的若干节点 <span
class="math inline">\(x_1, x_2, \cdots, x_m\)</span> 作为"叶子", 而所有
SCC 中的节点就是生成树上 <span class="math inline">\(u\to x_i\)</span>
路径上的点的并. 我们记这样的 SCC 为 <span
class="math inline">\(SCC(u)\)</span>. <span
class="math inline">\(x_i\)</span> 一定至少满足以下两性质之一:</p>
<ol type="1">
<li><span class="math inline">\(x_i\)</span> 存在返祖边 <span
class="math inline">\((x_i, u)\)</span>.</li>
<li><span class="math inline">\(x_i\)</span> 存在横叉边 <span
class="math inline">\((x_i, t)\)</span>, 其中 <span
class="math inline">\(t\)</span> 比 <span
class="math inline">\(x_i\)</span> 时间戳小且在 <span
class="math inline">\(SCC(u)\)</span> 中.</li>
</ol>
<p>注意, 以上定义中横叉边一词必须依托时间戳而存在.</p>
<p>那么, 我们的 <span class="math inline">\(low\)</span>
数组就细致地描述了这个过程. 如果我们在每个 SCC 的根 <span
class="math inline">\(u\)</span> 处考虑哪些节点在 <span
class="math inline">\(SCC(u)\)</span> 中, 那么我们只需要排除所有 <span
class="math inline">\(x_i\)</span> 的孩子们, 它们开启了新的 SCC.
还记得我们上面说使用栈维护 SCC 吗? 我们在 dfs 树找到一个新的 SCC 后,
从栈中弹出它们即可更新答案的同时给它的父亲 SCC "排异".</p>
<ul>
<li>如果对于一个节点 <span class="math inline">\(v\)</span> 有返祖边
<span class="math inline">\((v, u)\)</span>, 则这说明 <span
class="math inline">\(v\)</span> 所在的 SCC 的根至少是 <span
class="math inline">\(u\)</span>, 或者 <span
class="math inline">\(u\)</span> 的祖先. 那么我们可以往上传递(根据 SCC
的树段结构), 对 <span class="math inline">\(u\to v\)</span> 的每个节点,
至少可以到 <span class="math inline">\(u\)</span>, 故其所在的 SCC
的根至少是 <span class="math inline">\(u\)</span>, 或者 <span
class="math inline">\(u\)</span> 的祖先.</li>
<li>如果对于一个节点 <span class="math inline">\(v\)</span> 有横叉边
<span class="math inline">\((v, x)\)</span>. 分为两种情况:
<ul>
<li>若 <span class="math inline">\(x\)</span> 已经出栈, 那么 <span
class="math inline">\(x\)</span> 所在的 SCC 已经被考虑. 那么沿着 <span
class="math inline">\((v, x)\)</span> 继续走只能在 <span
class="math inline">\(x\)</span> 所在的 SCC 及其子 SCC 里面绕,
绝不可能到达 <span class="math inline">\(u\)</span> 的祖先(否则, 这个
SCC 应该再扩大, 需要到 <span class="math inline">\(u\)</span>
的祖先处再确定), 故它没有作用.</li>
<li>若 <span class="math inline">\(x\)</span> 仍然在栈中, 则 <span
class="math inline">\(x\)</span> 所在的 SCC 仍未完全确定, 它的根是 <span
class="math inline">\(u\)</span> 的祖先, 那么继续沿着 <span
class="math inline">\(u\)</span> 走可以回到它的祖先,
那么它的作用就类似于一条返祖边了. 可以类似与返祖边的做法.</li>
</ul></li>
</ul>
<p>于是我们的 <span class="math inline">\(low\)</span>
定义就是基于上面的分析来的. 在遍历完 <span
class="math inline">\(u\)</span> 的所有子树时, <span
class="math inline">\(low(u)\)</span> 集齐了 <span
class="math inline">\(u\)</span> 子树的可达性分析, 得到了从 <span
class="math inline">\(u\)</span> 出发的可以到达的最浅祖先.
(<strong>事实上不完全是这样</strong>, 见下方<a
href="#写法对比">写法对比</a>) 则当 <span
class="math inline">\(low(u)=dfn(u)\)</span> 时, 代表一个 SCC 的根,
这时仍在栈中且在 <span class="math inline">\(u\)</span>
子树中的节点(或者说栈中在 <span class="math inline">\(u\)</span>
以上的节点, 含)就是以 <span class="math inline">\(u\)</span> 为根的 SCC
的节点.</p>
<h2 id="写法对比">写法对比</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++_dfn;</span><br><span class="line">    stk[++top] = u;</span><br><span class="line">    ins[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = G<span class="number">1.</span>head[u]; i; i = G<span class="number">1.</span>e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = G<span class="number">1.</span>e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]); <span class="comment">//写法 1</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]); <span class="comment">//写法 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">        ++_scc;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            t = stk[top--];</span><br><span class="line">            ins[t] = <span class="number">0</span>;</span><br><span class="line">            scc[t] = _scc;</span><br><span class="line">            scc_sum[_scc] += a[t];</span><br><span class="line">        &#125;<span class="keyword">while</span>(t != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法 1 是严格按照我上述的过程分析定义的 <span
class="math inline">\(low\)</span>, 描述了从 <span
class="math inline">\(u\)</span> 出发的可以到达的最浅祖先.
这种的正确性是上面论证过的.</p>
<p>写法 2 是我们的习惯写法. 其中的 <span
class="math inline">\(low(u)\)</span> 代表从 <span
class="math inline">\(u\)</span>
的子树的任意节点以及从它们出发可以一次到达的仍在栈中的节点的时间戳最小值.
我们发现, 它的区别在于, 它对横叉边的处理没有那么干脆利索: 对于 <span
class="math inline">\((u, x)\)</span> 的横叉边更新, 它没有以 <span
class="math inline">\(x\)</span> 所在 SCC 的根(是 <span
class="math inline">\(u\)</span> 的某个祖先, 记作 <span
class="math inline">\(root(x)\)</span>)的时间戳作为更新 <span
class="math inline">\(low\)</span> 的值, 而是直接以 <span
class="math inline">\(x\)</span> 的时间戳更新. 这样也是正确的:
因为这一步最重要的是使 <span class="math inline">\(root(x)\to u\)</span>
上除了 <span class="math inline">\(root(x)\)</span>
以外的节点认识到自己不是 SCC 的根(这是可以做到的, 因为 <span
class="math inline">\(x\)</span> 的时间戳比它们都小, 所以它们的 <span
class="math inline">\(low\)</span> 会更新地比它们自己更小), 而 <span
class="math inline">\(root(x)\)</span> 本身不需更新 - 它的 <span
class="math inline">\(low\)</span> 的初值就是它自己的时间戳.</p>
<p>为什么会习惯第二种写法呢? 往后看, 因为它可以和其它几个 Tarjan
算法统一.</p>
<details>
<summary>
<b>完整代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nxt;</span><br><span class="line">    &#125;e[MAXM];</span><br><span class="line">    <span class="type">int</span> head[MAXN], cnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        e[++cnt] = &#123;v, head[u]&#125;;</span><br><span class="line">        head[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G1, G2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], _dfn, stk[MAXN], top, ins[MAXN], scc[MAXN], _scc, scc_sum[MAXN], deg[MAXN], que[MAXN], hd, tl, f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++_dfn;</span><br><span class="line">    stk[++top] = u;</span><br><span class="line">    ins[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = G<span class="number">1.</span>head[u]; i; i = G<span class="number">1.</span>e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = G<span class="number">1.</span>e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">        ++_scc;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            t = stk[top--];</span><br><span class="line">            ins[t] = <span class="number">0</span>;</span><br><span class="line">            scc[t] = _scc;</span><br><span class="line">            scc_sum[_scc] += a[t];</span><br><span class="line">        &#125;<span class="keyword">while</span>(t != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G<span class="number">1.</span><span class="built_in">addedge</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = G<span class="number">1.</span>head[u]; i; i = G<span class="number">1.</span>e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = G<span class="number">1.</span>e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(scc[u] == scc[v]) <span class="keyword">continue</span>;</span><br><span class="line">            G<span class="number">2.</span><span class="built_in">addedge</span>(scc[u], scc[v]);</span><br><span class="line">            deg[scc[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    hd = <span class="number">1</span>; tl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _scc; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            que[++tl] = i;</span><br><span class="line">            f[i] = scc_sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(hd &lt;= tl) &#123;</span><br><span class="line">        <span class="type">int</span> u = que[hd++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = G<span class="number">2.</span>head[u]; i; i = G<span class="number">2.</span>e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = G<span class="number">2.</span>e[i].v;</span><br><span class="line">            f[v] = <span class="built_in">max</span>(f[v], f[u] + scc_sum[v]);</span><br><span class="line">            <span class="keyword">if</span>(--deg[v] == <span class="number">0</span>)</span><br><span class="line">                que[++tl] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _scc; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="求割点和点双连通分量v-bcc">求割点和点双连通分量(v-BCC)</h1>
<p><a href="https://www.luogu.com.cn/problem/P3388">题目链接: LG_P3388
割点</a></p>
<p><a href="https://www.luogu.com.cn/problem/P8435">题目链接: LG_P8435
点双连通分量</a></p>
<p>割点是指, 在连通图(或非连通图的一个连通块中), 删去点 <span
class="math inline">\(u\)</span>
及与它相邻的边会使剩余的图不再连通(或连通块个数增多)的点 <span
class="math inline">\(u\)</span>.</p>
<p>点双连通分量(v-BCC), 简称点双, 是指一个极大子图满足删去任意一个点,
得到的子图仍然连通.</p>
<p><a
href="https://www.luogu.com.cn/blog/Jeremiah--y/solution-p8435">这个题解</a>讲得非常详细.</p>
<details>
<summary>
<b>展开代码 - P3388</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, nxt;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span>  </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], _dfn, cut[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++_dfn;</span><br><span class="line">    <span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="built_in">tarjan</span>(v, u, rt);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(u != rt || ch &gt;= <span class="number">2</span>)</span><br><span class="line">                    cut[u] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">addedge</span>(u, v);</span><br><span class="line">        <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i, <span class="number">0</span>, i);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(cut[i])</span><br><span class="line">            ++ans;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(cut[i])</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>
<b>展开代码 - P8435</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">4e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, nxt;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], _dfn, stk[MAXN], top;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; dcc;<span class="comment">//v-dcc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++_dfn;</span><br><span class="line">    stk[++top] = u;</span><br><span class="line">    <span class="keyword">if</span>(u == rt &amp;&amp; !head[u]) &#123;</span><br><span class="line">        dcc.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;u&#125;);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="built_in">tarjan</span>(v, u, rt);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                dcc.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br><span class="line">                <span class="type">int</span> t;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    t = stk[top--];</span><br><span class="line">                    dcc[(<span class="type">int</span>)dcc.<span class="built_in">size</span>()<span class="number">-1</span>].<span class="built_in">push_back</span>(t);</span><br><span class="line">                &#125;<span class="keyword">while</span>(t != v);</span><br><span class="line">                dcc[(<span class="type">int</span>)dcc.<span class="built_in">size</span>()<span class="number">-1</span>].<span class="built_in">push_back</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(u == v)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//cases that (u, u) and u is size 1</span></span><br><span class="line">        <span class="built_in">addedge</span>(u, v);</span><br><span class="line">        <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i, <span class="number">0</span>, i);</span><br><span class="line">    cout &lt;&lt; dcc.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;t : dcc) &#123;</span><br><span class="line">        cout &lt;&lt; t.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : t)</span><br><span class="line">            cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="求桥和边双连通分量e-bcc">求桥和边双连通分量(e-BCC)</h1>
<p><a href="https://www.luogu.com.cn/problem/P8436">题目链接: LG_P8436
边双连通分量</a></p>
<p>桥是指, 在连通图(或非连通图的一个连通块中), 删去边 <span
class="math inline">\(e\)</span>
会使剩余的图不再连通(或连通块个数增多)的边 <span
class="math inline">\(e\)</span>.</p>
<p>边双连通分量(e-BCC), 简称边双, 是指一个极大子图满足删去任意一条边,
得到的子图仍然连通.</p>
<p><a
href="https://www.luogu.com.cn/blog/zhengzhaoxi/solution-p8436">这个题解</a>讲得非常详细</p>
<details>
<summary>
<b>展开代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">4e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, nxt;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], _dfn, cut[MAXM];</span><br><span class="line"><span class="type">int</span> vis[MAXN], _bcc;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; bcc_con[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> toe)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++_dfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i ^ <span class="number">1</span>) == toe)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v, i);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u])</span><br><span class="line">                cut[i] = cut[i^<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    bcc_con[_bcc].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">addedge</span>(u, v);</span><br><span class="line">        <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            ++_bcc;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; _bcc &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _bcc; i++) &#123;</span><br><span class="line">        cout &lt;&lt; bcc_con[i].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : bcc_con[i])</span><br><span class="line">            cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>XCPC</tag>
        <tag>tarjan</tag>
        <tag>Graph Theory</tag>
        <tag>Connectivity</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分（一）总结 PART II</title>
    <url>/posts/38216f41/</url>
    <content><![CDATA[<p>本文简要梳理了微积分（一）的一些内容, 并记录一些套路.</p>
<span id="more"></span>
<h1 id="一元函数的微分学">一元函数的微分学</h1>
<h2 id="导数">导数</h2>
<ul>
<li><strong>导数的定义</strong>: 函数 <span
class="math inline">\(y=f(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 处的导数记号为</li>
</ul>
<p><span class="math display">\[
f&#39;(x_0)=y&#39;(x_0)=f&#39;(x)\bigg|_{x=x_0}=\dfrac{\mathrm
df}{\mathrm dx}\bigg|_{x=x_0}=\dfrac{\mathrm dy}{\mathrm
dx}\bigg|_{x=x_0}.
\]</span></p>
<p>值为</p>
<p><span class="math display">\[
f&#39;(x_0)=\lim_{x\to x_0}\dfrac{f(x)-f(x_0)}{x-x_0}=\lim_{\Delta x\to
0}\dfrac{f(x_0+\Delta x)-f(x_0)}{\Delta x}.
\]</span></p>
<p>几何意义为函数图像在 <span class="math inline">\((x_0,
f(x_0))\)</span> 处的切线的斜率.</p>
<p>函数在 <span class="math inline">\(x_0\)</span>
处可导的充要条件是左右导数存在且相等.</p>
<ul>
<li><strong>导函数</strong>: 若 <span class="math inline">\(f\)</span>
在开区间 <span class="math inline">\(I\)</span> 处处可导, 则 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上可导, 存在导函数, 记号为</li>
</ul>
<p><span class="math display">\[
f&#39;, \dfrac{\mathrm df}{\mathrm dx}, y&#39;, \dfrac{\mathrm
dy}{\mathrm dx}.
\]</span></p>
<p>值为</p>
<p><span class="math display">\[
f&#39;(x)=\lim_{h\to 0}\dfrac{f(x+h)-f(x)}{h}, x\in I.
\]</span></p>
<p>若 <span class="math inline">\(I\)</span> 改为闭区间,
则要求在闭区间端点处单侧导数存在.</p>
<ul>
<li><p><strong>连续可导</strong>: <span class="math inline">\(f\)</span>
在 <span class="math inline">\(I\)</span> 存在导函数且导函数连续, 记作
<span class="math inline">\(f\in C^1(I)\)</span>.</p></li>
<li><p><strong>增量公式</strong>: 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(x\)</span> 可导, 则 <span
class="math inline">\(f(x+\Delta x)=f(x)+f&#39;(x)\Delta x+o(\Delta
x)\)</span>.</p></li>
<li><p><strong>可导与连续的关系</strong>: 在 <span
class="math inline">\(x_0\)</span> 处可导一定在 <span
class="math inline">\(x_0\)</span> 连续, 反之未然.</p></li>
<li><p><strong>达布定理</strong>: 导函数的介值定理(无需连续).
由此推出区间上处处有定义的导函数无第一类间断点和无穷型间断点.(可以看<a
href="https://zhuanlan.zhihu.com/p/459668314">文章1</a>和<a
href="https://zhuanlan.zhihu.com/p/486060686">文章2</a>)</p></li>
</ul>
<h2 id="微分">微分</h2>
<ul>
<li><strong>微分的定义</strong>: 若在 <span
class="math inline">\(a\)</span> 附近, 函数 <span
class="math inline">\(y=f(x)\)</span> 有</li>
</ul>
<p><span class="math display">\[
\Delta y = A\Delta x+o(\Delta x).
\]</span></p>
<p>其中 <span class="math inline">\(A\)</span> 与 <span
class="math inline">\(\Delta x\)</span> 无关, 则称 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 可微, 微分为 <span
class="math inline">\(A\Delta x\)</span>, 记作</p>
<p><span class="math display">\[
\mathrm d f(a) = \mathrm d y\bigg|_{x=a}=A\Delta x=A\mathrm dx.
\]</span></p>
<p><span class="math inline">\(\mathrm dy\)</span> 是 <span
class="math inline">\(\Delta y\)</span> 的线性主部.</p>
<p>(约定 <span class="math inline">\(\mathrm dx\)</span> 为 <span
class="math inline">\(\Delta x\)</span>)</p>
<h2 id="一元微分可导与可微的等价性">(一元微分)可导与可微的等价性</h2>
<p>函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 可微的的充要条件是函数在 <span
class="math inline">\(a\)</span> 可导, 且 <span
class="math inline">\(\mathrm dy=f&#39;(x)\mathrm dx\)</span>.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<ol type="1">
<li>必要性. 由 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 可微, 有 <span
class="math inline">\(\Delta y=A\Delta x+o(\Delta x)\)</span>, 则 <span
class="math inline">\(\dfrac{\Delta y}{\Delta x}=A+\dfrac{o(\Delta
x)}{\Delta x}\)</span>. 取 <span class="math inline">\(\Delta x\to
0\)</span>, 有 <span class="math inline">\(f&#39;(a)=\lim\limits_{\Delta
x\to 0}\dfrac{\Delta y}{\Delta x}=A\)</span>.</li>
<li>充分性. 由 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 可导, 由增量公式有 <span
class="math inline">\(\Delta y=f&#39;(a)\Delta x+o(\Delta x)\)</span>,
这就是微分的定义, 故 <span class="math inline">\(\mathrm
dy\bigg|_{x=a}=f&#39;(a)\mathrm dx\)</span>.</li>
</ol>
</blockquote>
</details>
<p>由等价性知, <span class="math inline">\(\mathrm dy=f&#39;(x)\mathrm
dx\)</span>. 从而我们明白了使用 <span
class="math inline">\(\dfrac{\mathrm dy}{\mathrm dx}\)</span>
表示导数记号的合理性. 从而导数又叫微商.</p>
<h2 id="导数与微分的计算">导数与微分的计算</h2>
<p>以下不再区分可导和可微.</p>
<ul>
<li><strong>四则运算</strong>:</li>
</ul>
<ol type="1">
<li><span class="math inline">\((u\pm v)&#39;=u&#39;\pm v&#39;\)</span>,
或者写成 <span class="math inline">\(\mathrm d(u\pm v)=\mathrm du\pm
\mathrm dv\)</span>.</li>
<li><span class="math inline">\((uv)&#39;=u&#39;v+uv&#39;\)</span>,
或者写成 <span class="math inline">\(\mathrm d(uv)=v\mathrm du+u\mathrm
dv\)</span>.</li>
<li><span class="math inline">\((v\ne 0)\)</span>, <span
class="math inline">\(\left(\dfrac{u}{v}\right)&#39;=\dfrac{u&#39;v-uv&#39;}{v^2}\)</span>,
或者写成 <span class="math inline">\(\mathrm
d\left(\dfrac{u}{v}\right)=\dfrac{v\mathrm du-u\mathrm
dv}{v^2}\)</span>.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<ol type="1">
<li>由导数定义 <span class="math display">\[
\begin{aligned}
&amp;(u+v)&#39;
\\
=&amp;\lim_{h\to 0}\dfrac{[u(x+h)+v(x+h)]-[u(x)+v(x)]}{h}
\\
=&amp;\lim_{h\to 0}\dfrac{u(x+h)-u(x)}{h}+\lim_{h\to
0}\dfrac{v(x+h)-v(x)}{h}
\\
=&amp;u&#39;+v&#39;.
\end{aligned}
\]</span> 减法同理.</li>
<li>同样地, <span class="math display">\[
\begin{aligned}
&amp;(uv)&#39;
\\
=&amp;\lim_{h\to 0}\dfrac{u(x+h)v(x+h)-u(x)v(x)}{h}
\\
=&amp;\lim_{h\to 0} \dfrac{v(x+h)[u(x+h)-u(x)]}{h}+\lim_{h\to
0}\dfrac{u(x)[v(x+h)-v(x)]}{h}
\\
=&amp;u&#39;v+uv&#39;.
\end{aligned}
\]</span></li>
<li>同样地, <span class="math display">\[
\begin{aligned}
&amp;\left(\dfrac{u}{v}\right)&#39;
\\
=&amp;\lim_{h\to
0}\dfrac{1}{h}\left[\dfrac{u(x+h)}{v(x+h)}-\dfrac{u(x)}{v(x)}\right]
\\
=&amp;\lim_{h\to 0}\dfrac{u(x+h)v(x)-u(x)v(x+h)}{h\cdot v(x+h)v(x)}
\\
=&amp;\dfrac{1}{v^2}\lim_{h\to
0}\dfrac{v(x)[u(x+h)-u(x)]}{h}-\dfrac{1}{v^2}\lim_{h\to
0}\dfrac{u(x)[v(x+h)-v(x)]}{h}
\\
=&amp;\dfrac{u&#39;v-uv&#39;}{v^2}.
\end{aligned}
\]</span></li>
</ol>
</blockquote>
</details>
<ul>
<li><strong>复合运算</strong></li>
</ul>
<p>若 <span class="math inline">\(y=f(u), u=u(x)\)</span>, 则复合函数
<span class="math inline">\(y=(f\circ u)(x)=f(u(x))\)</span>
的导数记作</p>
<p><span class="math display">\[
f&#39;_x(u(x))=[f(u(x))]&#39;=\dfrac{\mathrm df(u(x))}{\mathrm
dx}=\dfrac{\mathrm dy}{\mathrm dx}.
\]</span></p>
<p>值为</p>
<p><span class="math display">\[
[f(u(x))]&#39;=f&#39;(u(x))\cdot u&#39;(x)=\dfrac{\mathrm dy}{\mathrm
du}\cdot \dfrac{du}{dx}.
\]</span></p>
<blockquote>
<p>注意记号! 不加下标的话, <span
class="math inline">\(f&#39;(u(x))\)</span> 可以看成是把 <span
class="math inline">\(u(x)\)</span> 的值代入 <span
class="math inline">\(f\)</span> 的导函数中(即对 <span
class="math inline">\(u(x)\)</span> 求导). 而 <span
class="math inline">\([f(u(x))]&#39;\)</span>
可以看成是把中括号里面展开成 <span class="math inline">\(x\)</span>
的函数再求导(即对 <span class="math inline">\(x\)</span> 求导).</p>
</blockquote>
<p>上面的法则写成微分形式为</p>
<p><span class="math display">\[
\mathrm d f(u(x))=f&#39;(u(x))u&#39;(x)\mathrm dx.
\]</span></p>
<p>继续用微分的定义, 还发现</p>
<p><span class="math display">\[
\mathrm df(u)=f&#39;(u)\mathrm du.
\]</span></p>
<p>这就是一阶微分的形式不变性.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>该法则证明如下: <span class="math display">\[
\begin{aligned}
&amp;[f(u(x))]&#39;
\\
=&amp;\lim_{h\to 0}\dfrac{f(u(x+h))-f(u(x))}{h}
\\
=&amp;\lim_{\Delta u\to 0}\dfrac{f(u(x+h))-f(u(x))}{u(x+h)-u(x)}\cdot
\lim_{h\to 0}\dfrac{u(x+h)-u(x)}{h}
\\
=&amp;f&#39;(u(x))\cdot u&#39;(x).
\end{aligned}
\]</span></p>
</blockquote>
</details>
<ul>
<li><strong>反函数</strong></li>
</ul>
<p>对于 <span class="math inline">\(y=f(x), x=\varphi(y)\)</span>,
我们对 <span class="math inline">\(y\)</span> 经由 <span
class="math inline">\(\varphi\)</span> 求导有</p>
<p><span class="math display">\[
f&#39;(x)=\dfrac{1}{\varphi&#39;(y)}=\dfrac{1}{\varphi&#39;(f(x))}.
\]</span></p>
<p>写成微分形式有</p>
<p><span class="math display">\[
\mathrm dy=\dfrac{1}{\mathrm dx/\mathrm dy}\mathrm dx.
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>证明如下: <span class="math display">\[
\begin{aligned}
&amp;f&#39;(x)
\\
=&amp;\lim_{\Delta x\to 0}\dfrac{f(x+\Delta x)-f(x)}{(x+\Delta x) - x}
\\
=&amp;\lim_{\Delta y\to 0}\dfrac{(y+\Delta y)-y}{\varphi(y+\Delta
y)-\varphi(y)}
\\
=&amp;\dfrac{1}{\varphi&#39;(y)}=\dfrac{1}{\varphi&#39;(f(x))}
\end{aligned}
\]</span></p>
</blockquote>
</details>
<ul>
<li><strong>隐函数</strong></li>
</ul>
<p>对于 <span class="math inline">\(f(x, y)=0\)</span> 形式的隐函数求导,
如对 <span class="math inline">\(x\)</span> 求导, 只需把 <span
class="math inline">\(y\)</span> 看成 <span
class="math inline">\(x\)</span> 的函数 <span
class="math inline">\(y=y(x)\)</span>, 等式两边同时求导. 别忘记 <span
class="math inline">\(y\)</span> 的部分使用复合求导即可. 或者求微分,
此时不需考虑这些, 直接求即可. 求高阶导是也是如此.</p>
<ul>
<li><strong>参数方程</strong></li>
</ul>
<p>对于参数方程 <span
class="math inline">\(\begin{cases}x=x(t),\\y=y(t).\end{cases}\)</span>,
求导公式为</p>
<p><span class="math display">\[
    \dfrac{\mathrm dy}{\mathrm dx}=\dfrac{\mathrm dy/\mathrm dt}{\mathrm
dx/\mathrm dt}=\dfrac{y&#39;(t)}{x&#39;(t)}.
\]</span></p>
<p>求高阶导时, 如二阶导, 用:</p>
<p><span class="math display">\[
    \dfrac{\mathrm d}{\mathrm dx}\left(\dfrac{\mathrm dy}{\mathrm
dx}\right)=\dfrac{\mathrm d}{\mathrm dx/\mathrm dt}\left(\dfrac{\mathrm
d(y&#39;(t)/x&#39;(t))}{\mathrm dt}\right)
\]</span></p>
<ul>
<li><strong>极坐标</strong></li>
</ul>
<p>对于极坐标 <span class="math inline">\(\rho=\rho(\theta)\)</span>,
转化为参数方程 <span
class="math inline">\(\begin{cases}x=\rho(\theta)\cos \theta \\
y=\rho(\theta)\sin\theta\end{cases}\)</span>, 用参数方程求导得</p>
<p><span class="math display">\[
    \dfrac{\mathrm d y}{\mathrm dx} =
\dfrac{y&#39;(\theta)}{x&#39;(\theta)}=\dfrac{\rho&#39;(\theta)\sin\theta
+\rho(\theta)\cos \theta}{\rho&#39;(\theta)\cos\theta - \rho(\theta)\sin
\theta}.
\]</span></p>
<ul>
<li><strong>基本公式表</strong></li>
</ul>
<details>
<summary>
<b>展开表格</b>
</summary>
<p><img src="derivative_table1.png" /></p>
<p><img src="derivative_table2.png" /></p>
</details>
<details>
<summary>
<b>展开前 12 项证明</b>
</summary>
<blockquote>
<ol type="1">
<li><p><span class="math inline">\(f(x)=c\)</span>, 则 <span
class="math inline">\(f&#39;(x)=\lim\limits_{h\to
0}\dfrac{0-0}{h}=0\)</span>.</p></li>
<li><p><span class="math inline">\(f(x)=x^\mu\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\lim_{h\to 0}\dfrac{(x+h)^\mu-x^\mu}{h}
\\
&amp;=x^\mu\lim_{h\to 0}\dfrac{(1+\frac{h}{x})^\mu-1}{h}
\\
&amp;=x^\mu \cdot \dfrac{\mu}{x}=\mu x^{\mu-1}.
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(f(x)=e^x\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\lim_{h\to 0}\dfrac{e^{x+h}-e^x}{h}
\\
&amp;=e^x\cdot \lim_{h\to 0}\dfrac{e^h-1}{h}=e^x.
\end{aligned}
\]</span> <span class="math inline">\(f(x)=a^x\)</span> 可以 写成 <span
class="math inline">\(f(x)=e^{x\ln a}\)</span> 再用复合函数求导.</p>
<p>进一步我们可以得到, <span class="math inline">\((\ln
|x|)&#39;=\dfrac{1}{x}\)</span>.</p></li>
<li><p><span class="math inline">\(f(x)=\ln x\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\lim_{h\to 0}\dfrac{\ln(x+h)-\ln x}{h}
\\
&amp;=\lim_{h\to 0}\dfrac{\ln (1+\dfrac{h}{x})}{h}
\\
&amp;=\dfrac{1}{x}.
\end{aligned}
\]</span> <span class="math inline">\(f(x)=\log_a x\)</span>, 可以写成
<span class="math inline">\(f(x)=\dfrac{\ln x}{\ln a}\)</span>
再求导.</p></li>
<li><p><span class="math inline">\(f(x)=\sin x\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\lim_{h\to 0}\dfrac{\sin(x+h)-\sin(x)}{h}
\\
&amp;=\lim_{h\to 0}\dfrac{2\cos(x+h/2)\sin(h/2)}{h}
\\
&amp;=\cos x.
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(f(x)=\cos
x=\sin(x+\dfrac{\pi}{2})\)</span>, 则 <span
class="math inline">\(f&#39;(x)=\cos(x+\dfrac{\pi}{2})=-\sin
x\)</span>.</p></li>
<li><p><span class="math inline">\(f(x)=\tan x\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\left(\dfrac{\sin x}{\cos x}\right)&#39;
\\
&amp;=\dfrac{\cos^2 x+\sin^2 x}{\cos^2 x}
\\
&amp;=\dfrac{1}{\cos^2x}=\sec^2 x.
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(f(x)=\cot
x=\tan(\dfrac{\pi}{2}-x)\)</span>, 则 <span
class="math inline">\(f&#39;(x)=-\sec^2(\dfrac{\pi}{2}-x)=-\csc^2
x\)</span>.</p></li>
<li><p><span class="math inline">\(y=f(x)=\arcsin x, x=\varphi(y)=\sin
y, y\in\left[-\dfrac{\pi}{2}, \dfrac{\pi}{2}\right]\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\dfrac{1}{\varphi&#39;(y)}
\\
&amp;=\dfrac{1}{\cos y}
\\
&amp;=\dfrac{1}{\sqrt{1-\sin^2y}}
\\
&amp;=\dfrac{1}{\sqrt{1-x^2}}.
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(f(x)=\arccos x=\dfrac{\pi}{2}-\arcsin
x\)</span>, 则 <span
class="math inline">\(f&#39;(x)=-\dfrac{1}{\sqrt{1-x^2}}\)</span>.</p></li>
<li><p><span class="math inline">\(y=f(x)=\arctan x, x=\varphi(y)=\tan
y\)</span>, 则 <span class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\dfrac{1}{\varphi&#39;(y)}
\\
&amp;=\dfrac{1}{\sec^2y}
\\
&amp;=\dfrac{1}{\tan^2y+1}
\\
&amp;=\dfrac{1}{1+x^2}.
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(f(x)=\operatorname{arccot}
x=\dfrac{\pi}{2}-\arctan x\)</span>, 则 <span
class="math inline">\(f&#39;(x)=-\dfrac{1}{1+x^2}\)</span>.</p></li>
</ol>
</blockquote>
</details>
<details>
<summary>
<b>双曲函数扩展及后 6 项证明</b>
</summary>
<blockquote>
<p>关于更详细的内容, 你可以看<a
href="https://zhuanlan.zhihu.com/p/20042215">这篇知乎专栏</a>,
也可以看看同济的高等数学课本.</p>
<ul>
<li><p>双曲函数的定义 <span class="math display">\[
\begin{aligned}
\operatorname{sh} x&amp;=\dfrac{e^x-e^{-x}}{2},
\\
\operatorname{ch} x&amp;=\dfrac{e^x+e^{-x}}{2},
\\
\operatorname{th} x&amp;=\dfrac{\operatorname{sh} x}{\operatorname{ch}
x}=\dfrac{e^x-e^{-x}}{e^x+e^{-x}},
\\
\operatorname{arsh} x&amp;=\ln(x+\sqrt {x^2+1}),
\\
\operatorname{arch} x&amp;=\ln(x+\sqrt {x^2-1}),
\\
\operatorname{arth} x&amp;=\dfrac{1}{2}\ln\dfrac{1+x}{1-x}.
\end{aligned}
\]</span></p></li>
<li><p>重要的性质 <span class="math display">\[
\begin{aligned}
\operatorname{sh} (x+y)&amp;=\operatorname{sh} x\operatorname{ch}
y+\operatorname{ch} x\operatorname{sh} y,
\\
\operatorname{sh} (x-y)&amp;=\operatorname{sh} x\operatorname{ch}
y-\operatorname{ch} x\operatorname{sh} y,
\\
\operatorname{ch} (x+y)&amp;=\operatorname{ch} x\operatorname{ch}
y+\operatorname{sh} x\operatorname{sh} y,
\\
\operatorname{ch} (x-y)&amp;=\operatorname{ch} x\operatorname{ch} y-
\operatorname{sh} x\operatorname{sh} y.
\end{aligned}
\]</span> 从上面可得一些性质, 需要记住的是 <span
class="math inline">\(\operatorname{ch}^2 x-\operatorname{sh}^2
x=1\)</span>.</p></li>
<li><p>证明导数公式</p></li>
</ul>
<ol start="13" type="1">
<li><span class="math inline">\(f(x)=\operatorname{sh}
x=\dfrac{e^x-e^{-x}}{2}\)</span>, 则 <span
class="math inline">\(f&#39;(x)=    \dfrac{e^x+e^{-x}}{2}=\operatorname{ch}
x\)</span>.</li>
<li>类似于 13. 可得, <span class="math inline">\(f(x)=\operatorname{ch}
x\)</span>, 则 <span class="math inline">\(f&#39;(x)=\operatorname{sh}
x\)</span>.</li>
<li><span class="math inline">\(f(x)=\operatorname{th}
x=\dfrac{\operatorname{sh} x}{\operatorname{ch} x}\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\dfrac{\operatorname{ch}^2 x-\operatorname{sh}^2
x}{\operatorname{ch}^2 x}=\dfrac{1}{\operatorname{ch}^2 x}
\end{aligned}
\]</span></li>
<li><span class="math inline">\(y= f(x)=\operatorname{arsh} x,
x=\varphi(y)=\operatorname{sh} y\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\dfrac{1}{\varphi&#39;(y)}
\\
&amp;=\dfrac{1}{\operatorname{ch}(y)}
\\
&amp;=\dfrac{1}{\sqrt{\operatorname{sh}^2 y+1}}
\\
&amp;=\dfrac{1}{\sqrt{x^2+1}}
\end{aligned}
\]</span></li>
<li><span class="math inline">\(y= f(x)=\operatorname{arch}x,
x=\varphi(y)=\operatorname{ch} y\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\dfrac{1}{\varphi&#39;(y)}
\\
&amp;=\dfrac{1}{\operatorname{sh} y}
\\
&amp;=\dfrac{1}{\sqrt{\operatorname{ch}^2y - 1}}
\\
&amp;=\dfrac{1}{\sqrt {x^2-1}}
\end{aligned}
\]</span></li>
<li><span class="math inline">\(y=f(x)=\operatorname{arth} x,
x=\varphi(y)=\operatorname{th}y\)</span>, 则 <span
class="math display">\[
\begin{aligned}
f&#39;(x)&amp;=\dfrac{1}{\varphi&#39;(y)}
\\
&amp;=\operatorname{ch}^2 y
\\
&amp;=\dfrac{\operatorname{ch}^2y}{\operatorname{ch}^2y-\operatorname{sh}^2y}
\\
&amp;=\dfrac{1}{1-\operatorname{th}^2y}
\\
&amp;=\dfrac{1}{1-x^2}
\end{aligned}
\]</span></li>
</ol>
</blockquote>
</details>
<h2 id="高阶导数和高阶微分">高阶导数和高阶微分</h2>
<ul>
<li><span class="math inline">\(n\)</span> 阶导数的定义: <span
class="math inline">\(y^{(n)}=(y^{(n-1)})&#39;\)</span></li>
</ul>
<p><span class="math inline">\(n\)</span> 阶导数记作</p>
<p><span class="math display">\[
    f^{(n)}, \dfrac{\mathrm d^nf}{\mathrm d x^n}, y^{(n)},
\dfrac{\mathrm d^ny}{\mathrm d x^n}
\]</span></p>
<p>若 <span class="math inline">\(n\le 3\)</span>, 也可以用若干撇 <span
class="math inline">\((&#39;)\)</span> 代替.</p>
<ul>
<li><span class="math inline">\(n\)</span> 阶连续可导: <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上 <span
class="math inline">\(n\)</span> 阶导函数连续, 记作 <span
class="math inline">\(f\in C^n(I)\)</span>.</li>
</ul>
<details>
<summary>
<b>常用的高阶导数</b>
</summary>
<blockquote>
<p><span class="math inline">\(f(x)=c\)</span>, 则 <span
class="math inline">\(f^{(n)}(x)=0, n\ge 1\)</span>.</p>
<p><span class="math inline">\(f(x)=a^x\)</span>, 则 <span
class="math inline">\(f^{(n)}(x)=a^x(\ln a)^n\)</span>.</p>
<p><span class="math inline">\(f(x)=\ln x\)</span>, 则 <span
class="math inline">\(f^{(n)}(x)=\dfrac{(-1)^{n-1}(n-1)!}{x^n}, n\ge
1\)</span>.</p>
<p><span class="math inline">\(f(x)=\sin (ax+b)\)</span>, 则 <span
class="math inline">\(f^{(n)}(x)=a^{n}\sin
(ax+b+\dfrac{n\pi}{2})\)</span>. <span class="math inline">\(f(x)=\cos
(ax+b)\)</span> 类似.</p>
<p><span class="math inline">\(f(x)=\dfrac{1}{x+a}\)</span>, 则 <span
class="math inline">\(f^{(n)}(x)=\dfrac{(-1)^n\cdot
n!}{(x+a)^{n+1}}\)</span>.</p>
<p><span class="math inline">\(f(x)=x^\mu\)</span>, 则 <span
class="math inline">\(f^{(n)}(x)=\mu^{\underline{n}}x^{\mu-n}\)</span>,
其中 <span class="math inline">\(\mu^{\underline{n}}=\mu(\mu-1)\cdots
(\mu-n+1)\)</span>.</p>
</blockquote>
</details>
<ul>
<li>高阶导数运算法则</li>
</ul>
<ol type="1">
<li><span class="math inline">\((u\pm v)^{(n)}=u^{(n)}\pm
v^{(n)}\)</span></li>
<li><span class="math inline">\((cu)^{(n)}=cu^{(n)}\)</span>.</li>
<li>莱布尼兹公式: <span
class="math inline">\((uv)^{(n)}=\sum\limits_{i=0}^nC_n^iu^{(n-i)}v^{(i)}\)</span></li>
</ol>
<details>
<summary>
<b>莱布尼斯公式证明</b>
</summary>
<blockquote>
<p>用归纳法, 当 <span class="math inline">\(n=0\)</span> 时成立.</p>
<p>设当 <span class="math inline">\(n=k-1(k\ge 1)\)</span> 时成立, 即
<span
class="math inline">\((uv)^{(k-1)}=\sum\limits_{i=0}^{k-1}C_{k-1}^iu^{(k-1-i)}v^{i}\)</span>.</p>
<p>则当 <span class="math inline">\(n=k\)</span> 时, 有 <span
class="math display">\[
\begin{aligned}
(uv)^{(k)}&amp;=[(uv)&#39;]^{(k-1)}
\\
&amp;=(u&#39;v)^{(k-1)}+(uv&#39;)^{k-1}
\\
&amp;=\sum_{i=0}^{k-1}C_{k-1}^iu^{(k-i)}v^{(i)}+\sum_{i=0}^{k-1}C_{k-1}^iu^{(k-1-i)}v^{(i+1)}
\\
&amp;=C_{k-1}^0u^{(k)}v^{(0)}+C_{k-1}^{k-1}u^{(0)}v^{(k)}+\sum_{i=1}^{k-1}(C_{k-1}^i+C_{k-1}^{i-1})u^{(k-i)}v^{(i)}
\\
&amp;=\sum_{i=0}^kC_k^iu^{(k-i)}v^{(i)}.
\end{aligned}
\]</span> 由数学归纳法, 得证.</p>
</blockquote>
</details>
<ul>
<li>高阶微分的定义: <span class="math inline">\(\mathrm d^ny=\mathrm
d(\mathrm dy)\)</span>.</li>
</ul>
<p>如果 <span class="math inline">\(x\)</span> 是自变量, 那么:</p>
<p>由于 <span class="math inline">\(\mathrm d^2 y=\mathrm
d(y&#39;\mathrm dx)=y&#39;&#39;\mathrm dx\cdot \mathrm dx+y&#39;\mathrm
d(\mathrm dx)\)</span>, 而 <span class="math inline">\(\mathrm d(\mathrm
dx)=0\)</span>, 记 <span class="math inline">\((\mathrm dx)^2\)</span>
为 <span class="math inline">\(\mathrm dx^2\)</span>, 故写为 <span
class="math inline">\(\mathrm d^2y=y&#39;&#39;\mathrm dx^2\)</span>.</p>
<p>同理, <span class="math inline">\(\mathrm d^ny=f^{(n)}(x)\mathrm
dx^n\)</span>. 从而我们可以理解高阶导数记号的合理性.</p>
<p>这样的高阶微分同样具有高阶导数的三条运算法则.</p>
<details>
<summary>
<b>但是高阶导数不具有形式不变性!</b>
</summary>
<blockquote>
<p>比如 <span class="math inline">\(y=f(x), x=x(t)\)</span>,
则在上面的式子中 <span class="math inline">\(\mathrm
d^2y=y&#39;&#39;\mathrm dx^2+y&#39;\mathrm d^2x\)</span>, 其中 <span
class="math inline">\(\mathrm d^2x\)</span> 是 <span
class="math inline">\(x(t)\)</span> 的二阶微分, 一般情况下不为 <span
class="math inline">\(0\)</span>.故此时不具有 <span
class="math inline">\(\mathrm d^2y=y&#39;&#39;\mathrm dx^2\)</span>
的性质. 对更高阶的微分更是如此.</p>
</blockquote>
</details>
<h2 id="微分中值定理">微分中值定理</h2>
<ul>
<li>极值: <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上有定义, 若在 <span
class="math inline">\(a\in I\)</span> 的一个邻域 <span
class="math inline">\(U(a)\)</span> 内, 有 <span
class="math inline">\(\forall x\in U(a)\)</span>, <span
class="math inline">\(f(x)\le(\ge)f(a)\)</span>, 则称 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 处取到极大(小)值, <span
class="math inline">\(a\)</span> 为极大(小)值点. 若严格不等式成立,
则称是严格极值.</li>
<li>费马定理: 可导的极值点一定是驻点(导数为零的点).
(可以用左、右极限的保号性证明必须为零)</li>
</ul>
<p>注意: 反之未必然.</p>
<ul>
<li>罗尔定理: 若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 连续, 在 <span
class="math inline">\((a, b)\)</span> 可导, 且 <span
class="math inline">\(f(a)=f(b)\)</span>, 则 <span
class="math inline">\(\exists \xi\in (a, b),
f&#39;(\xi)=0\)</span>.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>设在 <span class="math inline">\([a, b]\)</span> 上 <span
class="math inline">\(f\)</span> 有最大值 <span
class="math inline">\(M\)</span>, 最小值 <span
class="math inline">\(m\)</span>.</p>
<ol type="1">
<li>若 <span class="math inline">\(M=m\)</span>, 则 <span
class="math inline">\(f(x)\equiv c, x\in [a, b]\)</span>, 故 <span
class="math inline">\(f&#39;(x)=0, \forall x\in(a, b)\)</span>,
得证.</li>
<li>若 <span class="math inline">\(m&lt;M\)</span>, 则 <span
class="math inline">\(m\)</span> 和 <span
class="math inline">\(M\)</span> 取到处至少有一不为端点值(否则应该相等),
不妨是最大值 <span class="math inline">\(M\)</span>. 记为 <span
class="math inline">\(f(c)=M\)</span>, 则 <span
class="math inline">\(f(c)=M\)</span> 同时也是极大值. 则由费马定理, 有
<span class="math inline">\(f&#39;(c)=0\)</span>. 证毕.</li>
</ol>
</blockquote>
</details>
<ul>
<li>拉格朗日中值定理: 若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 连续, 在 <span
class="math inline">\((a, b)\)</span> 可导, 则 <span
class="math inline">\(\exists \xi\in (a, b)\)</span>, 使得</li>
</ul>
<p><span class="math display">\[
    f&#39;(\xi)=\dfrac{f(b)-f(a)}{b-a}.
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p><strong>证法1</strong>: 直线 <span class="math inline">\(AB\)</span>
的方程为 <span
class="math inline">\(y=f(a)+\dfrac{f(b)-f(a)}{b-a}(x-a)\)</span>, 让
<span class="math inline">\(f(x)\)</span> 减去它, 构造辅助函数: <span
class="math display">\[
F(x) = f(x)-f(a)-\dfrac{f(b)-f(a)}{b-a}(x-a).
\]</span> 则 <span class="math inline">\(F(b)=F(a)=0\)</span>,
由罗尔定理, 存在 <span class="math inline">\(\xi\in(a, b)\)</span>, 使得
<span class="math inline">\(F&#39;(\xi)=0\)</span>, 即 <span
class="math display">\[
f&#39;(\xi)=\dfrac{f(b)-f(a)}{b-a}.
\]</span> <strong>证法2</strong>: 即 <span
class="math inline">\(f&#39;(x)-\dfrac{f(b)-f(a)}{b-a}=0\)</span> 有根,
令 <span
class="math inline">\(F(x)=f(x)-\dfrac{f(b)-f(a)}{b-a}x\)</span>, 则
<span class="math inline">\(F(a)=F(b)=\dfrac{bf(a)-af(b)}{b-a}\)</span>,
由罗尔定理, 存在 <span class="math inline">\(\xi\in(a, b)\)</span>, 使得
<span class="math inline">\(F&#39;(\xi)=0\)</span>, 得证.</p>
</blockquote>
</details>
<blockquote>
<p><strong>推论 1</strong>: (有限增量公式) <span
class="math inline">\(f(x+\Delta x)=f(x)+f&#39;(x+\theta \Delta x)\Delta
x, \theta\in(0, 1)\)</span>.(在 <span class="math inline">\(x\)</span>
和 <span class="math inline">\(x+\Delta x\)</span>
之间使用拉格朗日中值定理)</p>
<p><strong>推论 2</strong>: 设 <span class="math inline">\(f\)</span> 在
<span class="math inline">\((a, b)\)</span> 上可导, 则 <span
class="math inline">\((a, b)\)</span> 上 <span
class="math inline">\(f(x)\)</span> 是常数的充要条件是 <span
class="math inline">\(f&#39;(x)=0\)</span>.(必要性显然,
充分性在任意两点间用拉格朗日中值定理)</p>
<p><strong>推论 3</strong>: 设 <span class="math inline">\(f\)</span> 和
<span class="math inline">\(g\)</span> 在 <span
class="math inline">\(I\)</span> 可导, 且 <span
class="math inline">\(f&#39;(x)=g&#39;(x)\)</span>, 则在 <span
class="math inline">\(I\)</span> 内有 <span
class="math inline">\(f(x)=g(x)+C\)</span>, <span
class="math inline">\(C\)</span> 为常数.(由推论 2 可得)</p>
</blockquote>
<ul>
<li>柯西中值定理: 设 <span class="math inline">\(f, g\)</span> 均在
<span class="math inline">\([a, b]\)</span> 连续, 在 <span
class="math inline">\((a, b)\)</span> 可导, 且在 <span
class="math inline">\((a, b)\)</span> 上 <span
class="math inline">\(g&#39;(x)\ne 0\)</span>, 则 <span
class="math inline">\(\exists \xi\in(a, b)\)</span>, 使得 <span
class="math display">\[
  \dfrac{f(b)-f(a)}{g(b)-g(a)}=\dfrac{f&#39;(\xi)}{g&#39;(\xi)}.
\]</span></li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>即证 <span
class="math inline">\([g(b)-g(a)]f&#39;(x)-[f(b)-f(a)]g&#39;(x)=0\)</span>
有根. 构造 <span
class="math inline">\(F(x)=[g(b)-g(a)]f(x)-[f(b)-f(a)]g(x)\)</span>, 则
<span class="math inline">\(F(a)=F(b)=f(a)g(b)-f(b)g(a)\)</span>,
由罗尔定律可知存在 <span class="math inline">\(\xi\in(a, b)\)</span>,
使得 <span class="math inline">\(F&#39;(\xi)=0\)</span>, 变形后立得.</p>
</blockquote>
</details>
<h2 id="洛必达法则">洛必达法则</h2>
<p>用于解决求不定型极限的问题(主要是 <span
class="math inline">\(\dfrac{0}{0}, \dfrac{\infty}{\infty}\)</span>,
其它可以转化为这两个)</p>
<p>求 <span class="math inline">\(\dfrac{0}{0}\)</span>
型的法则(有穷点): 若在 <span class="math inline">\(U^o(a)\)</span> 中,
<span class="math inline">\(f&#39;(x), g&#39;(x)\)</span> 存在且 <span
class="math inline">\(g&#39;(x)\ne 0\)</span>, <span
class="math inline">\(x\to a\)</span> 时 <span
class="math inline">\(f(x), g(x)\to 0\)</span>, 且 <span
class="math inline">\(\lim\limits_{x\to
a}\dfrac{f&#39;(x)}{g&#39;(x)}=A\)</span>(或无穷), 则有</p>
<p><span class="math display">\[
    \lim_{x\to a}\dfrac{f(x)}{g(x)}=\lim_{x\to
a}\dfrac{f&#39;(x)}{g&#39;(x)}.
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>不妨填充可去间断点 <span class="math inline">\(f(a)=g(a)=0\)</span>.
对右邻域内的任一点 <span class="math inline">\(x\)</span>, 在 <span
class="math inline">\((a, x)\)</span> 之间使用拉格朗日中值定理, 可得
<span class="math display">\[
\dfrac{f(x)}{g(x)}=\dfrac{f(x)-f(a)}{g(x)-g(a)}=\dfrac{f&#39;_+(\xi)}{g&#39;_+(\xi)}.
\]</span></p>
<p>其中 <span class="math inline">\(\xi\in(a, x)\)</span>. 当 <span
class="math inline">\(x\to a+\)</span> 时, <span
class="math inline">\(\xi\to a+\)</span>. 故取极限可得</p>
<p><span class="math display">\[
\lim_{x\to a+}\dfrac{f(x)}{g(x)}=\lim_{x\to
a+}\dfrac{f&#39;(x)}{g&#39;(x)}.
\]</span></p>
<p>对左侧同理.</p>
</blockquote>
</details>
<details>
<summary>
<b>其它几个类似的法则</b>
</summary>
<blockquote>
<p>求 <span class="math inline">\(\dfrac{0}{0}\)</span>
型的法则(无穷点): 若在 <span class="math inline">\(|x|&gt;N\)</span> 时,
<span class="math inline">\(f&#39;(x), g&#39;(x)\)</span> 存在且 <span
class="math inline">\(g&#39;(x)\ne 0\)</span>, <span
class="math inline">\(x\to \infty\)</span> 时 <span
class="math inline">\(f(x), g(x)\to 0\)</span>, 且 <span
class="math inline">\(\lim\limits_{x\to
\infty}\dfrac{f&#39;(x)}{g&#39;(x)}=A\)</span>(或无穷), 则有</p>
<p><span class="math display">\[
\lim_{x\to \infty}\dfrac{f(x)}{g(x)}=\lim_{x\to
\infty}\dfrac{f&#39;(x)}{g&#39;(x)}.
\]</span></p>
<p>证明方法: 作代换 <span class="math inline">\(t=\dfrac{1}{x}\to
0\)</span>, 用第一个法则.</p>
<p>求 <span class="math inline">\(\dfrac{\infty}{\infty}\)</span>
型的法则(有穷点): 若在 <span class="math inline">\(U^o(a)\)</span> 中,
<span class="math inline">\(f&#39;(x), g&#39;(x)\)</span> 存在且 <span
class="math inline">\(g&#39;(x)\ne 0\)</span>, <span
class="math inline">\(x\to a\)</span> 时 <span
class="math inline">\(f(x), g(x)\to \infty\)</span>, 且 <span
class="math inline">\(\lim\limits_{x\to
a}\dfrac{f&#39;(x)}{g&#39;(x)}=A\)</span>(或无穷), 则有</p>
<p><span class="math display">\[
\lim_{x\to a}\dfrac{f(x)}{g(x)}=\lim_{x\to
a}\dfrac{f&#39;(x)}{g&#39;(x)}.
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>只证右侧, 左侧同理. 分情况讨论.</p>
<p><strong>情况 1</strong>: <span class="math inline">\(A=0\)</span>. 则
<span class="math inline">\(\lim\limits_{x\to
a+}\dfrac{f&#39;(x)}{g&#39;(x)}=0\)</span>, 故 <span
class="math inline">\(\forall\varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta &gt;0\)</span>, 当 <span
class="math inline">\(a&lt;x&lt;a+\delta\)</span> 时, 有 <span
class="math inline">\(\left|\dfrac{f&#39;(x)}{g&#39;(x)}\right|&lt;\dfrac{\varepsilon}{2}\)</span>.</p>
<p>由柯西中值定理, 存在 <span class="math inline">\(\xi\in(x,
a+\delta)\)</span>, 使得 <span class="math display">\[
\dfrac{f(x)-f(a+\delta)}{g(x)-g(a+\delta)}=\dfrac{f&#39;(\xi)}{g&#39;(\xi)}.
\]</span> 即 <span class="math display">\[
\dfrac{f(x)}{g(x)}=\dfrac{f(a+\delta)}{g(x)}+\dfrac{f&#39;(\xi)}{g&#39;(\xi)}\left[1-\dfrac{g(a+\delta)}{g(x)}\right]
\]</span> 则容易证明得到(因为 <span class="math inline">\(g(x)\to
\infty\)</span>), 存在 <span
class="math inline">\(\eta&lt;\delta\)</span>, 使得 <span
class="math inline">\(a&lt;x&lt;a+\eta\)</span> 时, 有 <span
class="math display">\[
\left|\dfrac{f(x)}{g(x)}\right|&lt;\varepsilon
\]</span> 故 <span class="math inline">\(\lim\limits_{x\to
a+}\dfrac{f(x)}{g(x)}=0\)</span></p>
<p><strong>情况 2</strong>: <span class="math inline">\(A\)</span>
为常数, 则令 <span
class="math inline">\(f_0=f-Ag\)</span>(注意到上面的证明过程只用到了
<span class="math inline">\(g(x)\to \infty\)</span>, 故其实 <span
class="math inline">\(f(x)\to\infty\)</span> 不是本质的条件),
即可证明.</p>
<p><strong>情况 3</strong>: <span class="math inline">\(A\)</span>
为无穷, 把情况 1 中 <span class="math inline">\(\varepsilon\)</span>
限制改为 <span class="math inline">\(G\)</span> 限制即可.</p>
<p>证毕.</p>
</blockquote>
</details>
<p>求 <span class="math inline">\(\dfrac{\infty}{\infty}\)</span>
型的法则(无穷点): 若在 <span class="math inline">\(|x|&gt;N\)</span> 时,
<span class="math inline">\(f&#39;(x), g&#39;(x)\)</span> 存在且 <span
class="math inline">\(g&#39;(x)\ne 0\)</span>, <span
class="math inline">\(x\to \infty\)</span> 时 <span
class="math inline">\(f(x), g(x)\to \infty\)</span>, 且 <span
class="math inline">\(\lim\limits_{x\to
\infty}\dfrac{f&#39;(x)}{g&#39;(x)}=A\)</span>(或无穷), 则有</p>
<p><span class="math display">\[
\lim_{x\to \infty}\dfrac{f(x)}{g(x)}=\lim_{x\to
\infty}\dfrac{f&#39;(x)}{g&#39;(x)}.
\]</span></p>
<p>证明方法: 作代换 <span class="math inline">\(t=\dfrac{1}{x}\to
0\)</span>, 用上一个法则.</p>
</blockquote>
</details>
<h2 id="泰勒公式">泰勒公式</h2>
<ul>
<li>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 处有直到 <span
class="math inline">\(n\)</span> 阶的导数, 则 <span
class="math inline">\(n\)</span> 阶泰勒多项式为</li>
</ul>
<p><span class="math display">\[
    P_n(x)=\sum_{k=0}^n\dfrac{f^{(k)}(x_0)}{k!}(x-a)^k
\]</span></p>
<p>则 <span class="math inline">\(f(x)=P_n(x)+r_n(x)\)</span>, <span
class="math inline">\(r_n(x)\)</span> 称为余项.</p>
<p>可知:</p>
<p><span class="math display">\[
\begin{aligned}
    P^{(k)}(a)&amp;=f^{(k)}(a), &amp;(0\le k\le n)
    \\
    P^{(k)}(a)&amp;=0, &amp;(k\ge n+1)
    \\
    r_n^{(k)}(a)&amp;=0, &amp;(0\le k\le n)
    \\
    r_n^{(k)}(a)&amp;=f^{(k)}(a), &amp;(k \ge n+1, \textnormal{若存在})
\end{aligned}
\]</span></p>
<ul>
<li>皮亚诺余项: <span
class="math inline">\(r_n(x)=o((x-a)^n)\)</span>.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>因为 <span class="math inline">\(f\)</span> 有直到 <span
class="math inline">\(n\)</span> 阶的导数, 故在 <span
class="math inline">\(a\)</span> 的邻域内有直到 <span
class="math inline">\(n-1\)</span> 阶的导数. <span
class="math display">\[
\begin{aligned}
\lim_{x\to a}\dfrac{r_n(x)}{(x-a)^n}&amp;=\lim_{x\to
a}\dfrac{f(x)-P_n(x)}{(x-a)^n}
\\
&amp;=\lim_{x\to a}\dfrac{f&#39;(x)-P_n&#39;(x)}{n(x-a)^{n-1}}
\\
&amp;=\cdots
\\
&amp;=\lim_{x\to a}\dfrac{f^{(n-1)}(x)-P_n^{(n-1)}(x)}{n!(x-a)}
\\
&amp;=\dfrac{1}{n!}\lim_{x\to
a}\left[\dfrac{f^{(n-1)}(x)-f^{(n-1)}(a)}{x-a}-\dfrac{P^{(n-1)}(x)-P^{(n-1)}(a)}{x-a}\right]
\\
&amp;=\dfrac{1}{n!}[f^{(n)}(x)-P^{(n)}(x)] = 0.
\end{aligned}
\]</span> 故 <span class="math inline">\(r_n(x)=o((x-a)^n)\)</span>.</p>
</blockquote>
</details>
<ul>
<li>拉格朗日余项. 使用它需要附加条件: 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 的<strong>邻域内</strong>有直到 <span
class="math inline">\(n+1\)</span> 阶导数, 则 <span
class="math display">\[
  r_n(x)=\dfrac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1}=\dfrac{f^{(n+1)}(a+\theta(x-a))}{(n+1)!}(x-a)^{n+1}.
\]</span> 其中, <span class="math inline">\(\xi\)</span> 在 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(x\)</span> 之间(不含), <span
class="math inline">\(0&lt;\theta&lt;1\)</span>.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p><span class="math inline">\(n+1\)</span> 次使用柯西中值定理: <span
class="math display">\[
\begin{aligned}
\dfrac{r_n(x)}{(x-a)^{n+1}}&amp;=\dfrac{r_n(x)-r_n(a)}{(x-a)^{n+1}-(a-a)^{n+1}}
\\
&amp;=\dfrac{r_n&#39;(\xi_1)}{(n+1)(\xi_1-a)^n}
\\
&amp;=\dfrac{r_n&#39;(\xi_1)-r_n&#39;(a)}{(n+1)[(\xi_1-a)^n-(a-a)^n]}
\\
&amp;=\dfrac{r_n&#39;&#39;(\xi_2)}{(n+1)n(\xi_2-a)^{n-1}}
\\
&amp;=\cdots
\\
&amp;=\dfrac{r^{(n)}(\xi_n)}{(n+1)!(\xi_n-a)}
\\
&amp;=\dfrac{r^{(n)}(\xi_n)-r^{(n)}(a)}{(n+1)!(\xi_n-a)}
\\
&amp;=\dfrac{r^{(n+1)}(\xi)}{(n+1)!}=\dfrac{f^{(n+1)}(\xi)}{(n+1)!}
\end{aligned}
\]</span> 其中 <span class="math inline">\(\xi_1\)</span> 位于 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(x\)</span> 之间, <span
class="math inline">\(\xi_i\)</span> 位于 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(\xi_{i-1}\)</span> 之间 <span
class="math inline">\((2\le i\le n)\)</span>, <span
class="math inline">\(\xi\)</span> 位于 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(\xi_n\)</span> 之间, 也就位于 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(x\)</span> 之间.</p>
<p>其增量形式显然.</p>
</blockquote>
</details>
<ul>
<li>麦克劳林公式: 在 <span class="math inline">\(0\)</span>
处展开的泰勒公式.</li>
</ul>
<p>可以使用麦克劳林公式求无穷小主部, 从而求解极限.</p>
<details>
<summary>
<b>常用的麦克劳林公式</b>
</summary>
<blockquote>
<p>如下: <span class="math display">\[
\begin{aligned}
e^x&amp;=1+x+\dfrac{x^2}{2!}+\cdots+\dfrac{x^n}{n!}+o(x^n),
\\
\ln(1+x)&amp;=x-\dfrac{x^2}{2}+\cdots+\dfrac{(-1)^{n-1}x^n}{n}+o(x^n),
\\
\sin
x&amp;=x-\dfrac{x^3}{3!}+\cdots+\dfrac{(-1)^{m-1}x^{2m-1}}{(2m-1)!}+o(x^{2m}),
\\
\cos x&amp;=1-\dfrac{x^2}{2!}+\cdots
+\dfrac{(-1)^{m-1}x^{2m}}{(2m)!}+o(x^{2m+1}),
\\
(1+x)^\mu&amp;=1+\mu
x+\dfrac{\mu(\mu-1)x^2}{2!}+\cdots+\dfrac{\mu^{\underline{n}}x^n}{n!}+o(x^n),
\\
\dfrac{1}{1+x}&amp;=1-x+x^2-\cdots+(-1)^nx^n+o(x^{n}),
\\
\dfrac{1}{1-x}&amp;=1+x+x^2+\cdots+x^n+o(x^n),
\\
\arctan
x&amp;=x-\dfrac{x^3}{3}+\cdots+\dfrac{(-1)^{m-1}x^{2m-1}}{2m-1}+o(x^{2m}),
\\
\tan x&amp;=x+\dfrac{x^3}{3}+\dfrac{2x^5}{15}+o(x^6),
\\
\operatorname{sh}
x&amp;=x+\dfrac{x^3}{3!}+\cdots+\dfrac{x^{2m-1}}{(2m-1)!}+o(x^{2m}),
\\
\operatorname{ch}
x&amp;=1+\dfrac{x^2}{2!}+\cdots+\dfrac{x^{2m}}{(2m)!}+o(x^{2m+1}).
\end{aligned}
\]</span></p>
</blockquote>
</details>
<h2 id="导数与增减性">导数与增减性</h2>
<ul>
<li><strong>定理 1</strong>(严格单调的充分条件) 若 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 连续, 在 <span class="math inline">\((a, b)\)</span> 可导,
则若 <span class="math inline">\(f&#39;(x)&gt;0(&lt;0), \forall x\in (a,
b)\)</span>, 则 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 严格递增(减).
(可以使用拉格朗日中值定理证明)</li>
</ul>
<p>反之, 则可能区间内有孤立的若干点满足非严格不等式.(或者说,
满足非严格不等式的点不构成区间, 证明可以用反证法)</p>
<ul>
<li><strong>定理 2</strong>(严格单调的必要条件) 若 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\((a,
b)\)</span> 可导, 若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\((a, b)\)</span> 严格递增(减), 则 <span
class="math inline">\(f&#39;(x)\ge 0(\le 0)\)</span>.
(可以用极限的保号性证明)</li>
<li><strong>定理 3</strong>(广义单调的充要条件) 若 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 连续, 在 <span class="math inline">\((a, b)\)</span> 可导,
则在 <span class="math inline">\([a, b]\)</span>
上广义递增(减)的充要条件是 <span class="math inline">\(f&#39;(x)\ge
0(\le 0), \forall x\in(a, b)\)</span></li>
</ul>
<h2 id="导数与极值最值">导数与极值、最值</h2>
<ul>
<li>极值可疑点是驻点和不可导点.</li>
<li><strong>极值判法 1</strong> 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(U(a)\)</span> 连续, 在 <span
class="math inline">\(U^o(a)\)</span> 可导, 则若左右邻域上导数变号, 则
<span class="math inline">\(a\)</span> 为极值点. 左正右负为极大,
左负右正为极小. (可以用极限保号性证明)</li>
<li><strong>极值判法 2 &amp; 3</strong> 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 处 <span
class="math inline">\(n\)</span> 阶可导, 且 <span
class="math inline">\(f^{(k)}(a)=0(1\le k\le n-1)\)</span>, 但 <span
class="math inline">\(f^{(n)}(a)\ne 0\)</span>. 则若 <span
class="math inline">\(n\)</span> 为奇数, 则不是极值; 若 <span
class="math inline">\(n\)</span> 为偶数, 则 <span
class="math inline">\(f^{(n)}(a)\)</span> 正为极小, 负为极大.</li>
<li><strong>最值判法</strong> 若 <span class="math inline">\(f\)</span>
在 <span class="math inline">\([a, b]\)</span> 连续,
其最值只需比较各极值可疑点和区间端点的函数值.</li>
<li>对连续函数, 极大值和极小值相间排列,
不在端点处的最值点一定也是极值点. 在区间 <span
class="math inline">\(I\)</span> 上,
若函数存在最值但仅有一个极值(极大极小分开考虑), 则极值就是最值.</li>
</ul>
<h2 id="导数与凹凸性">导数与凹凸性</h2>
<ul>
<li>凹凸性定义: 若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上任意两点 <span
class="math inline">\(x_1, x_2\)</span>, 对任意 <span
class="math inline">\(\lambda\in[0, 1]\)</span> 均有</li>
</ul>
<p><span class="math display">\[
    f(\lambda x_1+(1-\lambda)x_2)\le(\ge) \lambda
f(x_1)+(1-\lambda)f(x_2).
\]</span></p>
<p>则称 <span class="math inline">\(f\)</span> 为下(上)凸函数,
统称为凸函数. 若上式所有不等号均为严格的, 则称为严格下(上)凸函数,</p>
<ul>
<li><strong>可导凸函数的充要条件</strong>: 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 内可导, 则 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 内是严格下(上)凸函数的充要条件是 <span
class="math inline">\(f&#39;(x)\)</span> 严格递增(减).</li>
</ul>
<blockquote>
<p>推论: 若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 内二阶可导, 则 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 内是严格下(上)凸函数的充要条件是 <span
class="math inline">\(f&#39;&#39;(x)&gt;0(&lt;0)\)</span>,
或者构成非严格不等号的点不构成区间.</p>
<p>把以上两结论中严格全部改成广义,
严格不等号全部改为非严格不等号(推论的逗号后的结论去除),
则是广义凹凸性的充要条件.</p>
</blockquote>
<details>
<summary>
<b>证明</b>
</summary>
<p><img src="concavity_theroem_proof1.png" /> <img
src="concavity_theroem_proof2.png" /></p>
<blockquote>
<p>证明如上</p>
<p>证明充分性时用到了凸函数的斜率性质: 若 <span
class="math inline">\(f\)</span> 是 <span
class="math inline">\(I\)</span> 上的下(上)凸函数, 则 <span
class="math inline">\(\forall a, b, c\in I\)</span>, <span
class="math inline">\(a&lt;b&lt;c\)</span>, 有 <span
class="math display">\[
k_{AB}&lt;k_{AC}&lt;k_{BC}.
\]</span> 证明方面, 类似上述图形证明, 用数学语言表达即可.</p>
</blockquote>
</details>
<ul>
<li><strong>凸函数的连续性</strong>: 开区间上的凸函数一定是连续函数,
闭区间上内点一定连续,
端点可能不连续.(利用凸函数的斜率性质和单调有界定理证明每一处内点的左右导数均存在(不一定相等),
故左右连续, 故连续. 可看<a
href="https://www.zhihu.com/question/432852940">此文</a>)</li>
<li><strong>凸函数的可导性</strong>:
开区间上的凸函数每一点左右导数均存在, 且不可导点是可数个.(证明可以看<a
href="https://www.zhihu.com/question/31437665/answer/51932947">此文</a>)</li>
</ul>
<h2 id="作图">作图</h2>
<ol type="1">
<li>确定定义域.</li>
<li>研究对称性、奇偶性、周期性</li>
<li>求 <span class="math inline">\(y&#39;, y&#39;&#39;\)</span>, 列出
<span class="math inline">\(x-y&#39;-y&#39;&#39;-y\)</span> 表,
得到大致形状.</li>
<li>求渐近线.</li>
<li>画图, 标特殊点.</li>
</ol>
<ul>
<li>求渐近线的方法:</li>
</ul>
<p>主要是寻找 <span class="math inline">\(x\)</span> 或 <span
class="math inline">\(y\)</span> 的无穷分支</p>
<ol type="1">
<li>显函数: 考虑定义域边缘点的 <span class="math inline">\(\lim
y\)</span> 是否为无穷得到垂直渐近线; 考虑 <span
class="math inline">\(x\to \pm\infty\)</span> 的 <span
class="math inline">\(k=\lim y/x\)</span>
得到水平渐近线和斜渐近线的斜率, 再算 <span
class="math inline">\(b=\lim(y-kx)\)</span> 得到截距.</li>
<li>隐函数: 考虑 <span class="math inline">\(x, y\)</span> 一个趋于常数
<span class="math inline">\(A\)</span>,
一个趋于无穷的情况得到水平和垂直渐近线; 考虑换元 <span
class="math inline">\(k=y/x\)</span>
后另一个变量(无论是谁)趋于无穷的情况得到斜渐近线的斜率(得到关于 <span
class="math inline">\(k\)</span> 的方程), 最后用 <span
class="math inline">\(b=\lim (y-kx)\)</span>
得到截距(需要一些技巧).</li>
<li>参数方程: 考虑使得 <span class="math inline">\(x\to \infty\)</span>
或 <span class="math inline">\(y\to \infty\)</span>, <span
class="math inline">\((t\to t_0)\)</span> 的情况的 <span
class="math inline">\(t_0\)</span> 即可, 对斜渐近线也需求 <span
class="math inline">\(\lim y/x\)</span>.</li>
</ol>
<h1 id="典题赏析">典题赏析</h1>
<ol type="1">
<li>设函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\((-\infty, +\infty)\)</span> 内定义, 且 <span
class="math inline">\(\forall x, y\)</span>, 有 <span
class="math display">\[
\begin{gather*}
f(x+y)=f(x)f(y),
\\
f(x)=1+xg(x), \lim_{x\to 0}g(x)=1.
\end{gather*}
\]</span> 试证: <span class="math inline">\(f\)</span> 在 <span
class="math inline">\((-\infty, +\infty)\)</span> 内处处可导, 且 <span
class="math inline">\(f&#39;(x)=f(x)\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>用导数定义: <span class="math display">\[
f&#39;(x)=\lim_{h\to 0}\dfrac{f(x+h)-f(x)}{h}=f(x)\lim_{h\to
0}\dfrac{f(h)-1}{h}=f(x)\lim_{h\to 0}g(h)=f(x).
\]</span></p>
</blockquote>
</details>
<ol start="2" type="1">
<li><p>求以下函数的 <span class="math inline">\(n\)</span> 阶导数.</p>
<p>(1) <span class="math inline">\(y=\dfrac{1}{x^2-1}\)</span>; (2)
<span class="math inline">\(y=\sin x\sin 3x\)</span>; (3) <span
class="math inline">\(y=\sin^2x\)</span>.</p></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>(1) <span
class="math inline">\(y=-\dfrac{1}{2}\left(\dfrac{1}{x+1}-\dfrac{1}{x-1}\right)\)</span>.
<span
class="math inline">\(y^{(n)}=-\dfrac{1}{2}\left(\dfrac{(-1)^nn!}{(x+1)^{n+1}}-\dfrac{(-1)^nn!}{(x-1)^{n+1}}\right)\)</span>.</p>
<p>(2) <span class="math inline">\(y=\sin x\sin 3x = \dfrac{1}{2}(\cos
2x-\cos 4x)\)</span>. <span
class="math inline">\(y^{(n)}=\dfrac{1}{2}\left[2^n\cos
\left(2x+\dfrac{n\pi}{2}\right)-4^n\cos\left(4x+\dfrac{n\pi}{2}\right)\right]\)</span>.</p>
<p>(3) <span
class="math inline">\(y=\sin^2x=\dfrac{1}{2}-\dfrac{1}{2}\cos
2x\)</span>. <span
class="math inline">\(y^{(n)}=-2^{n-1}\cos\left(2x+\dfrac{n\pi}{2}\right)\)</span>.</p>
</blockquote>
</details>
<ol start="3" type="1">
<li><p>求以下高阶导数.</p>
<p>(1) <span class="math inline">\(y=\dfrac{x^8}{1-x}\)</span>, 求 <span
class="math inline">\(y^{(8)}\)</span>; (2) <span
class="math inline">\(y=x\ln x\)</span>, 求 <span
class="math inline">\(y^{(5)}\)</span>;</p></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>(1) <span
class="math inline">\(y=\dfrac{x^8}{1-x}=\dfrac{1}{1-x}-(1+x+x^2+\cdots+x^7)\)</span>,
<span
class="math inline">\(y^{(8)}=-\dfrac{(-1)^88!}{(x-1)^9}=\dfrac{8!}{(1-x)^9}\)</span>.</p>
<p>(2) <span class="math inline">\(y=x\ln x\)</span>, <span
class="math inline">\(y^{(5)}=\sum_{k=0}^5C_5^kx^{(k)}(\ln
x)^{(5-k)}=x(\ln x)^{(5)}+5(\ln x)^{(4)}=-\dfrac{6}{x^4}\)</span>.</p>
</blockquote>
</details>
<ol start="4" type="1">
<li><p>求下列指定阶微分, 其中 <span class="math inline">\(x\)</span>
是自变量, <span class="math inline">\(u, v\)</span> 是 <span
class="math inline">\(x\)</span> 的足够次可微函数.</p>
<p>(1) <span class="math inline">\(y=\sqrt x\)</span>, 求 <span
class="math inline">\(\mathrm d^3 y\)</span>; (2) <span
class="math inline">\(y=\dfrac{u}{v}\)</span>, 求 <span
class="math inline">\(\mathrm d^2 y\)</span>.</p></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>(1) <span class="math inline">\(\mathrm d^3 y=(\sqrt x)^{(3)}\mathrm
d x^3=\dfrac{1}{2}\cdot (-\dfrac{1}{2})\cdot
(-\dfrac{3}{2})x^{-5/2}\mathrm d x^3=\dfrac{3}{8}x^{-5/2}\mathrm
dx^3\)</span>.</p>
<p>(2) <span class="math inline">\(\mathrm dy=\dfrac{v\mathrm
du-u\mathrm dv}{v^2}\)</span>;</p>
<p><span class="math inline">\(\mathrm d^2y=\mathrm d(\mathrm
dy)=\dfrac{v^2\mathrm d(v\mathrm du-u\mathrm dv)-(v\mathrm du-u\mathrm
dv)2v\mathrm dv}{v^4}=\dfrac{v^2\mathrm d^2u-uv\mathrm d^2v-2v\mathrm
du\mathrm dv+2u\mathrm dv^2}{v^3}\)</span>.</p>
</blockquote>
</details>
<ol start="5" type="1">
<li>求证: <span class="math inline">\(4ax^3+3bx^2+2cx=a+b+c\)</span> 在
<span class="math inline">\((0, 1)\)</span> 内至少有一个根.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>构造原函数 <span
class="math inline">\(F(x)=ax^4+bx^3+cx^2-(a+b+c)x\)</span>, 则 <span
class="math inline">\(F(0)=F(1)=0\)</span>, 又 <span
class="math inline">\(F\)</span> 在 <span class="math inline">\([0,
1]\)</span> 连续, <span class="math inline">\((0, 1)\)</span> 可导,
由罗尔定理有 <span class="math inline">\(\exists x_0\in (0, 1),
F&#39;(x_0)=0\)</span>, 即证.</p>
</blockquote>
</details>
<ol start="6" type="1">
<li>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 连续, 在 <span
class="math inline">\((a, b)\)</span> 可导, 且 <span
class="math inline">\(\lim\limits_{x\to a+}f&#39;(x)\)</span> 存在,
证明: <span class="math inline">\(f&#39;_+(a)\)</span> 存在且 <span
class="math inline">\(f&#39;_+(a)=\lim\limits_{x\to
a+}f&#39;(x)\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>对于 <span class="math inline">\((a, x), a&lt;x&lt;b\)</span>,
使用拉格朗日中值定理, 则存在 <span class="math inline">\(\xi\in (a,
x)\)</span>, 使得 <span class="math display">\[
f&#39;(\xi)=\dfrac{f(x)-f(a)}{x-a}.
\]</span> 当 <span class="math inline">\(x\to a+\)</span> 时, 有 <span
class="math inline">\(\xi\to a+\)</span>, 上式取极限得 <span
class="math display">\[
f&#39;_+(a)=\lim_{x\to a+}\dfrac{f(x)-f(a)}{x-a}=\lim_{\xi\to
a+}f&#39;(\xi)=\lim_{x\to a+}f&#39;(x).
\]</span></p>
</blockquote>
</details>
<ol start="7" type="1">
<li>设函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([0, a]\)</span> 上连续, 在 <span
class="math inline">\((0, a)\)</span> 上可导, 且 <span
class="math inline">\(f(a)=0\)</span>, 试证存在 <span
class="math inline">\(\xi\in (0, a)\)</span>, 使得 <span
class="math inline">\(nf(\xi)+\xi f&#39;(\xi)=0(n\in N)\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>令 <span class="math inline">\(F(x)=f(x)\cdot x^n\)</span>, 则 <span
class="math inline">\(F(0)=F(a)=0\)</span>, 由罗尔定理有 <span
class="math inline">\(\exists \xi\in(0, a)\)</span>, <span
class="math inline">\(F&#39;(\xi)=0\)</span>, 即证.</p>
</blockquote>
</details>
<ol start="8" type="1">
<li><p>求下列极限:</p>
<p>(1) <span class="math inline">\(\lim\limits_{x\to 0}\dfrac{e^x\sin
x-x(1+x)}{x^3}\)</span>. (2) <span
class="math inline">\(\lim\limits_{x\to 0}\dfrac{(\operatorname{sh}
x)^n-x^n}{(\sin x)^n-x^n}\)</span>. (3) <span
class="math inline">\(\lim\limits_{x\to
+\infty}(\sqrt[3]{x^3+2x^2+1}-xe^{1/x})\)</span>.</p>
<p>(4) <span class="math inline">\(\lim\limits_{x\to
0}\dfrac{\ln(1+x)\ln(1-x)-\ln(1-x^2)}{x^4}\)</span>. (5) <span
class="math inline">\(\lim\limits_{x\to
\infty}\left[x-x^2\ln\left(1+\dfrac{1}{x}\right)\right]\)</span>. (6)
<span class="math inline">\(\lim\limits_{n\to
\infty}n^2(\sqrt[n]{a}-\sqrt[n+1]{a})\)</span>.</p></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>(1) 当 <span class="math inline">\(x\to 0\)</span> 时, <span
class="math display">\[
e^x\sin
x=(1+x+\dfrac{1}{2}x^2+o(x^2))(x-\dfrac{1}{6}x^3+o(x^3))=x+x^2+\dfrac{1}{3}x^3+o(x^3).
\]</span> 故 <span class="math display">\[
\lim_{x\to 0}\dfrac{e^x\sin x-x(1+x)}{x^3}=\lim_{x\to
0}\dfrac{x+x^2+\frac{1}{3}x^3+o(x^3)-x(1+x)}{x^3}=\dfrac{1}{3}.
\]</span> (2) 当 <span class="math inline">\(x\to 0\)</span>, <span
class="math display">\[
\begin{aligned}
\operatorname{sh} x&amp;=x+\dfrac{x^3}{6}+o(x^3),
\\
\sin x&amp;=x-\dfrac{x^3}{6}+o(x^3),
\\
\operatorname{sh}^n x&amp;=x^n+\dfrac{nx^{n+2}}{6}+o(x^{n+2}),
\\
\sin^n x&amp;=x^n-\dfrac{nx^{n+2}}{6}+o(x^{n+2}).
\end{aligned}
\]</span> 故 <span class="math display">\[
\lim_{x\to 0}\dfrac{\operatorname{sh}^nx-x^n}{\sin^nx-x^n}=\lim_{x\to
0}\dfrac{\frac{n}{6}x^{n+2}+o(x^{n+2})}{-\frac{n}{6}x^{n+2}+o(x^{n+2})}=-1.
\]</span> (3) 当 <span class="math inline">\(x\to +\infty\)</span>,
<span class="math display">\[
\begin{aligned}
\sqrt[3]{x^3+2x^2+1}&amp;=x\sqrt[3]{1+\dfrac{2}{x}+\dfrac{1}{x^3}}
\\
&amp;=x\left(1+\dfrac{1}{3}(\dfrac{2}{x}+\dfrac{1}{x^3})+o\left(\dfrac{1}{x}\right)\right)
\\
xe^{\frac{1}{x}}&amp;=x\left(1+\dfrac{1}{x}+o\left(\dfrac{1}{x}\right)\right)
\end{aligned}
\]</span> 故 <span class="math display">\[
\lim_{x\to +\infty}(\sqrt[3]{x^3+2x^2+1}-xe^{\frac{1}{x}})=\lim_{x\to
+\infty}\left(-\dfrac{1}{3}+o(1)\right)=-\dfrac{1}{3}.
\]</span> (4) 当 <span class="math inline">\(x\to 0\)</span>, <span
class="math display">\[
\begin{aligned}
\ln(1+x)&amp;=x-\dfrac{1}{2}x^2+\dfrac{1}{3}x^3+o(x^3),
\\
\ln(1-x)&amp;=-x-\dfrac{1}{2}x^2-\dfrac{1}{3}x^3+o(x^3),
\\
\ln(1+x)\ln(1-x)&amp;=-x^2-\dfrac{5}{12}x^4+o(x^4).
\\
\ln(1-x^2)&amp;=-x^2-\dfrac{1}{2}x^4+o(x^4).
\end{aligned}
\]</span> 故 <span class="math display">\[
\lim_{x\to 0}\dfrac{\ln(1+x)\ln(1-x)-\ln(1-x^2)}{x^4}=\lim_{x\to
0}\dfrac{\frac{1}{12}x^4+o(x^4)}{x^4}=\dfrac{1}{12}
\]</span> (5) 当 <span class="math inline">\(x\to \infty\)</span>, <span
class="math display">\[
\ln\left(1+\dfrac{1}{x}\right)=\dfrac{1}{x}-\dfrac{1}{2x^2}+o\left(\dfrac{1}{x^2}\right).
\]</span> 从而 <span class="math display">\[
\lim_{x\to
\infty}\left[x-x^2\ln\left(1+\dfrac{1}{x}\right)\right]=\lim_{x\to\infty}\left(\dfrac{1}{2}+o(1)\right)=\dfrac{1}{2}.
\]</span></p>
</blockquote>
</details>
<ol start="9" type="1">
<li><p>写出下列函数关于 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(n\)</span> 阶有限展开式.</p>
<p>(1) <span class="math inline">\(\sqrt {1-x}\)</span>. (2) <span
class="math inline">\(\arctan x\)</span>.</p></li>
<li><p>写出下列函数的指定阶有限展开式.</p>
<p>(1) <span
class="math inline">\(\sqrt{1-2x+x^3}-\sqrt[3]{1-3x+x^2}\)</span>, 关于
<span class="math inline">\(x\)</span>, <span
class="math inline">\(3\)</span> 阶. (2) <span class="math inline">\(\ln
x\)</span>, 关于 <span class="math inline">\(x-2\)</span>, <span
class="math inline">\(n\)</span> 阶.</p></li>
<li><p>求 <span class="math inline">\(y=e^{1/x}\sqrt{1+x^2}\)</span>
的渐近线.</p></li>
<li><p>作下列函数的图形.</p>
<p>(1) <span class="math inline">\(y=\dfrac{\ln x}{x}\)</span>. (2)
<span class="math inline">\(y=\dfrac{x}{1+x^2}\)</span>. (3) <span
class="math inline">\(y=x-2\arctan x\)</span>. (4) <span
class="math inline">\(y=x\ln(e+\dfrac{1}{x})\)</span>.</p></li>
<li><p>求函数的二阶导数, 函数为 <span
class="math inline">\(\begin{cases}x=\ln(1+t^2)\\y=t-\arctan
t\end{cases}\)</span>.</p></li>
<li><p>作曲线 <span class="math inline">\(x=2t-t^2\)</span>, <span
class="math inline">\(y=3t-t^3\)</span> 的图形.</p></li>
<li><p>若 <span class="math inline">\(f\)</span> 二阶可导,
求下列函数的二阶导数:</p>
<p>(1) <span class="math inline">\(y=f(\ln x)\)</span>, (2) <span
class="math inline">\(y=f(f(x))\)</span>.</p></li>
<li><p>设 <span class="math inline">\(y=f(x)\)</span> 在点 <span
class="math inline">\(x\)</span> 的邻域内三阶可导, 且 <span
class="math inline">\(f&#39;(x)\ne 0\)</span>, 若 <span
class="math inline">\(f(x)\)</span> 存在反函数 <span
class="math inline">\(x=f^{-1}(y)\)</span>, 试用 <span
class="math inline">\(f&#39;(x), f&#39;&#39;(x),
f&#39;&#39;&#39;(x)\)</span> 表示 <span
class="math inline">\((f^{-1})&#39;&#39;&#39;(y)\)</span>.</p></li>
<li><p>证明下列不等式:</p>
<p>(1) <span
class="math inline">\(\dfrac{b-a}{b}&lt;\ln\dfrac{b}{a}&lt;\dfrac{b-a}{a}(0&lt;a&lt;b)\)</span>.
(2) <span class="math inline">\(\dfrac{h}{1+h^2}&lt;\arctan
h&lt;h(h&gt;0)\)</span>.</p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 可导, 且 <span
class="math inline">\(0\notin (a, b)\)</span>, 证明: <span
class="math inline">\(\exists \xi\in(a, b)\)</span>, 使得 <span
class="math inline">\(2\xi[f(b)-f(a)]=(b^2-a^2)f&#39;(\xi)\)</span>. 若
<span class="math inline">\(0\in (a, b)\)</span>, 又如何证明?</p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(a\)</span> 处二阶可导, 证明: <span
class="math display">\[
\lim_{h\to 0}\dfrac{f(a+h)+f(a-h)-2f(a)}{h^2}=f&#39;&#39;(a).
\]</span></p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(U(a)\)</span> 内存在二阶导数, 证明:
对绝对值充分小的 <span class="math inline">\(h\)</span>, 存在 <span
class="math inline">\(\theta\in (0, 1)\)</span>, 使得 <span
class="math display">\[
\dfrac{f(a+h)+f(a-h)-2f(a)}{h^2}=\dfrac{f&#39;&#39;(a+\theta
h)+f&#39;&#39;(a-\theta h)}{2}.
\]</span></p></li>
<li><p>速度 <span class="math inline">\(v\)</span> 和加速度的关系 <span
class="math inline">\(a\)</span> 为 <span
class="math inline">\(a=-kv^2\)</span>, 求速度随位移变化的关系.</p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上有三阶导数. 证明: <span
class="math inline">\(\exists \xi\in (a, b)\)</span>, 使得 <span
class="math display">\[
f(b)=f(a)+\dfrac{1}{2}(b-a)[f&#39;(a)+f&#39;(b)]-\dfrac{1}{12}(b-a)^3f&#39;&#39;&#39;(\xi).
\]</span></p></li>
<li><p>证明: 若 <span class="math inline">\(x&gt;0\)</span>, 则</p>
<p>(1) <span class="math inline">\(\sqrt
{x+1}-\sqrt{x}=\dfrac{1}{2\sqrt{x+\theta(x)}}\)</span>, 其中 <span
class="math inline">\(\dfrac{1}{4}&lt;\theta(x)&lt;\dfrac{1}{2}\)</span>.</p>
<p>(2) <span class="math inline">\(\lim\limits_{x\to
0+}\theta(x)=\dfrac{1}{4}, \lim\limits_{x\to
+\infty}\theta(x)=\dfrac{1}{2}\)</span>.</p></li>
<li><p>设 <span class="math inline">\(h&gt;0\)</span>, 函数 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\(U(a,
h)\)</span> 上具有 <span class="math inline">\(n+2\)</span> 阶连续导数,
且 <span class="math inline">\(f^{(n+2)}(a)\ne 0\)</span>, <span
class="math inline">\(f\)</span> 在 <span class="math inline">\(U(a,
h)\)</span> 上的泰勒展开为 <span class="math display">\[
f(a+h)=f(a)+f&#39;(a)h+\cdots+\dfrac{f^{(n)}(a)}{n!}h^n+\dfrac{f^{(n+1)}(a+\theta
h)}{(n+1)!}h^{n+1}.
\]</span> 其中 <span class="math inline">\(0&lt;\theta &lt;1\)</span>,
求 <span class="math inline">\(\lim\limits_{x\to
0}\theta\)</span>.</p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 二阶可导, <span
class="math inline">\(f&#39;(a)=f&#39;(b)=0\)</span>, 证明: <span
class="math inline">\(\exists \xi\in(a, b)\)</span>, 使得 <span
class="math display">\[
|f&#39;&#39;(\xi)|\ge \dfrac{4}{(b-a)^2}|f(b)-f(a)|.
\]</span></p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(\mathbb R\)</span> 上二次连续可导, 且对 <span
class="math inline">\(\forall x\in \mathbb R, h&gt;0\)</span>, 有 <span
class="math inline">\(f(x+h)+f(x-h)-2f(x)\ge 0\)</span>, 证明: 对 <span
class="math inline">\(\forall x\in \mathbb R\)</span>, 有 <span
class="math inline">\(f&#39;&#39;(x)\ge 0\)</span>.</p></li>
<li><p>设 <span class="math inline">\(f, g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可导, <span
class="math inline">\(f(a)=f(b)=0\)</span>, 求证存在 <span
class="math inline">\(\xi\in(a, b)\)</span>, 使得 <span
class="math display">\[
f&#39;(\xi)=g&#39;(\xi)f(\xi).
\]</span></p></li>
<li><p>设函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可导, 在 <span
class="math inline">\((a, b)\)</span> 内二阶可导, <span
class="math inline">\(f(a)=f(b)=0, f&#39;(a)f&#39;(b)&gt;0\)</span>,
求证: 存在 <span class="math inline">\(\xi\in(a, b)\)</span>, 使得 <span
class="math inline">\(f&#39;&#39;(\xi)=f(\xi)\)</span>.</p></li>
<li><p>设函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([0, 1]\)</span> 上二阶可导, <span
class="math inline">\(f(0)=f(1)\)</span>, 求证: 存在 <span
class="math inline">\(\xi\in (0, 1)\)</span>, 使得 <span
class="math display">\[
2f&#39;(\xi)+(\xi-1)f&#39;&#39;(\xi)=0.
\]</span></p></li>
<li><p>设函数 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可导 <span
class="math inline">\((a&gt;0)\)</span>, 求证: 存在 <span
class="math inline">\(\xi\in(a, b)\)</span>, 使得 <span
class="math display">\[
\dfrac{af(b)-bf(a)}{b-a}=\xi f&#39;(\xi)-f(\xi).
\]</span></p></li>
<li><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可导, <span
class="math inline">\(f(a)=0, f(b)=1\)</span>, 求证: 存在 <span
class="math inline">\(\xi, \eta\in(a, b)\)</span>, 且 <span
class="math inline">\(\xi\ne \eta\)</span>, 使得 <span
class="math display">\[
\dfrac{1}{f&#39;(\xi)}+\dfrac{1}{f&#39;(\eta)}=2(b-a).
\]</span></p></li>
<li><p>设 <span class="math inline">\(f, g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 二阶可导, 并且 <span
class="math inline">\(g&#39;&#39;(x)\ne 0\)</span>, <span
class="math inline">\(f(a)=f(b)=g(a)=g(b)=0\)</span>, 试证:</p>
<p>(1) 在开区间 <span class="math inline">\((a, b)\)</span> 内 <span
class="math inline">\(g(x)\ne 0\)</span>;</p>
<p>(2) <span class="math inline">\(\exists \xi\in(a, b)\)</span>, 使得
<span class="math display">\[
\dfrac{f(\xi)}{g(\xi)}=\dfrac{f&#39;&#39;(\xi)}{g&#39;&#39;(\xi)}.
\]</span></p></li>
<li><p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([0, 1]\)</span> 上二阶可导, <span
class="math inline">\(|f&#39;&#39;(x)|\le M\)</span>, 且 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((0,
1)\)</span> 内取得最大值, 试证 <span class="math display">\[
|f&#39;(0)|+|f&#39;(1)|\le M.
\]</span></p></li>
<li><p>设 <span class="math inline">\(y=f(x)\)</span> 在 <span
class="math inline">\((-1, 1)\)</span> 内具有二阶连续导数, 且 <span
class="math inline">\(f&#39;&#39;(x)\ne 0\)</span>, 试证:</p>
<p>(1) 对于 <span class="math inline">\((-1, 1)\)</span> 内的任一非零
<span class="math inline">\(x\)</span> 存在唯一的 <span
class="math inline">\(\theta(x)\in(0, 1)\)</span>, 使 <span
class="math inline">\(f(x)=f(0)+xf&#39;(\theta(x)x)\)</span> 成立.</p>
<p>(2) <span class="math inline">\(\lim\limits_{x\to
0}\theta(x)=\dfrac{1}{2}\)</span>.</p></li>
<li><p>试求 <span class="math inline">\(\lim\limits_{x\to
a}\left(\dfrac{1}{f(x)-f(a)}-\dfrac{1}{(x-a)f&#39;(x)}\right)\)</span>,
其中 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x=a\)</span> 的邻域中二阶导数连续, 且 <span
class="math inline">\(f&#39;(a)\ne 0\)</span>.</p></li>
<li><p>设 <span class="math inline">\(f(x)=a_1\sin x+a_2\sin
2x+\cdots+a_n\sin nx\)</span>, 且 <span class="math inline">\(|f(x)|\le
|\sin x|\)</span>, <span class="math inline">\(a_1, a_2, \cdots,
a_n\)</span> 为实常数, 求证 <span class="math display">\[
|a_1+2a_2+\cdots+na_n|\le 1.
\]</span></p></li>
<li><p>设 <span class="math inline">\(y=y(x)\)</span> 由方程 <span
class="math display">\[
x^3+y^2-2xy=0
\]</span> 确定, 试求 <span class="math inline">\(y=y(x)\)</span>
的渐近线.</p></li>
<li><p>设 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可导, <span
class="math inline">\(f&#39;(x)\ne 0\)</span>, 求证: 存在 <span
class="math inline">\(\xi, \eta\in(a, b)\)</span> 使得 <span
class="math display">\[
(b-a)e^\eta f&#39;(\xi)=(e^b-e^a)f&#39;(\eta).
\]</span></p></li>
</ol>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Calculus</tag>
        <tag>Maths</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 CCPC Harbin 解题报告</title>
    <url>/posts/79529d9c/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/103447">比赛链接</a></p>
<span id="more"></span>
<h1 id="b---magical-subsequence">B - Magical Subsequence</h1>
<p><strong>题意</strong>：给一个长度为 <span
class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(A_i\)</span>，选取其中 <span
class="math inline">\(m\)</span> 项 <span class="math inline">\(A_{b_1},
A_{b_2},\cdots, A_{b_m}\)</span> 且满足：</p>
<ol type="1">
<li>要求 <span class="math inline">\(m\)</span> 为偶数；</li>
<li>要求 <span
class="math inline">\(A_{b_1}+A_{b_2}=A_{b_3}+A_{b_4}=\cdots=A_{b_{m-1}}+A_{b_m}\)</span>。</li>
</ol>
<p>求最大的 <span class="math inline">\(m\)</span>。</p>
<p>数据范围：<span class="math inline">\(n\le 10^5, 1\le A_i\le
100\)</span>。</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>注意到 <span class="math inline">\(1\le A_i\le
100\)</span>，我们可以枚举 <span
class="math inline">\(A_{b_1}+A_{b_2}=v\)</span> 的值。对于一个 <span
class="math inline">\(A_i\)</span>，如果我们把它作为 <span
class="math inline">\(A_{b_x}+A_{b_{x+1}}\)</span> 的前一项，那么后一项
<span class="math inline">\(A_{b_{x+1}}\)</span> 需满足：值等于 <span
class="math inline">\(v-A_i\)</span> 且 <span
class="math inline">\(b_{x+1}&gt;i\)</span>。贪心地，我们选择 <span
class="math inline">\(b_{x+1}\)</span>
尽量小的那个。我们对每个值维护一个
<code>vector</code>，那么二分编号即可。于是我们得到了若干条线段，问题转化为选取最多条线段，互不相交，这是一个经典的贪心问题。</p>
<p>时间复杂度 <span class="math inline">\(O(Vn\log n)\)</span>，其中
<span class="math inline">\(V\)</span> 为值域上界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXV = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n, A[MAXN], minv, maxv;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAXV];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (Seg a, Seg b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    vector&lt;Seg&gt; seg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> op = v - A[i];</span><br><span class="line">        <span class="keyword">if</span>(op &lt; minv || op &gt; maxv)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">upper_bound</span>(V[op].<span class="built_in">begin</span>(), V[op].<span class="built_in">end</span>(), i);</span><br><span class="line">        <span class="keyword">if</span>(it != V[op].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">push_back</span>(&#123;i, *it&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(seg.<span class="built_in">begin</span>(), seg.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> lst = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : seg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.l &gt; lst) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            lst = v.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    minv = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">        V[A[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, A[i]);</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">2</span> * minv; v &lt;= <span class="number">2</span> * maxv; v++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">check</span>(v));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="d---math-master">D - Math master</h1>
<p><strong>题意</strong>：给出一个分数 <span
class="math inline">\(\dfrac{p}{q}\)</span>，要求在十进制下，划去 <span
class="math inline">\(p\)</span> 和 <span
class="math inline">\(q\)</span>
中相同种类、个数的数字，并保持分数值不变。求最小表示（使得 <span
class="math inline">\(p\)</span> 尽量小）。</p>
<p>例如，<span class="math inline">\(\dfrac{163}{326}\)</span> 同时划去
<span class="math inline">\(\lbrace 3,6\rbrace\)</span> 可以得到 <span
class="math inline">\(\dfrac{1}{2}\)</span> 为最简。</p>
<p>数据范围：<span
class="math inline">\(0&lt;p,q&lt;2^{63}\)</span>。</p>
<details>
<summary>
<b>展开题解</b>
</summary>
<p>在十进制下， <span class="math inline">\(p\)</span> 至多有 <span
class="math inline">\(\lg p\)</span> 位。枚举删去哪些位，至多有 <span
class="math inline">\(2^{\lg p}\)</span> 种。代入 <span
class="math inline">\(p&lt;2^{63}\)</span> 计算，至多有 <span
class="math inline">\(511683\)</span> 种情况。所以直接枚举删去哪些位，将
<span class="math inline">\(p\)</span> 删成 <span
class="math inline">\(x\)</span>；再根据 <span
class="math inline">\(p/q=x/y\)</span> 直接计算得到 <span
class="math inline">\(y\)</span>，然后判断即可。</p>
<p>时间复杂度 <span class="math inline">\(O(2^{\lg p}\cdot poly(\lg
p))\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX = <span class="number">19</span>;</span><br><span class="line">ll P, Q, p10[MAX];</span><br><span class="line"><span class="type">int</span> delp[MAX], nump[MAX], _p, U;</span><br><span class="line"><span class="type">int</span> delq[MAX], numq[MAX], _q, more0;</span><br><span class="line">ll ansx, ansy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initdel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        delp[i] = delq[i] = <span class="number">0</span>;</span><br><span class="line">    more0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equaldel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(delp[i] != delq[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> delq[<span class="number">0</span>] &lt;= delp[<span class="number">0</span>] &amp;&amp; delp[<span class="number">0</span>] &lt;= delq[<span class="number">0</span>] + more0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; P &gt;&gt; Q;</span><br><span class="line">    ll tmpP = P, tmpQ = Q;</span><br><span class="line">    _p = _q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmpP) &#123;</span><br><span class="line">        nump[_p++] = tmpP % <span class="number">10</span>;</span><br><span class="line">        tmpP /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmpQ) &#123;</span><br><span class="line">        numq[_q++] = tmpQ % <span class="number">10</span>;</span><br><span class="line">        tmpQ /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ansx = P, ansy = Q;</span><br><span class="line">    U = <span class="number">1</span> &lt;&lt; _p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> S = <span class="number">0</span>; S &lt; U; S++) &#123;</span><br><span class="line">        <span class="built_in">initdel</span>();</span><br><span class="line">        ll x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _p; i++)</span><br><span class="line">            <span class="keyword">if</span>((S &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                x += p10[cnt] * nump[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                delp[nump[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        __int128 M = (__int128)x * Q;</span><br><span class="line">        <span class="keyword">if</span>(M % P != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ll y = (ll)(M / P), tmpy = y;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmpy &amp;&amp; tot &lt; _q) &#123;</span><br><span class="line">            <span class="type">int</span> y0 = tmpy % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span>(tot &lt; _q &amp;&amp; numq[tot] != y0) &#123;</span><br><span class="line">                delq[numq[tot]]++;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tot &gt;= _q)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            tmpy /= <span class="number">10</span>;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(tot &lt; _q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numq[tot] != <span class="number">0</span>)</span><br><span class="line">                delq[numq[tot]]++;</span><br><span class="line">            <span class="keyword">else</span> more0++;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">equaldel</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; ansx)</span><br><span class="line">                ansx = x, ansy = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ansx &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ansy &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    p10[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX; i++)</span><br><span class="line">        p10[i] = p10[i<span class="number">-1</span>] * <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="e---power-and-modulo">E - Power and Modulo</h1>
<p><strong>题意</strong>：给一个长度为 <span
class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(A_i\)</span>，问是否存在唯一的 <span
class="math inline">\(M\ge 1\)</span> 满足 <span
class="math inline">\(\forall i\in\lbrace 1, 2, \cdots, n\rbrace ,
A_i=2^{i-1}\bmod M\)</span>。</p>
<p>数据范围：<span class="math inline">\(1\le n\le 10^5\)</span>，<span
class="math inline">\(0\le A_i\le 10^9\)</span>。</p>
<details>
<summary>
<b>题解1（愚蠢的原思路）</b>
</summary>
<p>我们看，<span class="math inline">\(A_i=2^{i-1}\bmod M\)</span>
是什么意思。一方面，由于 <span class="math inline">\(2^{i-1}\bmod
M\in[0, M-1]\)</span>，我们知道 <span class="math inline">\(0\le A_i\le
M-1\)</span>，故有 <span class="math inline">\(M&gt; \max
A_i\)</span>。</p>
<p>另一方面，我们知道 <span class="math inline">\(M\mid
(A_i-2^{i-1})\)</span>，故 <span class="math inline">\(M\mid
\gcd(A_i-2^{i-1})\)</span>。我们先求出 <span
class="math inline">\(\gcd(A_i-2^{i-1})\)</span> 即可。在 <span
class="math inline">\(n\)</span> 较小时，<span
class="math inline">\(A_i-2^{i-1}\)</span> 可能全为 <span
class="math inline">\(0\)</span>，这时任意大于 <span
class="math inline">\(A_i\)</span>
最大值的数都可以。否则，我们找到第一个 <span
class="math inline">\(A_i-2^{i-1}\)</span> 非零的数（因为 <span
class="math inline">\(A_i\le 10^9\)</span> 而 <span
class="math inline">\(2^{i-1}\)</span>
增长很快，这个数注定不会太大），把它作为 <span
class="math inline">\(M_0\)</span>；然后考虑它和下一个数的 <span
class="math inline">\(\gcd\)</span>，如为 <span
class="math inline">\(\gcd(M_0, 2^{j-1}-A_j)\)</span>。根据 <span
class="math inline">\(\gcd\)</span> 的性质，我们只需计算 <span
class="math inline">\(\gcd(M_0, (2^{j-1}-A_j)\bmod
M)\)</span>，快速幂计算第二项，再欧几里得即可。最后得到的 <span
class="math inline">\(M\)</span> 就是最大的可能的 <span
class="math inline">\(M\)</span> 了，其余可能的 <span
class="math inline">\(M\)</span> 都是它的因子。再判断是否满足 <span
class="math inline">\(M&gt;\max A_i\)</span> 即可。</p>
<p>那么怎么判断 <span class="math inline">\(M\)</span>
是否唯一呢，只要让 <span class="math inline">\(M\)</span> 除去 <span
class="math inline">\(M\)</span> 最小的非 1 因子即可。再判断这个数 <span
class="math inline">\(M&#39;\)</span> 是否大于 <span
class="math inline">\(\max A_i\)</span> 即可。时间复杂度 <span
class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll M)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; n; a = a * a % M, n &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">            ret = ret * a % M;</span><br><span class="line">    <span class="keyword">return</span> ret % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll A[MAXN], g, mxv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    g = mxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; A[i], mxv = <span class="built_in">max</span>(mxv, A[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(g == <span class="number">0</span>) &#123;</span><br><span class="line">            g = <span class="built_in">abs</span>((<span class="number">1ll</span> &lt;&lt; (i<span class="number">-1</span>)) - A[i]);<span class="comment">//g inside 2^30</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g = <span class="built_in">gcd</span>(g, (<span class="built_in">qpow</span>(<span class="number">2</span>, i<span class="number">-1</span>, g) - A[i]) % g + g);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(g &lt;= mxv) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(g == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; g &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i * i &lt;= g; i++)</span><br><span class="line">        <span class="keyword">if</span>(g % i == <span class="number">0</span>) &#123;</span><br><span class="line">            g2 = g / i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g2)</span><br><span class="line">        g2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(g2 &lt;= mxv) &#123;</span><br><span class="line">        cout &lt;&lt; g &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//assure g is the only one</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>
<b>题解2（一个比较好的做法）</b>
</summary>
<p>分 <span class="math inline">\(A_1\)</span> 三种情况讨论：</p>
<ol type="1">
<li>如果 <span class="math inline">\(A_1=0\)</span>，那么 <span
class="math inline">\(1\bmod M=0\)</span>，故 <span
class="math inline">\(M=1\)</span>，检测其它的 <span
class="math inline">\(A_i(i\le 2)\)</span> 是否全为 <span
class="math inline">\(0\)</span> 即可。</li>
<li>如果 <span class="math inline">\(A_1\le 2\)</span>，那么 <span
class="math inline">\(1\bmod M=A_1\le 2\)</span>，无解。</li>
<li>如果 <span class="math inline">\(A_1=1\)</span>，我们寻找不满足
<span class="math inline">\(A_{i+1}=2A_i\)</span> 的最小的 <span
class="math inline">\(i\)</span>，那么我们知道：<span
class="math inline">\(A_{i+1}=2A_i\bmod
M\)</span>。因为根据递推式，<span
class="math inline">\(A_i=2^{i-1}=2^{i-1}\bmod M\)</span>，故 <span
class="math inline">\(M&gt;A_i\)</span>，于是 <span
class="math inline">\(2A_i\bmod M\)</span> 要么等于 <span
class="math inline">\(2A_i\)</span> 要么等于 <span
class="math inline">\(2A_i-M\)</span>。由于 <span
class="math inline">\(A_{i+1}\ne 2A_i\)</span>，故 <span
class="math inline">\(A_{i+1}=2A_i-M\)</span>，即确定了 <span
class="math inline">\(M=2A_i-A_{i+1}\)</span>。
再从头判断一遍即可。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">if</span>(A[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> fl = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                fl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(fl)</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(A[<span class="number">1</span>] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//A[1] == 1</span></span><br><span class="line">        <span class="type">int</span> M = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * A[i] != A[i<span class="number">+1</span>]) &#123;</span><br><span class="line">                M = <span class="number">2</span> * A[i] - A[i<span class="number">+1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(M == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> fl = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * A[i] % M != A[i<span class="number">+1</span>]) &#123;</span><br><span class="line">                fl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(fl)</span><br><span class="line">            cout &lt;&lt; M &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="j---local-minimum">J - Local Minimum</h1>
<p>签到水题，不写题意和题解了，给个代码。</p>
<details>
<summary>
<b>展开代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, A[MAXN][MAXN], row[MAXN], col[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">max</span>(n, m); i++)</span><br><span class="line">        row[i] = col[i] = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">            row[i] = <span class="built_in">min</span>(row[i], A[i][j]);</span><br><span class="line">            col[j] = <span class="built_in">min</span>(col[j], A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] == row[i] &amp;&amp; A[i][j] == col[j])</span><br><span class="line">                ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>XCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分（一）总结 PART I</title>
    <url>/posts/f6c7f5cd/</url>
    <content><![CDATA[<p>本文简要梳理了微积分（一）的一些内容, 并记录一些套路.</p>
<span id="more"></span>
<h1 id="分析基础">分析基础</h1>
<h2 id="界-确界">界, 确界</h2>
<p>(上, 下)界, 有界.</p>
<p><strong>确界</strong>: 若 <span class="math inline">\(\alpha\)</span>
是 <span class="math inline">\(A\)</span> 的上确界(即 <span
class="math inline">\(\alpha = \sup A\)</span>), 那么:</p>
<ol type="1">
<li><p>一方面, <span class="math inline">\(\alpha\)</span> 是上界, 即
<span class="math inline">\(\forall x\in A, x \le
\alpha\)</span>.</p></li>
<li><p>另一方面, <span class="math inline">\(\forall \varepsilon&gt;0,
\exists x_0\in A\)</span> 使得 <span
class="math inline">\(\alpha-\varepsilon&lt;x_0\)</span>.
(不可再小)</p></li>
</ol>
<blockquote>
<p>证明与上下确界有关的不等式需要根据定义, 如证明 <span
class="math inline">\(\sup\limits_{x\in X, y\in Y}\lbrace x+y\rbrace
=\sup\limits_{x\in X}\lbrace x\rbrace +\sup\limits_{y\in Y}\lbrace
y\rbrace\)</span> 等式子.</p>
</blockquote>
<h2 id="几大互相等价的定理">几大互相等价的定理</h2>
<p><strong>1. 实数的连续性原理</strong></p>
<p>若 <span class="math inline">\(A, B\)</span> 为非空实数集, 且 <span
class="math inline">\(\forall x\in A, \forall y\in B, x\le y\)</span>,
则 <span class="math inline">\(\exists c\in \mathbb R\)</span> 使得
<span class="math inline">\(\forall x\in A, \forall y\in B, x\le c\le
y\)</span>.</p>
<p><strong>2. 确界存在定理</strong></p>
<p>若 <span class="math inline">\(A\)</span> 非空有上(下)界, 则 <span
class="math inline">\(A\)</span> 必有上(下)确界.</p>
<p><strong>3. 单调有界定理</strong></p>
<p>若 <span class="math inline">\(\lbrace a_n\rbrace\)</span>
单调递增/减且有上/下界, 则 <span class="math inline">\(\lbrace
a_n\rbrace\)</span> 收敛(为 <span class="math inline">\(\sup \lbrace
a_n\rbrace\)</span> / <span class="math inline">\(\inf \lbrace
a_n\rbrace\)</span>)</p>
<p>函数版: 若 <span class="math inline">\(f\)</span> 是定义在 <span
class="math inline">\(I\)</span> 上的单调有界函数, 则 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上任一点都存在有限的单侧极限.</p>
<p><strong>4. 闭区间套定理</strong></p>
<p>若 <span class="math inline">\(\lbrace [a_n, b_n]\rbrace\)</span>
是一列闭区间, 且满足 <span class="math inline">\([a_1, b_1]\supset [a_2,
b_2]\supset\cdots \supset [a_n, b_n]\supset \cdots\)</span>, 及 <span
class="math inline">\(\lim\limits_{n\to \infty}(b_n-a_n)=0\)</span>.
则存在唯一 <span class="math inline">\(c\in [a_n, b_n]\)</span>, 使得
<span class="math inline">\(\lim\limits_{n\to
\infty}a_n=\lim\limits_{n\to\infty}b_n=c\)</span>.</p>
<p><strong>5. 收敛子列定理</strong></p>
<p>有限数列必存在收敛子列.(但是收敛的值不一定唯一)</p>
<p><strong>6. 柯西收敛准则</strong></p>
<p><span class="math inline">\(\lbrace a_n\rbrace\)</span> 收敛等价于
<span class="math inline">\(\forall \varepsilon &gt; 0, \exists N &gt;
0, \forall m, n&gt;N, |a_m-a_n|&lt;\varepsilon\)</span>.</p>
<p>函数版:</p>
<ol type="1">
<li><span class="math inline">\(\lim\limits_{x\to a}f(x)\)</span>
存在等价于 <span class="math inline">\(\forall \varepsilon &gt; 0,
\exists \delta &gt; 0, \forall x_1, x_2\in U^o(a, \delta),
|f(x_1)-f(x_2)|&lt;\varepsilon\)</span>.</li>
<li><span class="math inline">\(\lim\limits_{x\to \infty}f(x)\)</span>
存在等价与 <span class="math inline">\(\forall \varepsilon &gt; 0,
\exists N &gt; 0, \forall x_1, x_2\)</span> 满足 <span
class="math inline">\(|x_1|&gt;N, |x_2|&gt;N\)</span>, 有 <span
class="math inline">\(|f(x_1)-f(x_2)|&lt;\varepsilon\)</span>.</li>
</ol>
<p><strong>7. 有限覆盖定理</strong></p>
<p>闭区间的一个覆盖必存在有限子覆盖.</p>
<details>
<summary>
<b>一些互相证明</b>
</summary>
<blockquote>
<p>下面是上课讲的:</p>
<p><strong>1 推 2</strong> 非空数集与它的上界组成的集合之间,
由实数的连续性原理, 夹着一个 <span class="math inline">\(c\)</span>,
一方面 <span class="math inline">\(\forall x\in X, x\le c\)</span>, 故
<span class="math inline">\(c\)</span> 为上界; 反设 <span
class="math inline">\(c\)</span> 不是上确界, 那么存在 <span
class="math inline">\(\varepsilon &gt; 0, \forall x\in X, x\le
c-\varepsilon\)</span>, 故 <span
class="math inline">\(c-\varepsilon\)</span> 也是上界, 故 <span
class="math inline">\(c\le c-\varepsilon\)</span>, 矛盾.</p>
<p><strong>2 推 3</strong> (证递增上界的情况)数列有上界则有上确界 <span
class="math inline">\(A\)</span>, 则对任意 <span
class="math inline">\(\varepsilon&gt;0\)</span> 存在 <span
class="math inline">\(N\)</span>, 使得 <span
class="math inline">\(A-\varepsilon&lt; a_N\le A\)</span>, 故当 <span
class="math inline">\(n&gt;N\)</span> 时 <span
class="math inline">\(A-\varepsilon&lt;a_N\le a_n\le
A&lt;A+\varepsilon\)</span>, 故极限存在为 <span
class="math inline">\(A\)</span>.</p>
<p><strong>3 推 4</strong> <span class="math inline">\(\lbrace
a_n\rbrace\)</span> 递增且上界存在为 <span
class="math inline">\(b_1\)</span>, <span class="math inline">\(\lbrace
b_n\rbrace\)</span> 递减且下界存在为 <span
class="math inline">\(a_1\)</span>, 分别设两数列极限为 <span
class="math inline">\(A, B\)</span>. 由 <span
class="math inline">\(\lim\limits_{n\to \infty}(b_n-a_n)=0\)</span> 可得
<span class="math inline">\(A=B=c\)</span>, 且 <span
class="math inline">\(\forall n, a_n\le c\le b_n\)</span>. 设另有 <span
class="math inline">\(c&#39;\)</span> 使得 <span
class="math inline">\(a_n\le c&#39;\le b_n\)</span>, 则 <span
class="math inline">\(|c-c&#39;|\le b_n-a_n\)</span>, 由极限保号性得
<span class="math inline">\(|c-c&#39;|\le 0\)</span>, 故 <span
class="math inline">\(c=c&#39;\)</span>.</p>
<p><strong>4 推 5</strong> 设数列为 <span class="math inline">\(\lbrace
x_n\rbrace\)</span>, 从 <span class="math inline">\([-M, M]\)</span>
开始使用二分法(即套用闭区间套定理), 构造得到区间套 <span
class="math inline">\([l_n, r_n]\)</span>,
因为左右区间至少有一个是无穷多项, 选择无穷多项的一边一直下去,
最后收敛到一个点 <span class="math inline">\(c\)</span>. 因为每个 <span
class="math inline">\([l_n, r_n]\)</span> 中都有无穷多项,
所以我们如下构造 <span class="math inline">\(a_{n_k}\)</span>: 在 <span
class="math inline">\([l_k, r_k]\)</span> 的范围内挑选一个 <span
class="math inline">\(a_{n_k}\)</span>, 满足 <span
class="math inline">\(n_k&gt;n_{k-1}\)</span>. 这是显然可以做到的, 因为
<span class="math inline">\(n_{k-1}\)</span> 前只有有限项. 于是我们得到
<span class="math inline">\(l_k\le a_{n_k}\le r_k\)</span>, 取极限得
<span class="math inline">\(a_{n_k}\to c\)</span>.</p>
<p><strong>5 推 6</strong> 证明柯西收敛准则: 一方面, 左推右,
由绝对值不等式显然. 另一方面, 右推左. 取 <span
class="math inline">\(\varepsilon_0=1\)</span>, 则存在 <span
class="math inline">\(N_0&gt;0, \forall n&gt;N_0,
|a_n-a_{N_0+1}|&lt;1\)</span>, 故可得 <span
class="math inline">\(\lbrace a_n\rbrace\)</span> 有界, 故有收敛子列
<span class="math inline">\(\lbrace a_{n_k}\rbrace \to A\)</span>.
于是对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>, 存在
<span class="math inline">\(N&gt;0\)</span>, 因 <span
class="math inline">\(a_{n_k}\)</span> 无穷多项, 故存在 <span
class="math inline">\(n_{k_0}&gt;N\)</span>, 满足 <span
class="math inline">\(\forall n&gt;N\)</span>, <span
class="math inline">\(|a_n-a_{n_{k_0}}|&lt;\varepsilon/2\)</span>.
然后由绝对值不等式易得.</p>
<p><strong>4 推 7</strong> 反证 <span class="math inline">\([a,
b]\)</span> 不能够有限覆盖, 二分, 则左右区间至少有一个不能够有限覆盖.
得到一系列 <span class="math inline">\([l_n,
r_n]\)</span>(闭区间套)均不能被有限覆盖, 由闭区间套定理可得 <span
class="math inline">\(\lbrace l_n\rbrace, \lbrace r_n\rbrace\)</span>
收敛于 <span class="math inline">\(c\)</span>. 取覆盖 <span
class="math inline">\(c\)</span> 的覆盖 <span
class="math inline">\((c-\alpha, c+\beta)\)</span>, 取 <span
class="math inline">\(\varepsilon=\min(\alpha, \beta)\)</span>, 那么存在
<span class="math inline">\(N&gt;0\)</span>, 当 <span
class="math inline">\(n&gt;N\)</span>, <span class="math inline">\([l_n,
r_n]\subsetneqq (c-\varepsilon, c+\varepsilon)\subseteq (c-\alpha,
c+\beta)\)</span>, 故可以被有限覆盖(1 个), 矛盾.</p>
<p><strong>6 推 4</strong> <span class="math inline">\(\forall
\varepsilon&gt;0\)</span>, <span class="math inline">\(\exists
N&gt;0\)</span>, <span class="math inline">\(\forall n&gt;N\)</span>, 有
<span class="math inline">\(0\le b_n-a_n&lt;\varepsilon\)</span>. 对
<span class="math inline">\(\forall m\ge n&gt;N\)</span>, 有 <span
class="math inline">\(a_n\le a_m\le b_m\le b_n\)</span>, 那么 <span
class="math inline">\(|a_m-a_n|=a_m-a_n\le
b_n-a_n&lt;\varepsilon\)</span>. 由柯西收敛准则, <span
class="math inline">\(\lbrace a_n\rbrace\)</span> 极限存在. 同理 <span
class="math inline">\(\lbrace b_n\rbrace\)</span> 极限存在. 后续证明同
"3 推 4".</p>
<p><strong>6 推 3</strong> (证单调递增有上界的情况) 反设 <span
class="math inline">\(\lbrace a_n\rbrace\)</span> 无极限, 则 <span
class="math inline">\(\exists \varepsilon&gt;0\)</span>, <span
class="math inline">\(\forall N&gt;0\)</span>, <span
class="math inline">\(\exists n&gt;m&gt;N\)</span>, <span
class="math inline">\(|a_n-a_m|\ge\varepsilon\)</span>, 即 <span
class="math inline">\(a_n\ge a_m+\varepsilon\)</span>. 由于 <span
class="math inline">\(N\)</span> 的任意性, 适当选取 <span
class="math inline">\(N\)</span> 后可得 <span
class="math inline">\(\lbrace a_{n}\rbrace\)</span> 的子列 <span
class="math inline">\(\lbrace a_{n_k}\rbrace\)</span>, 满足 <span
class="math inline">\(a_{n_{k+1}}\ge a_{n_k}+\varepsilon\)</span>, 那么
<span class="math inline">\(a_{n_k}\ge a_{n_{k-1}}+\varepsilon\ge \cdots
\ge a_{n_1}+(k-1)\varepsilon\)</span>. 故 <span
class="math inline">\(\lim\limits_{k\to\infty}a_{n_k}\ge
\lim\limits_{k\to\infty}(a_{n_1}+(k-1)\varepsilon)=+\infty\)</span>.
故子数列无界, 则原数列也无界, 矛盾.</p>
<p><strong>4 推 2</strong> (证上界的情况) 由于 <span
class="math inline">\(S\)</span> 非空, 取 <span
class="math inline">\(a\in S\)</span>, 若 <span
class="math inline">\(a\)</span> 为 <span
class="math inline">\(S\)</span> 上界, 则 <span
class="math inline">\(a\)</span> 为上确界, 证毕. 故设 <span
class="math inline">\(a\)</span> 不为 <span
class="math inline">\(S\)</span> 上界. 由 <span
class="math inline">\(S\)</span> 存在上界, 设为 <span
class="math inline">\(b\)</span>. 若 <span class="math inline">\(b\in
S\)</span> 则证毕. 故设 <span class="math inline">\(b\notin S\)</span>.
故可知存在 <span class="math inline">\(x\in S\)</span>, <span
class="math inline">\(a&lt;s&lt;b\)</span>. 以此为 <span
class="math inline">\([a_1, b_1]\)</span>, 二分出区间套 <span
class="math inline">\([a_n, b_n]\)</span> 满足 <span
class="math inline">\(a_n\)</span> 不为 <span
class="math inline">\(S\)</span> 上界, <span
class="math inline">\(b_n\)</span> 为 <span
class="math inline">\(S\)</span> 上界, 且存在 <span
class="math inline">\(x_n\in S\)</span> 满足 <span
class="math inline">\(a_n&lt;x_n&lt;b_n\)</span>. 由闭区间套定理, <span
class="math inline">\(\lbrace a_n\rbrace \to c\)</span>, <span
class="math inline">\(\lbrace b_n\rbrace \to c\)</span>. 由于 <span
class="math inline">\(b_n\)</span> 是 <span
class="math inline">\(S\)</span> 上界, 故 <span
class="math inline">\(\forall x\in S, x\le b_n\)</span>,
由极限的保号性有 <span class="math inline">\(x\le c\)</span>. 故 <span
class="math inline">\(c\)</span> 为 <span
class="math inline">\(S\)</span> 上界. 由极限的定义, <span
class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists N&gt;0\)</span>, <span
class="math inline">\(\forall n&gt;N\)</span>, <span
class="math inline">\(c-\varepsilon&lt;a_n&lt;b_n&lt;c+\varepsilon\)</span>,
又存在 <span class="math inline">\(x_n\in S\)</span>, <span
class="math inline">\(a_n&lt;x_n&lt;b_n\)</span>, 故 <span
class="math inline">\(c-\varepsilon&lt;x_n\)</span>, 从而 <span
class="math inline">\(c\)</span> 是上确界.</p>
<p><a href="六大定理互证.pdf">拓展: 六大定理互相证明!</a></p>
</blockquote>
</details>
<h2 id="常用的等式不等式">常用的等式、不等式</h2>
<details>
<summary>
<b>展开</b>
</summary>
<p><img src="equal_nequal1.png" /> <img src="equal_nequal2.png" /> <img
src="equal_nequal3.png" /></p>
</details>
<blockquote>
<p>这些不等式在后面都用得着.</p>
</blockquote>
<h2 id="极限定义">极限定义</h2>
<p><strong>数列极限</strong>: <span class="math inline">\(\lbrace
a_n\rbrace\)</span> 为一数列, 若 <span class="math inline">\(\forall
\varepsilon &gt; 0, \exists N&gt;0, \forall n&gt;N,
|a_n-A|&lt;\varepsilon\)</span>, 则 <span
class="math inline">\(\lim\limits_{n\to \infty}a_n=A\)</span>.</p>
<p><strong>函数定义1</strong>: <span class="math inline">\(f(x)\)</span>
在 <span class="math inline">\(U^o(x_0)\)</span> 有定义, 若 <span
class="math inline">\(\forall \varepsilon &gt; 0, \exists \delta&gt;0,
\forall x\in U^o(x_0, \delta), |f(x)-A|&lt;\varepsilon\)</span>, 则
<span class="math inline">\(\lim\limits_{x\to x_0}=A\)</span>.</p>
<p><strong>函数定义2</strong>: <span class="math inline">\(f(x)\)</span>
在 <span class="math inline">\([b, +\infty)\)</span> 有定义, 若 <span
class="math inline">\(\forall \varepsilon &gt; 0, \exists H &gt; 0,
\forall x &gt; H, |f(x)-A|&lt;\varepsilon\)</span>, 则 <span
class="math inline">\(\lim\limits_{x\to +\infty}=A\)</span>.</p>
<p>上面三个定义, 如果要写成 <span class="math inline">\(\lim
f=+\infty\)</span> 或 <span class="math inline">\(\lim
f=-\infty\)</span> 的形式, 则要把 <span
class="math inline">\(\varepsilon\)</span>
的限制改为上/下界限制(即任意一个上/下界, <span
class="math inline">\(f\)</span> 均可超出); 如果 <span
class="math inline">\(\lim f=\infty\)</span> 则把 <span
class="math inline">\(f\)</span> 套上个绝对值,转化为上界. (换句话说,
<span class="math inline">\(\lim f=\infty\)</span> 等价于 <span
class="math inline">\(\lim |f|=+\infty\)</span>)</p>
<blockquote>
<p>一些找 <span class="math inline">\(N,\delta\)</span> 的方法.</p>
<ol type="1">
<li><p>直接法, 如 <span class="math inline">\(1/n, q^n,
\sqrt[n]a\)</span>.</p></li>
<li><p>二项式定理法, 如 <span class="math inline">\(\sqrt[n]n,
\frac{poly(n)}{a^n}\)</span>.</p></li>
<li><p>放缩法. 如 <span class="math inline">\(\sin x &lt; x(x &gt;
0)\)</span></p></li>
<li><p>有理化.</p></li>
</ol>
<p>善用取整符, 善用限制范围(特别是函数的极限)的方法.</p>
</blockquote>
<p><strong>单侧极限</strong>: 极限存在等价于左右极限存在且相等.</p>
<h2 id="极限的性质">极限的性质</h2>
<ol type="1">
<li><p>数列有限项不影响敛散性.</p></li>
<li><p>极限存在则唯一.</p>
<blockquote>
<p>证明: 假设不唯一, 则取两数之差的一半作为 <span
class="math inline">\(\varepsilon\)</span>.)</p>
</blockquote></li>
<li><p>收敛数列有界, 收敛函数局部有界.</p>
<blockquote>
<p>证明: 由 <span class="math inline">\(\max\lbrace A+\varepsilon,
A-\varepsilon\rbrace\)</span> 限制.</p>
</blockquote></li>
<li><p>极限的保序性: 若 <span class="math inline">\(f\to A, g\to
B\)</span>, 且 <span class="math inline">\(f\ge g\)</span>, 则 <span
class="math inline">\(A\ge B\)</span>; 反之,若 <span
class="math inline">\(A&gt;B\)</span>, 则在去心邻域内 <span
class="math inline">\(f&gt;g\)</span>.</p>
<blockquote>
<p>证明: 后者可取 <span class="math inline">\((A-B)/2\)</span> 作为
<span class="math inline">\(\varepsilon\)</span>, 前者可以用反证.</p>
</blockquote></li>
<li><p>极限的四则运算. (注意: 需保证得到的两部分极限均存在!)</p></li>
</ol>
<details>
<summary>
<b>证明方法</b>
</summary>
<p><img src="lim_fourop1.png" /> <img src="lim_fourop2.png" /></p>
</details>
<ol start="6" type="1">
<li><p>极限的复合运算: 若 <span class="math inline">\(\lim\limits_{x\to
x_0}\varphi(x)=b, \lim\limits_{t\to b}g(t)=A\)</span>, 且在 <span
class="math inline">\(U^o(x_0)\)</span> 内 <span
class="math inline">\(\varphi(x)\ne b\)</span>, 则 <span
class="math inline">\(\lim\limits_{x\to
x_0}g(\varphi(x))=A\)</span>.</p></li>
<li><p>海涅定理: <span class="math inline">\(\lim\limits_{x\to
x_0}=A\)</span> 等价于 <span class="math inline">\(\forall\lbrace
x_n\rbrace , x_n\to x_0, x_n\ne x_0\)</span> 都有 <span
class="math inline">\(\lim\limits_{n\to \infty}f(x_n)=A\)</span>.</p>
<blockquote>
<p>常常用它的逆否证明一个函数没有极限</p>
</blockquote></li>
</ol>
<details>
<summary>
<b>海涅定理的证明(只证右到左)</b>
</summary>
<p><img src="heineproof.png" /></p>
</details>
<ol start="8" type="1">
<li>夹逼定理: 存在 <span class="math inline">\(U^o(x_0,
\delta)\)</span>, <span class="math inline">\(f(x)\le g(x)\le
h(x)\)</span> 且 <span class="math inline">\(x\to x_0\)</span> 时 <span
class="math inline">\(f(x)\to A, h(x)\to A\)</span>, 则 <span
class="math inline">\(g(x)\to A\)</span>.</li>
</ol>
<h2 id="两个重要极限">两个重要极限</h2>
<p><span class="math inline">\(\lim\limits_{x\to 0}\dfrac{\sin
x}{x}=1\)</span>, 使用不等式 <span class="math inline">\(\sin x &lt; x
&lt; \tan x\)</span> 夹逼证得.</p>
<p><span class="math inline">\(\lim\limits_{x\to
+\infty}(1+\dfrac{1}{x})^x=e\)</span>, 使用 <span
class="math inline">\((1+\dfrac{1}{n})^n\)</span> 递增证得数列极限, 再与
<span class="math inline">\((1+\dfrac{1}{n})^{n+1}\)</span>
夹逼证得函数极限.</p>
<details>
<summary>
<b>数列单调的证明</b>
</summary>
<p><img src="e_lim_proof.png" /></p>
<blockquote>
<p>这里还有另一种证明:</p>
<p><span class="math display">\[\begin{aligned}
a_n&amp;=(1+\dfrac{1}{n})^n
\\
&amp;=1+C_n^1\dfrac{1}{n}+C_n^2\dfrac{1}{n^2}+\cdots+C_n^k\dfrac{1}{n^k}+\cdots+C_n^n\dfrac{1}{n^n}
\\
&amp;=1+1+\cdots+\dfrac{n(n-1)\cdots(n-k+1)}{k!n^k}+\cdots+C_n^n\dfrac{1}{n^n}
\\
&amp;=1+1+\cdots+\dfrac{1\cdot(1-\frac{1}{n})\cdots(1-\frac{k-1}{n})}{k!}+\cdots+C_n^n\dfrac{1}{n^n}
\end{aligned}
\]</span></p>
<p>则</p>
<p><span class="math display">\[
a_{n+1}=1+1+\cdots+\dfrac{1\cdot(1-\frac{1}{n+1})\cdots(1-\frac{k-1}{n+1})}{k!}+\cdots+C_{n+1}^{n+1}\dfrac{1}{(n+1)^{n+1}}
\]</span></p>
<p>我们发现 <span class="math inline">\(a_{n+1}\)</span> 项数多,
且每项都大, 故 <span class="math inline">\(a_{n+1}&gt;a_n\)</span>.</p>
<p>又</p>
<p><span class="math display">\[
\begin{aligned}
a_n&amp;&lt;1+1+\cdots+\dfrac{1}{k!}+\cdots+\dfrac{1}{n!}
\\
&amp;=\sum_{i=1}^n\dfrac{1}{i!}
\\
&amp;&lt;1+\sum_{i=1}^n\dfrac{1}{2^{i-1}}
\\
&amp;=3-\dfrac{1}{2^{n-1}}
\end{aligned}
\]</span></p>
<p>故单调有界.</p>
</blockquote>
</details>
<details>
<summary>
<b>推论: 调和级数的估计</b>
</summary>
<p><img src="e_lim_concl1.png" /> <img src="e_lim_concl2.png" /></p>
</details>
<h2 id="连续性">连续性</h2>
<p>定义(函数在某点连续): 若 <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)=f(x_0)\)</span> 则
<span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 连续.</p>
<p>条件: <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(U(x_0)\)</span> 有定义, 在 <span
class="math inline">\(x\to x_0\)</span> 有极限, 极限值等于函数值.</p>
<p>或者使用增量: <span class="math inline">\(\lim\limits_{\Delta x\to
0}(f(x_0+\Delta x)-f(x_0))=0\)</span>.</p>
<p>同时, 有相应的 <span
class="math inline">\(\varepsilon-\delta\)</span> 语言, 海涅定理等.</p>
<p>连续等价于左连续且右连续.</p>
<p>若 <span class="math inline">\(f\)</span> 在开区间 <span
class="math inline">\(I\)</span> 内处处连续, 那么称 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 连续. 若 <span
class="math inline">\(I\)</span> 改为闭区间,
则在闭区间端点处要求单侧连续. 记为 <span class="math inline">\(f\in
C(I)\)</span>.</p>
<p>若不满足, 则称为不连续; 若在 <span class="math inline">\(x_0\)</span>
处不连续, 但左极限、右极限中至少有一个存在, 那我们可以说它间断, <span
class="math inline">\(x_0\)</span> 即为间断点.</p>
<details>
<summary>
<b>间断点的分类</b>
</summary>
<p><img src="discontinuity_point.png" /></p>
</details>
<p>初等函数在其定义域中都是连续的.</p>
<h2 id="连续的性质">连续的性质</h2>
<ol type="1">
<li><p>局部有界性</p>
<blockquote>
<p>极限的性质</p>
</blockquote></li>
<li><p>局部保号性</p>
<blockquote>
<p>极限的性质. 往往推广使用, 比如 <span
class="math inline">\(f(x_0)&gt;0\)</span>, 推出邻域内 <span
class="math inline">\(f(x)&gt;f(x_0)/2\)</span>.</p>
</blockquote></li>
<li><p>四则运算与复合连续</p></li>
<li><p>严格单调的函数有反函数, 严格单调的连续函数反函数连续.</p></li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<p><img src="inv_p1.png" /> <img src="inv_p2.png" /> <img
src="inv_p3.png" /></p>
</details>
<ol start="5" type="1">
<li>闭区间连续函数满足有界性定理, 最值定理, 零点定理, 介值定理,
康托尔定理.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p><strong>有界性定理</strong></p>
<ol type="1">
<li><p>使用有限覆盖定理, 若干个局部有界可以得到一组覆盖,
取出一有限覆盖可证得.</p></li>
<li><p>假设无界, 可取出一有界数列 <span class="math inline">\(\lbrace
x_n\rbrace\)</span> 使得 <span class="math inline">\(f(x_n)\to
+\infty\)</span>, 由于有界数列必有收敛子列, 设 <span
class="math inline">\(x_{n_k}\to x_0\)</span>, 则 <span
class="math inline">\(x_0\in [a, b]\)</span>, 则 <span
class="math inline">\(\lim\limits_{k\to
\infty}f(x_{n_k})=f(x_0)=+\infty\)</span>, 矛盾.</p></li>
</ol>
<p><strong>最值定理</strong></p>
<p>(下证最大值)</p>
<ol type="1">
<li><p>可知 <span class="math inline">\(f(x)\)</span> 值域有上确界 <span
class="math inline">\(A=\sup\limits_{x\in [a, b]}f(x)\)</span>.
则可取出一有界数列 <span class="math inline">\(\lbrace
x_n\rbrace\)</span> 使得 <span
class="math inline">\(A-\frac{1}{n}&lt;f(x_n)\le A\)</span>.
取其收敛子列 <span class="math inline">\(\lbrace x_{n_k}\rbrace \to
x_0\)</span>, 则 <span
class="math inline">\(A-\frac{1}{n_k}&lt;f(x_{n_k})\le A\)</span>, 又
<span class="math inline">\(\lim\limits_{k\to
\infty}\left(A-\frac{1}{n_k}\right)=A\)</span>, 则由夹逼定理得 <span
class="math inline">\(\lim\limits_{k\to
\infty}f(x_{n_k})=f(x_0)=A\)</span>. 故 <span
class="math inline">\(A\)</span> 为最大值.</p></li>
<li><p>假设 <span class="math inline">\(\forall x\in[a, b],
f(x)&lt;A\)</span>. 由 <span class="math inline">\(x\)</span> 的任意性,
可得一组覆盖 <span class="math inline">\(\lbrace U(x)\rbrace , x\in[a,
b]\)</span>, 在 <span class="math inline">\(U(x)\)</span> 内, <span
class="math inline">\(f(x)&lt;A-\varepsilon_x\)</span>. 由有限覆盖定理,
<span class="math inline">\(f(x)&lt;A-\min_{U(x)\in
\Sigma&#39;}\varepsilon_x\)</span>, 故 <span
class="math inline">\(A\)</span> 不为上确界, 矛盾.</p></li>
</ol>
<p><strong>零点定理/介值定理</strong></p>
<p>二分法+闭区间套.</p>
<p><strong>康托尔定理</strong></p>
<ol type="1">
<li><p>引理: 函数的柯西收敛准则: <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)\)</span> 存在等价于
<span class="math inline">\(\forall \varepsilon &gt; 0, \exists \delta
&gt; 0, \forall x_1, x_2\in U^o(x_0, \delta),
|f(x_1)-f(x_2)|&lt;\delta\)</span>. (使用海涅定理可以证明)</p>
<p>使用有限覆盖定理即可. 这里需要做点处理, 以避免交叉. 例如,
可以取海涅定理中的 <span class="math inline">\(\delta\)</span> 为 <span
class="math inline">\(\delta_x\)</span>, 但以 <span
class="math inline">\(U(x, \delta_x/2)\)</span> 为当前点的覆盖, 最后取得
<span class="math inline">\(\delta=\min_{U(x,
\delta_x/2)\in\Sigma&#39;}(\delta_x/2)\)</span>,
从而避免取到相邻区间没有结论.</p></li>
<li><p>用反证法, 即 <span class="math inline">\(\exists
\varepsilon&gt;0, \forall \delta&gt;0, \exists x_1, x_2\in I,
|x_1-x_2|&lt;\delta, |f(x_1)-f(x_2)|\ge \varepsilon\)</span>. 取 <span
class="math inline">\(\delta = 1/n\)</span>, 有 <span
class="math inline">\(\lbrace x&#39;_n\rbrace\)</span> 和 <span
class="math inline">\(\lbrace x&#39;&#39;_n\rbrace\)</span> 满足 <span
class="math inline">\(|x&#39;_n-x&#39;&#39;_n|&lt;1/n\)</span> 且 <span
class="math inline">\(|f(x&#39;_n)-f(x&#39;&#39;_n)|\ge
\varepsilon_n\)</span>. 取有界数列 <span class="math inline">\(\lbrace
x&#39;_n\rbrace\)</span> 的一个收敛子列 <span
class="math inline">\(\lbrace x&#39;_{n_k}\rbrace \to c\)</span>, 则
<span class="math inline">\(\lim\limits_{k\to
\infty}x&#39;&#39;_{n_k}=\lim\limits_{k\to\infty}(x&#39;&#39;_{n_k}-x&#39;_{n_k})+\lim\limits_{k\to
\infty}x&#39;_{n_k}=c\)</span>. 故 <span
class="math inline">\(\lim\limits_{k\to
\infty}|f(x&#39;_{n_k})-f(x&#39;&#39;_{n_k})|=|f(c)-f(c)|=0\)</span>,
矛盾.</p></li>
</ol>
</blockquote>
</details>
<h2 id="一致连续">一致连续</h2>
<p>定义: <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(I\)</span> 上有定义, 若 <span
class="math inline">\(\forall \varepsilon &gt;0, \exists \delta &gt; 0,
\forall x_1, x_2\in I, |x_1-x_2|&lt;\delta\)</span>, 有 <span
class="math inline">\(|f(x_1)-f(x_2)|&lt;\varepsilon\)</span>, 则称
<span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(I\)</span> 上一致连续.</p>
<p><strong>康托尔定理</strong>: 闭区间上的连续函数一致连续.
证明见上.</p>
<p><strong>常用性质:</strong></p>
<ol type="1">
<li>设 <span class="math inline">\(f\in C(a, b)\)</span>, 则 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\((a,
b)\)</span> 内一致连续 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(f(a+0)\)</span> 和 <span
class="math inline">\(f(a-0)\)</span> 都存在.</li>
<li>设 <span class="math inline">\(f\)</span> 在区间 <span
class="math inline">\(I\)</span> 和 <span
class="math inline">\(J\)</span> 上一致连续, 且 <span
class="math inline">\(I\cap J\ne \varnothing\)</span>, 则 <span
class="math inline">\(f\)</span> 在区间 <span
class="math inline">\(I\cup J\)</span> 上一致连续.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<ol type="1">
<li>(1)右推左: 构造闭区间上的连续函数, 用康托尔定理. (2)左推右:
使用柯西收敛准则.</li>
<li>对 <span class="math inline">\(x_1, x_2\)</span> 的取值进行分类:
若同在 <span class="math inline">\(I\)</span> 或同在 <span
class="math inline">\(J\)</span>, 则证毕; 否则, 使用 <span
class="math inline">\(f(x_0), x_0\in I\cap J\)</span>
作为过渡构造绝对值不等式.</li>
</ol>
</blockquote>
</details>
<h2 id="无穷小">无穷小</h2>
<p>无穷小: 以 <span class="math inline">\(0\)</span> 为极限的变量.</p>
<p>无穷大: 分为三种, <span class="math inline">\(+\infty\)</span>, <span
class="math inline">\(-\infty\)</span>, 两者统称为 <span
class="math inline">\(\infty\)</span>.</p>
<p><strong>无穷小的性质</strong></p>
<ol type="1">
<li><p>若 <span class="math inline">\(\lim f=A\)</span>, 则 <span
class="math inline">\(f=A+\alpha\)</span>, 其中 <span
class="math inline">\(\alpha\)</span> 为无穷小.</p></li>
<li><p>有界性.(数列整体有界, 函数局部有界)</p></li>
<li><p>无穷小的线性组合是无穷小.</p></li>
<li><p>无穷小乘有界函数是无穷小.</p></li>
<li><p>无穷小的乘积是无穷小.</p></li>
<li><p>无穷小(非零)的倒数是无穷大.</p></li>
</ol>
<p><strong>无穷小的比较</strong></p>
<p>根据 <span class="math inline">\(\lim\limits_{x\to
x_0}\dfrac{\alpha(x)}{\beta(x)}\)</span> 的值,
把无穷小直接的关系分为高阶、低阶、等阶, 若值为 <span
class="math inline">\(1\)</span>, 称为等价. <span
class="math inline">\(x(x\to 0)\)</span> 称为基准无穷小, 等阶于 <span
class="math inline">\(x^s(x\to 0)\)</span> 的称为 <span
class="math inline">\(s\)</span> 阶无穷小. 等价无穷小可替换.</p>
<p>常见的等价无穷小替换:</p>
<p><span class="math inline">\(\sin x\sim \tan x \sim \ln(1+x)\sim e^x-1
\sim \arcsin x\sim \arctan x \sim x\)</span>.</p>
<p><span class="math inline">\(1-\cos x \sim
\dfrac{1}{2}x^2\)</span>.</p>
<p><span class="math inline">\((1+x)^k-1\sim kx\)</span>.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>证明: <span class="math inline">\(\sin x\sim \tan x\sim \arcsin x\sim
\arctan x\sim x\)</span> 以及 <span class="math inline">\(1-\cos x\sim
\dfrac{1}{2}x^2\)</span> 根据第一个重要极限可得.</p>
<p>而</p>
<p><span class="math display">\[
\lim_{x\to 0}\dfrac{\ln(1+x)}{x} = \lim_{x\to
0}\ln{(1+x)^{1/x}}=\ln{\lim_{x\to 0}(1+x)^{1/x}}=\ln e=1.
\]</span></p>
<p>对于 <span class="math inline">\(\dfrac{e^x-1}{x}\)</span>, 令 <span
class="math inline">\(y=e^x-1\)</span>, <span
class="math inline">\(x=\ln(1+y)\)</span>, 由上可得.</p>
<p>对于 <span class="math inline">\(\dfrac{(1+x)^k-1}{x}\)</span>, 令
<span class="math inline">\(y=(1+x)^k-1\)</span>, 则 <span
class="math inline">\(\ln(1+y)=k\ln(1+x)\)</span>, 则</p>
<p><span class="math display">\[
\lim_{x\to 0}\dfrac{(1+x)^k-1}{x}=\lim_{y\to 0}\dfrac{y}{\ln(1+y)}\cdot
k\cdot\lim_{x\to 0} \dfrac{\ln(1+x)}{x}=k.
\]</span></p>
</blockquote>
</details>
<h1 id="典题赏析">典题赏析</h1>
<ol type="1">
<li>若 <span class="math inline">\(X, Y\)</span> 为 <span
class="math inline">\(\mathbb R_+\cup\lbrace 0\rbrace\)</span> 的子集,
证明 <span class="math inline">\(\inf_{x\in X, y\in Y}\lbrace xy\rbrace
=\inf_{x\in X}\lbrace x\rbrace +\inf_{y\in Y}\lbrace
y\rbrace\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>首先, <span class="math inline">\(0\)</span> 是 <span
class="math inline">\(X, Y\)</span> 的下界, 故 <span
class="math inline">\(A=\inf_{x\in X}\lbrace x\rbrace\)</span> 和 <span
class="math inline">\(B=\inf_{y\in Y}\lbrace y\rbrace\)</span> 均存在且
<span class="math inline">\(A\ge 0, B\ge 0\)</span>. <span
class="math inline">\(\forall x\in X, y\in Y, x\ge A, y\ge B\)</span>,
故 <span class="math inline">\(xy\ge AB\)</span>, <span
class="math inline">\(AB\)</span> 下界存在, 故 <span
class="math inline">\(C=\inf_{x\in X, y\in Y}\lbrace xy\rbrace\)</span>
存在, 下证 <span class="math inline">\(C=AB\)</span>. 由 <span
class="math inline">\(A, B\)</span> 分别是 <span
class="math inline">\(X, Y\)</span> 的下确界知, <span
class="math inline">\(\forall \varepsilon&#39;&gt;0\)</span>, 存在 <span
class="math inline">\(x_0\in X, A\le x_0&lt;A+\varepsilon&#39;\)</span>,
存在 <span class="math inline">\(y_0\in Y, B\le
y_0&lt;B+\varepsilon&#39;\)</span>, 故 <span class="math display">\[
AB\le
x_0y_0&lt;(A+\varepsilon&#39;)(B+\varepsilon&#39;)=AB+\varepsilon&#39;(A+B)+\varepsilon&#39;^2.
\]</span> 于是 <span class="math inline">\(\forall
\varepsilon&gt;0\)</span>, 取 <span
class="math inline">\(\varepsilon&#39;\)</span> 满足 <span
class="math inline">\(\varepsilon&#39;&gt;0\)</span> 且 <span
class="math inline">\(\varepsilon&#39;(A+B)+\varepsilon&#39;^2=\varepsilon\)</span>,
故 <span class="math inline">\(x_0y_0&lt;AB+\varepsilon\)</span>, 即证
<span class="math inline">\(AB\)</span> 为下确界, 即原命题成立.</p>
</blockquote>
</details>
<ol start="2" type="1">
<li>证明 <span
class="math inline">\(\lim\limits_{n\to+\infty}\sqrt[n]a=1\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<p><img src="pro2_sol.png" /></p>
</details>
<ol start="3" type="1">
<li>证明 <span
class="math inline">\(\lim\limits_{n\to+\infty}\sqrt[n]n=1\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<p><img src="pro3_sol.png" /></p>
</details>
<ol start="4" type="1">
<li>证明: 设 <span class="math inline">\(n\to \infty\)</span> 时, <span
class="math inline">\(a_n\to A, b_n\to B\)</span>, 则(1) <span
class="math inline">\(\dfrac{\sum_{i=1}^na_i}{n}\to A\)</span>; (2)
<span class="math inline">\(\dfrac{\sum_{i=1}^na_ib_{n-i+1}}{n}\to
AB\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>前者即证 <span
class="math inline">\(\dfrac{\sum_{i=1}^n(a_i-A)}{n}\to 0\)</span>. 对前
<span class="math inline">\(N\)</span> 项显然为 <span
class="math inline">\(0\)</span>, <span class="math inline">\(N\)</span>
之后的项利用 <span class="math inline">\(\epsilon\)</span> 放缩即可.</p>
<p>后者类似, 分成前、中、后三部分证明.</p>
</blockquote>
</details>
<ol start="5" type="1">
<li>证明: <span
class="math inline">\(\lim\limits_{n\to\infty}\dfrac{n}{a^n}=0(a&gt;1)\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>设 <span class="math inline">\(b=a-1\)</span>, 则</p>
<p><span class="math display">\[
0\le
\dfrac{n}{a^n}=\dfrac{n}{(1+b)^n}&lt;\dfrac{n}{\frac{n(n-1)}{2}b^2}=\dfrac{2}{b^2(n-1)}
\]</span></p>
<p>夹逼得极限为 <span class="math inline">\(0\)</span>.</p>
</blockquote>
</details>
<ol start="6" type="1">
<li>证明: 无界数列 <span class="math inline">\(\lbrace
x_n\rbrace\)</span> 必存在子数列 <span class="math inline">\(\lbrace
x_{n_k}\rbrace\)</span> 使得 <span
class="math inline">\(\lim\limits_{k\to
\infty}x_{n_k}=\infty\)</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>因为无界, 故 <span class="math inline">\(\forall M&gt;0, \exists n,
|x_n|&gt;M\)</span>.</p>
<p>依次取 <span class="math inline">\(M=k\)</span>, 故 <span
class="math inline">\(\exists n_k, |x_{n_k}|&gt;k\)</span>. 可以省略前
<span class="math inline">\(n_{k-1}\)</span> 项来取, 这样能够保证 <span
class="math inline">\(n_k\)</span> 递增. 故 <span
class="math inline">\(\lbrace x_{n_k}\rbrace\)</span>
是趋于无穷大的数列.</p>
</blockquote>
</details>
<ol start="7" type="1">
<li>证明: <span class="math inline">\(\lim\limits_{x\to +\infty}\arctan
x=\dfrac{\pi}{2}, \lim\limits_{x\to -\infty}\arctan
x=-\dfrac{\pi}{2}\)</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>只证前者.</p>
<p><span class="math display">\[
|\arctan x - \dfrac{\pi}{2}|=\dfrac{\pi}{2}-\arctan
x=\operatorname{arccot} x
\]</span></p>
<p>欲让上式小于 <span class="math inline">\(\varepsilon\)</span>, 只需
<span class="math inline">\(x&gt;\cot \varepsilon\)</span> 即可.</p>
</blockquote>
</details>
<ol start="8" type="1">
<li>设 <span class="math display">\[
     f(x)=\begin{cases}
         x, x\, \textnormal{是有理数};
         \\
         -x, x\, \textnormal{是无理数}.
     \end{cases}
\]</span> 求证 (1) 当 <span class="math inline">\(a\ne 0\)</span> 时,
<span class="math inline">\(\lim\limits_{x\to a}f(x)\)</span> 不存在;
(2) 当 <span class="math inline">\(a=0\)</span> 时, <span
class="math inline">\(\lim\limits_{x\to a}f(x)=0\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<ol type="1">
<li><p>取有理数列 <span class="math inline">\(\lbrace a_n\rbrace \to
a\)</span>, 则 <span class="math inline">\(\lbrace f(a_n)\rbrace
=\lbrace a_n\rbrace \to a\)</span>. 取无理数列 <span
class="math inline">\(\lbrace a_n\rbrace \to a\)</span>, 则 <span
class="math inline">\(\lbrace f(a_n)\rbrace =\lbrace -a_n\rbrace \to
-a\)</span>.</p></li>
<li><p>对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>, 取
<span class="math inline">\(\delta=\varepsilon\)</span>, 当 <span
class="math inline">\(0&lt;|x-0|&lt;\delta\)</span>, 有 <span
class="math inline">\(|f(x)-0|=|x|&lt;\varepsilon\)</span>, 故极限为
<span class="math inline">\(0\)</span>.</p></li>
</ol>
</blockquote>
</details>
<ol start="9" type="1">
<li>证明: <span class="math inline">\(\lim\limits_{x\to
+\infty}f(x)=+\infty \Leftrightarrow \forall x_n:
x_n\to+\infty(n\to\infty)\)</span> 有 <span class="math display">\[
    \lim\limits_{n\to\infty}f(x_n)=+\infty.
\]</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>非常类似于海涅定理的证明. 左推右显然, 右推左反证, 即反设 <span
class="math inline">\(\exists H&gt;0, \forall G&gt;0, \exists x &gt; G,
f(x)\le H\)</span>. 取 <span class="math inline">\(G=n\)</span>, 则存在
<span class="math inline">\(x_n&gt;n, f(x_n)\le H\)</span>. 故我们找到
<span class="math inline">\(\lbrace x_n\rbrace \to +\infty\)</span> 但是
<span class="math inline">\(f(x_n)\)</span> 不趋于 <span
class="math inline">\(+\infty\)</span>.</p>
</blockquote>
</details>
<ol start="10" type="1">
<li>函数 <span class="math inline">\(f\)</span> 定义在 <span
class="math inline">\((0, 1)\)</span> 内为 <span class="math display">\[
    f(x)=\begin{cases}
   0,\quad x\,\textnormal{为无理数},
   \\
   \dfrac{1}{q}, x=\dfrac{p}{q}, p,q,\in \mathbb Z, \dfrac{p}{q}
\textnormal{是最简分数}.
    \end{cases}
   \]</span> 证明: 若 <span class="math inline">\(a\in(0, 1)\)</span>,
则 <span class="math inline">\(\lim\limits_{x\to a}f(x)=0\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>, 要让
<span class="math inline">\(|f(x)|&lt;\varepsilon\)</span>, 有两种情况.
若 <span class="math inline">\(x\)</span> 是无理数, 显然成立; 若 <span
class="math inline">\(x\)</span> 是有理数且为 <span
class="math inline">\(\dfrac{p}{q}\)</span>, 则有 <span
class="math inline">\(\dfrac{1}{q}&lt;\varepsilon\)</span>, 即 <span
class="math inline">\(q&gt;\dfrac{1}{\varepsilon}\)</span>. 也就是说,
<span class="math inline">\(x\)</span> 不可取到形如 <span
class="math inline">\(\dfrac{p}{q}\)</span> 且 <span
class="math inline">\(q\le \dfrac{1}{\varepsilon}\)</span> 的有理数.
这样的有理数(除去 <span class="math inline">\(a\)</span> 点)在 <span
class="math inline">\((0, 1)\)</span> 内仅有有限个, 设为 <span
class="math inline">\(x_1, x_2, \cdots, x_m\)</span>, 取 <span
class="math inline">\(\delta=\min_{1\le i\le m}|a-x_i|\)</span>,
就可以避开这些有理数, 故可满足条件.</p>
</blockquote>
</details>
<ol start="11" type="1">
<li>证明 <span
class="math inline">\(\lim\limits_{n\to+\infty}x_n=A\Leftrightarrow
\lbrace x_n\rbrace\)</span> 的任意子数列都以 <span
class="math inline">\(A\)</span> 为极限.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>左推右显然, 右推左可以用反证, 非常类似海涅定理的证明. 设 <span
class="math inline">\(\exists \varepsilon, \forall N&gt;0, \exists
n&gt;N, |x_n-A|\ge \varepsilon\)</span>. 取 <span
class="math inline">\(N=k\)</span>, 则 <span
class="math inline">\(\exists n_k&gt;k\)</span>, <span
class="math inline">\(|x_{n_k}-A|\ge\varepsilon\)</span>.
这里还是得认真考虑一下 <span class="math inline">\(n_k\)</span>
递增的问题, 即去除前 <span class="math inline">\(n_{k-1}\)</span>
项后再考虑. 后面的证明就显然了.</p>
</blockquote>
</details>
<ol start="12" type="1">
<li>求 <span class="math inline">\(\lim\limits_{n\to
\infty}\sqrt[n]{a_1^n+a_2^n+\cdots+a_k^n}\)</span>, 其中 <span
class="math inline">\(k\)</span> 确定, <span
class="math inline">\(a_i\ge 0\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>设 <span class="math inline">\(M = \max_{1\le i\le k}a_i\)</span>,
故有:</p>
<p><span class="math display">\[
\sqrt[n]{M^n}\le \sqrt[n]{a_1^n+a_2^n+\cdots+a_k^n} \le \sqrt[n]{kM^n}
\]</span> 夹逼得原极限等于 <span class="math inline">\(M\)</span>.</p>
</blockquote>
</details>
<ol start="13" type="1">
<li>求 <span class="math inline">\(n\to+\infty\)</span> 时,
下列各式的极限: (1) <span class="math inline">\(na^n(|a|&lt;1)\)</span>;
(2) <span class="math inline">\(\dfrac{a^n}{n!}\)</span> (<span
class="math inline">\(a\)</span> 是常数); (3) <span
class="math inline">\(\dfrac{n^\mu}{a^n}\)</span> (<span
class="math inline">\(a&gt;1,\mu&gt;0\)</span> 是常数).</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>使用"比值判别法"(见下方).</p>
<ol type="1">
<li><p>由于 <span
class="math inline">\(\left|\dfrac{(n+1)a^{n+1}}{na^n}\right|=a\cdot
\dfrac{n+1}{n}\to a\)</span>, 且 <span
class="math inline">\(a&lt;1\)</span>, 故原式极限为 <span
class="math inline">\(0\)</span>.</p></li>
<li><p>由于 <span
class="math inline">\(\left|\dfrac{a^{n+1}/(n+1)!}{a^n/n!}\right|=\dfrac{a}{n+1}\to
0\)</span>, 故原式极限为 <span
class="math inline">\(0\)</span>.</p></li>
<li><p>由于 <span
class="math inline">\(\left|\dfrac{(n+1)^\mu/a^{(n+1)}}{n^\mu/a^n}\right|=\dfrac{1}{a}\cdot
\dfrac{(n+1)^\mu}{n^\mu}\to \dfrac{1}{a}\)</span>, 且 <span
class="math inline">\(\dfrac{1}{a}&lt;1\)</span>, 故原式极限为 <span
class="math inline">\(0\)</span>.</p></li>
</ol>
</blockquote>
</details>
<ol start="14" type="1">
<li>设 <span class="math inline">\(a&gt;1\)</span>, 求证: (1) <span
class="math inline">\(\lim\limits_{x\to +\infty}\dfrac{x^\mu}{a^x}=0(\mu
&gt; 0)\)</span>; (2) <span class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{\log_ax}{x^\mu}=0(\mu&gt;0)\)</span>; (3) <span
class="math inline">\(\lim\limits_{x\to 0+}x^\beta\log_ax=0(\beta &gt;
0)\)</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>(1). 先证明 <span class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{x}{a^x}=0(a&gt;1)\)</span>. 由上我们已证得 <span
class="math inline">\(\lim\limits_{n\to
\infty}\dfrac{n}{a^n}=0\)</span>. 又有不等式 <span
class="math inline">\(\dfrac{\lfloor x\rfloor}{a^{\lfloor
x\rfloor+1}}&lt; \dfrac{x}{a^x}&lt;\dfrac{\lfloor x\rfloor
+1}{a^{\lfloor x\rfloor}}\)</span>, 夹逼易得 <span
class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{x}{a^x}=0\)</span>.</p>
<p>接下来, 对于 <span class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{x^\mu}{a^x}\)</span>, 令 <span
class="math inline">\(t=x^\mu\to +\infty\)</span>, 则 <span
class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{x^\mu}{a^x}=\lim\limits_{t\to
+\infty}\dfrac{t}{(a^{1/\mu})^t}=0\)</span>.</p>
<p>(2). 同样地, 对于 <span class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{\log_ax}{x}\)</span>, 令 <span
class="math inline">\(k=\log_ax\)</span>, 可直接转换为 (1) 中情形.</p>
<p>对于 <span class="math inline">\(\lim\limits_{x\to
+\infty}\dfrac{\log_ax}{x^\mu}\)</span>, 对 <span
class="math inline">\(x^\mu\)</span> 换元可转化为前一种情形.</p>
<p>(3). 令 <span
class="math inline">\(t=\dfrac{1}{x}\to+\infty\)</span>, 则 <span
class="math inline">\(\lim\limits_{x\to
0+}x^\beta\log_ax=-\lim\limits_{t\to
+\infty}\dfrac{\log_at}{t^\beta}=0\)</span>.</p>
</blockquote>
</details>
<ol start="15" type="1">
<li>设 <span class="math inline">\(\sup\limits_{x\in X}\lbrace x\rbrace
=\beta\)</span>, 试证从 <span class="math inline">\(X\)</span>
中可选取数列 <span class="math inline">\(\lbrace x_n\rbrace\)</span>, 使
<span class="math inline">\(\lim\limits_{n\to\infty}x_n=\beta\)</span>.
(<span class="math inline">\(\beta\)</span> 换成 <span
class="math inline">\(+\infty\)</span> 也成立)</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>由于上确界的性质, 我们知道 <span class="math inline">\(\forall
\varepsilon&gt;0, \exists x\in X, \beta-\varepsilon&lt;x\le
\beta\)</span>.</p>
<p>取 <span class="math inline">\(\varepsilon=1/n\)</span>, 则可取得数列
<span class="math inline">\(\lbrace x_n\rbrace\)</span> 满足 <span
class="math inline">\(\beta - 1/n&lt;x_n&lt;\beta\)</span>, 从而 <span
class="math inline">\(|x_n-\beta|&lt;1/n\to 0\)</span>, 夹逼准则知,
该数列极限为 <span class="math inline">\(\beta\)</span>.</p>
</blockquote>
</details>
<ol start="16" type="1">
<li>证明 <span class="math display">\[
    \left(\dfrac{n}{e}\right)^n&lt;n!&lt;e\left(\dfrac{n}{2}\right)^n
\]</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>首先, 一个显然的不等式是 <span
class="math inline">\(2\le\left(1+\dfrac{1}{n}\right)^n&lt;e\)</span>.</p>
<p>用归纳法. 当 <span class="math inline">\(n=1\)</span> 时显然成立.
假设 <span class="math inline">\(n=k-1(k\ge 2)\)</span> 时成立, 即 <span
class="math display">\[
\left(\dfrac{k-1}{e}\right)^{k-1}&lt;(k-1)!&lt;e(\dfrac{k-1}{2})^{k-1}
\]</span> 则, 一方面 <span class="math display">\[
k!=k(k-1)!&gt;k\cdot
(\dfrac{k-1}{e})^{k-1}=\left(\dfrac{k}{e}\right)^k\cdot
\dfrac{e}{\left(1+\dfrac{1}{k-1}\right)^{k-1}}&gt;\left(\dfrac{k}{e}\right)^k
\]</span> 另一方面 <span class="math display">\[
k!=k(k-1)!&lt;k\cdot e\cdot \left(\dfrac{k-1}{2}\right)^{k-1}=e\cdot
\left(\dfrac{k}{2}\right)^k\cdot
\dfrac{2}{\left(1+\dfrac{1}{k-1}\right)^{k-1}}&lt;e\cdot
\left(\dfrac{k}{2}\right)^k
\]</span> 证毕.</p>
</blockquote>
</details>
<ol start="17" type="1">
<li>证明: 若 <span class="math inline">\(f(x)\in C(\mathbb R)\)</span>
且函数值均为有理数, 求证其为常数函数.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>反证法: 设 <span class="math inline">\(f\)</span> 不为常值函数,
不妨设 <span class="math inline">\(f(a)\ne f(b)\)</span> 且 <span
class="math inline">\(a&lt;b\)</span>. 不失一般性, 设 <span
class="math inline">\(f(a)&lt;f(b)\)</span>. 在区间 <span
class="math inline">\((f(a), f(b))\)</span> 中必存在无理数 <span
class="math inline">\(y_0\)</span>, 由介值定理可知 <span
class="math inline">\(\exists x_0\in (a, b)\)</span>, <span
class="math inline">\(f(x_0)=y_0\)</span>, 与 <span
class="math inline">\(f(x)\)</span> 函数值均为有理数矛盾. 故 <span
class="math inline">\(f(x)\)</span> 为常值函数.</p>
</blockquote>
</details>
<ol start="18" type="1">
<li>设 <span class="math inline">\(x_1, a&gt;0\)</span>, <span
class="math inline">\(x_{n+1}=\dfrac{1}{2}\left(x_n+\dfrac{a}{x_n}\right)\)</span>,
求 <span class="math inline">\(\lim\limits_{n\to
\infty}x_n\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>显然 <span class="math inline">\(x_n&gt;0\)</span>. 当 <span
class="math inline">\(n\ge 2\)</span>, 可知 <span
class="math inline">\(x_{n+1}=\dfrac{1}{2}\left(x_n+\dfrac{a}{x_n}\right)\ge
\sqrt a\)</span>. 故 <span class="math inline">\(\lbrace
x_n\rbrace\)</span> 有下界 <span class="math inline">\(0\)</span>. 并且
<span
class="math inline">\(\dfrac{x_{n+1}}{x_n}=\dfrac{1}{2}\left(1+\dfrac{a}{x_n^2}\right)\le
1(n\ge 2)\)</span>, 故 <span class="math inline">\(\lbrace
x_n\rbrace\)</span> 从第二项开始单调递减. 因为数列的敛散性和有限项无关,
故 <span class="math inline">\(\lbrace x_n\rbrace\)</span> 极限存在,
记为 <span class="math inline">\(A\)</span>, 在 <span
class="math inline">\(x_{n+1}=\dfrac{1}{2}\left(x_n+\dfrac{a}{x_n}\right)\)</span>
两边同时取极限, 可得 <span
class="math inline">\(A=\dfrac{1}{2}\left(A+\dfrac{a}{A}\right)\)</span>,
故 <span class="math inline">\(A=\sqrt a\)</span>(负值舍去).</p>
</blockquote>
</details>
<ol start="19" type="1">
<li>设 <span class="math inline">\(x_1=1,
x_{n+1}=\dfrac{1}{1+x_n}\)</span>, 求 <span
class="math inline">\(\lim\limits_{n\to\infty}x_n\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>令 <span class="math inline">\(A=\dfrac{1}{1+A}\)</span>, 即 <span
class="math inline">\(A^2=1-A\)</span>, 得 <span
class="math inline">\(A=\dfrac{\sqrt 5-1}{2}\)</span>(负值舍去).</p>
<p>则 <span class="math display">\[
|x_{n+1}-A|=\left|\dfrac{1-A-Ax_n}{1+x_n}\right|=\left|\dfrac{A(A-x_n)}{1+x_n}\right|\le
A\left|x_n-A\right|\le \cdots \le A^n|x_1-A|
\]</span> 由夹逼定理得 <span class="math inline">\(\lim\limits_{n\to
\infty}x_n=A=\dfrac{\sqrt 5-1}{2}\)</span></p>
</blockquote>
</details>
<ol start="20" type="1">
<li>设 <span
class="math inline">\(\lim\limits_{x\to\infty}\left(\dfrac{x^2}{x+1}-ax-b\right)=0\)</span>,
求 <span class="math inline">\(a, b\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>可知 <span
class="math inline">\(\lim\limits_{x\to\infty}\left(\dfrac{x}{x+1}-a-\dfrac{b}{x}\right)=\lim\limits_{x\to\infty}\dfrac{1}{x}\left(\dfrac{x^2}{x+1}-ax-b\right)=0\)</span>,
即 <span class="math inline">\(1-a=0\)</span>, <span
class="math inline">\(a=1\)</span>.</p>
<p>代回原式得 <span
class="math inline">\(\lim\limits_{x\to\infty}\left(\dfrac{x^2}{x+1}-x-b\right)=\lim\limits_{x\to\infty}\left(\dfrac{-x}{x+1}-b\right)=0\)</span>,
故 <span class="math inline">\(-1-b=0\)</span>, <span
class="math inline">\(b=-1\)</span>.</p>
</blockquote>
</details>
<ol start="21" type="1">
<li>设 <span class="math inline">\(f(x)\)</span> 在区间 <span
class="math inline">\([0, 1]\)</span> 上连续, <span
class="math inline">\(f(0)=0, f(1)=1\)</span>, 求证: 存在 <span
class="math inline">\(\xi\in(0, 1)\)</span>, 使得 <span
class="math display">\[
    f\left(\xi-\dfrac{1}{3}\right)=f(\xi)-\dfrac{1}{3}.
\]</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>令 <span
class="math inline">\(F(x)=f(x)-f\left(x-\dfrac{1}{3}\right)-\dfrac{1}{3}\)</span>,
<span class="math inline">\(x\in \left[\dfrac{1}{3}, 1\right]\)</span>.
问题转化为 <span class="math inline">\(F(x)\)</span> 在 <span
class="math inline">\(\left[\dfrac{1}{3}, 1\right)\)</span>
内是否有根.</p>
<p>若 <span class="math inline">\(F\left(\dfrac{2}{3}\right)=0\)</span>,
则有根 <span class="math inline">\(\dfrac{2}{3}\)</span>, 命题成立.</p>
<p>若 <span class="math inline">\(F\left(\dfrac{2}{3}\right)\ne
0\)</span>, 由于 <span
class="math inline">\(F\left(\dfrac{1}{3}\right)+F\left(\dfrac{2}{3}\right)+F\left(\dfrac{3}{3}\right)=0\)</span>,
则 <span class="math inline">\(F\left(\dfrac{1}{3}\right)\)</span> 和
<span class="math inline">\(F\left(\dfrac{3}{3}\right)\)</span>
中至少有一个与 <span
class="math inline">\(F\left(\dfrac{2}{3}\right)\)</span> 异号.
在异号一侧用零点定理即可.</p>
</blockquote>
</details>
<ol start="22" type="1">
<li>求极限: <span class="math inline">\(\lim\limits_{n\to
\infty}\dfrac{\sum_{i=1}^ni!}{n!}\)</span>.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>因为 <span class="math inline">\(\dfrac{n!}{n!}\le
\dfrac{\sum_{i=1}^ni!}{n!}\le
\dfrac{(n-2)(n-2)!+(n-1)!+n!}{n!}!\)</span></p>
<p>夹逼可得原极限为 <span class="math inline">\(1\)</span>.</p>
</blockquote>
</details>
<ol start="23" type="1">
<li>证明 <span
class="math inline">\(\left|e-\left(1+\dfrac{1}{n}\right)^n\right|&lt;\dfrac{e}{n}\)</span></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>一方面, <span
class="math inline">\(e-\left(1+\dfrac{1}{n}\right)&lt;\left(1+\dfrac{1}{n}\right)^{n+1}-\left(1+\dfrac{1}{n}\right)^{n}=\dfrac{1}{n}\left(1+\dfrac{1}{n}\right)^n&lt;\dfrac{e}{n}\)</span>;
另一方面, <span
class="math inline">\(e-\left(1+\dfrac{1}{n}\right)&gt;0\)</span>,
故可得.</p>
</blockquote>
</details>
<ol start="24" type="1">
<li>举出符合下列要求的函数: (1) 只在 <span class="math inline">\(1/2,
1/3, 1/4\)</span> 三点不连续的函数. (2) 只在 <span
class="math inline">\(1/2, 1/3, 1/4\)</span> 三点连续的函数. (3) 只在
<span class="math inline">\(x=0\)</span> 处右连续的函数.</li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<p>(1). <span
class="math inline">\(\dfrac{1}{(x-1/2)(x-1/3)(x-1/4)}\)</span>. (2).
<span class="math inline">\((x-1/2)(x-1/3)(x-1/4)D(x)\)</span>. (3).
<span class="math inline">\(\begin{cases}xD(x),&amp;x\ge 0;\\ D(x),
&amp;x&lt;0\end{cases}\)</span></p>
</blockquote>
</details>
<ol start="25" type="1">
<li>设函数 <span class="math inline">\(f\)</span> 在区间 <span
class="math inline">\(I\)</span> 上连续, 证明:
<ol type="1">
<li>若对任何有理数 <span class="math inline">\(r\in I, f(r)=0\)</span>,
则 <span class="math inline">\(f\equiv 0\)</span>.</li>
<li>若对任意两个有理数 <span class="math inline">\(r_1, r_2\in I,
r_1&lt;r_2\)</span>, 有 <span
class="math inline">\(f(r_1)&lt;f(r_2)\)</span>, 则 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上严格增加.</li>
</ol></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<ol type="1">
<li><span class="math inline">\(\forall x_0\in I\)</span>, 存在有理数列
<span class="math inline">\(\lbrace x_n\rbrace\)</span> 满足 <span
class="math inline">\(x_n\in I\)</span> 且 <span
class="math inline">\(\lbrace x_n\rbrace \to x_0\)</span>. 那么 <span
class="math inline">\(f(x_0)=\lim\limits_{x\to
x_0}f(x)=\lim\limits_{n\to \infty}f(x_n)=0\)</span>.</li>
<li><span class="math inline">\(\forall x_1, x_2\in I,
x_1&lt;x_2\)</span>, 存在 <span class="math inline">\(r_1, r_2\in
\mathbb Q\)</span> 且 <span class="math inline">\(x_1&lt;r_1 &lt; r_2
&lt;x_2\)</span>. 存在单调递减有理数列 <span
class="math inline">\(\lbrace a_n\rbrace\)</span> 和单调递增有理数列
<span class="math inline">\(\lbrace b_n\rbrace\)</span> 满足 <span
class="math inline">\(a_n\in(x_1, r_1)\)</span>, <span
class="math inline">\(\lbrace a_n\rbrace \to x_1\)</span>, <span
class="math inline">\(b_n\in(r_2, x_2)\)</span>, <span
class="math inline">\(\lbrace b_n\rbrace \to x_2\)</span>, 那么 <span
class="math inline">\(a_n&lt;r_1&lt;r_2&lt;b_n\)</span>,
由极限的保号性有 <span
class="math inline">\(\lim\limits_{n\to\infty}a_n\le r_1&lt;r_2\le
\lim\limits_{n\to \infty}b_n\)</span>, 故 <span
class="math inline">\(f(x_1)&lt;f(x_2)\)</span>. 从而单调性得证.</li>
</ol>
</blockquote>
</details>
<ol start="26" type="1">
<li>设 <span class="math inline">\(\lbrace a_n\rbrace\)</span>
为有界数列, 记 <span class="math inline">\(\beta_n=\sup\lbrace a_n,
a_{n+1}, \cdots\rbrace, \alpha_n=\inf\lbrace a_n, a_{n+1},
\cdots\rbrace\)</span>, 证明:
<ol type="1">
<li>对 <span class="math inline">\(\forall n\in \mathbb N^+, \beta_n\ge
\alpha_n\)</span>.</li>
<li><span class="math inline">\(\lbrace \beta_n\rbrace\)</span>
递减有界, <span class="math inline">\(\lbrace \alpha_n \rbrace\)</span>
递增有界, 且对 <span class="math inline">\(\forall m, n\in \mathbb N^+,
\beta_n\ge \alpha_m\)</span>.</li>
<li>设 <span class="math inline">\(\beta\)</span> 和 <span
class="math inline">\(\alpha\)</span> 分别是 <span
class="math inline">\(\lbrace \beta_n\rbrace\)</span> 和 <span
class="math inline">\(\lbrace \alpha_n\rbrace\)</span> 的极限, 则 <span
class="math inline">\(\beta\ge \alpha\)</span>.</li>
<li><span class="math inline">\(\lbrace a_n\rbrace\)</span>
收敛的充要条件是 <span class="math inline">\(\beta=\alpha\)</span>.</li>
</ol></li>
</ol>
<details>
<summary>
<b>解答</b>
</summary>
<blockquote>
<ol type="1">
<li>对 <span class="math inline">\(\forall n\in\mathbb N^+\)</span>,
<span class="math inline">\(\beta_n\ge a_n\ge \alpha_n\)</span>.</li>
<li>由 <span class="math inline">\(\beta_n=\sup\lbrace a_n, a_{n+1},
\cdots\rbrace\)</span>, 可知 <span class="math inline">\(\forall
i\in\lbrace n+1, n+2, \cdots\rbrace, \beta_n\ge a_i\)</span>, <span
class="math inline">\(\beta_n\)</span> 是 <span
class="math inline">\(\lbrace a_{n+1}, a_{n+2}, \cdots\rbrace\)</span>
的一个上界. 又上确界是最小上界, 有 <span
class="math inline">\(\beta_n\ge \beta_{n+1}\)</span>. 同理 <span
class="math inline">\(\alpha_n\le \alpha_{n+1}\)</span>. 又 <span
class="math inline">\(\beta_n\ge \alpha_n\ge \alpha_{n-1}\ge \cdots\ge
\alpha_1\)</span>, 故 <span class="math inline">\(\alpha_1\)</span> 是
<span class="math inline">\(\lbrace\beta_n\rbrace\)</span> 的一个下界.
同理, <span class="math inline">\(\beta_1\)</span> 是 <span
class="math inline">\(\lbrace\alpha_n\rbrace\)</span> 的一个上界.
证毕.</li>
<li>由于 <span class="math inline">\(\beta_n\ge \alpha_n\)</span>,
由极限的保号性, 有 <span class="math inline">\(\beta_n\ge
\alpha\)</span>, 再用一次, 有 <span class="math inline">\(\beta\ge
\alpha\)</span>.</li>
<li>(1)必要性. 若 <span class="math inline">\(\lbrace
a_n\rbrace\)</span> 收敛到 <span class="math inline">\(A\)</span>, 则
<span class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists N&gt;0\)</span>, <span
class="math inline">\(\forall n&gt;N\)</span>, <span
class="math inline">\(A-\varepsilon&lt;a_n&lt;A+\varepsilon\)</span>. 则
<span class="math inline">\(n&gt;N\)</span> 时, <span
class="math inline">\(A-\varepsilon&lt; \alpha_n\le \beta_n\le
A+\varepsilon\)</span>, 则证得 <span
class="math inline">\(\alpha=\beta=A\)</span>. (2) 充分性. 若 <span
class="math inline">\(\beta=\alpha=A\)</span>, 则 <span
class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists N&gt;0\)</span>, <span
class="math inline">\(\forall n&gt;N\)</span>, <span
class="math inline">\(A-\varepsilon&lt; \alpha\le
\beta&lt;A+\varepsilon\)</span>, 又 <span class="math inline">\(\beta\ge
a_n\ge \alpha\)</span>, 可知 <span
class="math inline">\(A-\varepsilon&lt;a_n\le A+\varepsilon\)</span>, 故
<span class="math inline">\(\lbrace a_n\rbrace\)</span> 收敛到 <span
class="math inline">\(A\)</span>.</li>
</ol>
</blockquote>
</details>
<ol start="27" type="1">
<li>证明下列各题:
<ol type="1">
<li>设 <span class="math inline">\(I\)</span> 为有限区间, <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上一致连续, 证明: <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上有界.</li>
<li>用一致连续定义证明: 若 <span class="math inline">\(f, g\)</span> 在
<span class="math inline">\(I\)</span> 上一致连续, 则 <span
class="math inline">\(f\pm g\)</span> 在 <span
class="math inline">\(I\)</span> 上一致连续.</li>
</ol></li>
</ol>
<details>
<summary>
<b>展开</b>
</summary>
<blockquote>
<ol type="1">
<li>只考虑 <span class="math inline">\(I\)</span> 为开区间 <span
class="math inline">\((a, b)\)</span> 的情况, 其它情况类似. 由一致连续,
可知 <span class="math inline">\(f(a+), f(b-)\)</span> 存在, 可把 <span
class="math inline">\((a, b)\)</span> 分成 <span
class="math inline">\((a, a+\delta_1)\)</span>, <span
class="math inline">\([\delta_1, \delta_2]\)</span>, <span
class="math inline">\((\delta_2, b)\)</span> 三段,
一三部分可用极限的局部有界性, 第二部分利用闭区间的有界性定理.</li>
<li>用三角不等式即可证明.</li>
</ol>
</blockquote>
</details>
<ol start="28" type="1">
<li>设 <span class="math inline">\(f\in C[a, +\infty)\)</span>, 且 <span
class="math inline">\(\lim\limits_{x\to \infty}f(x)\)</span> 存在.
<ol type="1">
<li>证明: <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, +\infty)\)</span> 上有界.</li>
<li>证明: <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, +\infty)\)</span> 上一致连续.</li>
</ol></li>
</ol>
<details>
<summary>
<b>展开</b>
</summary>
<blockquote>
<ol type="1">
<li>由极限存在, 可分为 <span class="math inline">\([a, b]\)</span> 和
<span class="math inline">\((b, +\infty)\)</span>. 前者显然有界,
后者用极限的局部有界性.</li>
<li><span class="math inline">\([a, b]\)</span> 用康托尔定理, <span
class="math inline">\((b, +\infty)\)</span> 用柯西收敛准则即可.
再使用区间的并仍然一致连续的性质.</li>
</ol>
</blockquote>
</details>
<h1 id="方法总结">方法总结</h1>
<h2 id="比值判别法">比值判别法</h2>
<details>
<summary>
<b>展开</b>
</summary>
<p><img src="quat_judge_method.png" /></p>
</details>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Calculus</tag>
        <tag>Maths</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 22.04 上配置蓝牙耳机</title>
    <url>/posts/548117f2/</url>
    <content><![CDATA[<p>尝试在 Ubuntu 22.04 上连接了我的 HUAWEI FreeBuds 4E 耳机.</p>
<span id="more"></span>
<h1 id="环境信息">环境信息</h1>
<ul>
<li>系统版本: Ubuntu 22.04 LTS.</li>
<li>耳机信息: HUAWEI FreeBuds 4E.</li>
</ul>
<h1 id="问题描述">问题描述</h1>
<p>使用系统自带的 GUI 界面连接蓝牙失败, 一直转圈,
耳机一直是表示"待连接"的白色灯光.</p>
<p>意识到可能是蓝牙驱动的问题, 于是 STFW.</p>
<h1 id="问题解决">问题解决</h1>
<p>根据<a
href="https://blog.csdn.net/weixin_48120620/article/details/126229978"
class="uri">https://blog.csdn.net/weixin_48120620/article/details/126229978</a>的流程配置成功,
以下是解决步骤.</p>
<h2 id="step-1-安装-pulseaudio-module-bluetooth">Step 1 安装
pulseaudio-module-bluetooth</h2>
<p>终端输入以下命令:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install pulseaudio-module-bluetooth </span><br><span class="line">pulseaudio -k</span><br><span class="line">pulseaudio --start</span><br><span class="line"><span class="built_in">sudo</span> pactl load-module module-bluetooth-discover</span><br></pre></td></tr></table></figure>
<h2 id="step-2-使用-cli-蓝牙设置进行连接">Step 2 使用 CLI
蓝牙设置进行连接</h2>
<p>首先输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bluetoothctl</span><br></pre></td></tr></table></figure>
<p>打开 CLI 蓝牙设置.</p>
<p>再依次输入以下命令:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scan on</span><br><span class="line">trust &lt;MAC&gt;</span><br><span class="line">pair &lt;MAC&gt;</span><br><span class="line">connect &lt;MAC&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;MAC&gt;</code> 是在输入 <code>scan on</code>
后查找到的形如 <code>XX:XX:XX:XX:XX:XX</code> 的耳机的 MAC 地址.</p>
<p>然后就可以正常连接了. 耳机也成为了配对成功的绿色.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分（一）总结 PART III</title>
    <url>/posts/dce146d0/</url>
    <content><![CDATA[<p>本文简要梳理了微积分（一）的一些内容, 并记录一些套路.</p>
<span id="more"></span>
<h1 id="一元函数的积分学">一元函数的积分学</h1>
<h2 id="定积分的定义">定积分的定义</h2>
<p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上有定义, 在 <span
class="math inline">\([a, b]\)</span> 间插入分点</p>
<p><span class="math display">\[
    a=x_0&lt;x_1&lt;\cdots&lt;x_{i-1}&lt;x_i&lt;\cdots
&lt;x_{n-1}&lt;x_n=b.
\]</span></p>
<p>称 <span class="math inline">\(\pi=\lbrace x_0, x_1, \cdots,
x_n\rbrace\)</span> 为 <span class="math inline">\([a, b]\)</span>
的一个分划. 记 <span class="math inline">\(\Delta x_i=x_i-x_{i-1}, 1\le
i\le n\)</span>, 记 <span class="math inline">\(\lambda=\max_{1\le i\le
n} \Delta x_i\)</span> 为分割 <span class="math inline">\(\pi\)</span>
的模, 任取 <span class="math inline">\(\xi_i\in [x_{i-1}, x_i]\)</span>,
称</p>
<p><span class="math display">\[
    \sigma=\sum_{i=1}^nf(\xi_i)\Delta x_i
\]</span></p>
<p>为 <span class="math inline">\(f\)</span> 在分割 <span
class="math inline">\(\pi\)</span> 下的黎曼和.</p>
<p>若</p>
<p><span class="math display">\[
    I=\lim_{\lambda\to 0}\sum_{i=1}^nf(\xi_i)\Delta x_i
\]</span></p>
<p>存在, 则称 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上黎曼可积, <span
class="math inline">\(I\)</span> 为 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上的定积分, 记作</p>
<p><span class="math display">\[
    \int_a^bf(x)\mathrm dx=I.
\]</span></p>
<p>若 <span class="math inline">\(a\ge b\)</span>, 规定</p>
<p><span class="math display">\[
    \int_a^bf(x)\mathrm dx=-\int_b^af(x)\mathrm dx.
\]</span></p>
<p>用极限的语言, 上述定义可写为:</p>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta &gt;0\)</span>, 使得对任意的分割
<span class="math inline">\(\pi\)</span>, 对任意选取的分点 <span
class="math inline">\(\xi_i\in[x_{i-1}, x_i]\)</span>, 只要 <span
class="math inline">\(\lambda(\pi)&lt;\delta\)</span>, 都有 <span
class="math display">\[
    |\sigma(D)-I|&lt;\varepsilon.
\]</span></p>
<p>则</p>
<p><span class="math display">\[
\int_a^bf(x)\mathrm dx=I.
\]</span></p>
<h2 id="定积分的存在性">定积分的存在性</h2>
<p><strong>可积的必要条件</strong> 若 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上可积, 则 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上有界.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>用反证法: 若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 无界, <span
class="math inline">\(\forall M&gt;0\)</span>, 适当选取分割 <span
class="math inline">\(\pi\)</span> 和分点 <span
class="math inline">\(\xi_i, 1\le i\le n\)</span>, 并且 <span
class="math inline">\(\xi_k\)</span> 满足 <span class="math display">\[
|f(\xi_k)|\ge \dfrac{1}{\Delta x_k}\left[M+\sum_{i=1, i\ne
k}^nf(\xi_i)\Delta x_i\right].
\]</span> 故 <span class="math display">\[
\begin{aligned}
|\sigma (\pi)|&amp;=\left|\sum_{i=1}^nf(\xi_i)\Delta x_i\right|
\\
&amp;\ge |f(\xi_k)\Delta x_k|-\left|\sum_{i=1, i\ne k}^nf(\xi_i)\Delta
x_i\right|
\\
&amp;\ge M.
\end{aligned}
\]</span> 故由 <span class="math inline">\(G\)</span> 的任意性可知,
<span class="math inline">\(\sigma (\pi)\)</span> 无极限, 故不可积.</p>
</blockquote>
</details>
<p><strong>达布和的定义</strong> 对一个分割 <span
class="math inline">\(\pi=\lbrace x_0, x_1,\cdots, x_n\rbrace\)</span>,
设 <span class="math inline">\(m_i\)</span> 是 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([x_{i-1}, x_i]\)</span> 的下确界, <span
class="math inline">\(M_i\)</span> 是 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([x_{i-1}, x_i]\)</span> 的上确界, 称 <span
class="math inline">\(w_i=M_i-m_i\)</span> 为 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([x_{i-1}, x_i]\)</span> 上的振幅. 称</p>
<p><span class="math display">\[
    s=\sum_{i=1}^nm_i\Delta x_i\ \textnormal{与}\
S=\sum_{i=1}^nM_i\Delta x_i
\]</span></p>
<p>分别为达布下和与达布上和. 容易发现对任意分点得到的 <span
class="math inline">\(\sigma\)</span>, 都有 <span
class="math inline">\(s\le \sigma\le S\)</span>.</p>
<p><strong>达布和的性质</strong></p>
<ul>
<li><strong>性质 1</strong> 对于一个确定的分割, 有 <span
class="math display">\[
  \begin{aligned}
  S&amp;=\sup\left\lbrace\sum_{i=1}^nf(\xi_i)\Delta x_i:
\xi_i\in[x_{i-1}, x_i], 1\le i\le n\right\rbrace,
  \\
  s&amp;=\inf\left\lbrace\sum_{i=1}^nf(\xi_i)\Delta x_i:
\xi_i\in[x_{i-1}, x_i], 1\le i\le n\right\rbrace.
  \end{aligned}
\]</span></li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>由于 <span class="math inline">\(\forall \sigma, \sigma \le
S\)</span>, 故 <span class="math inline">\(S\)</span> 为上界.</p>
<p>由于 <span class="math inline">\(M_i\)</span> 为 <span
class="math inline">\(f(\xi_i), \xi_i\in[x_{i-1}, x_i]\)</span>
的上确界, 故 <span class="math inline">\(\forall
\varepsilon&gt;0\)</span>, <span class="math inline">\(\exists
\xi_i\in[x_{i-1}, x_i]\)</span>, 满足 <span
class="math inline">\(f(\xi_i)&gt;
M_i-\dfrac{\varepsilon}{b-a}\)</span>, 故 <span class="math display">\[
\sum_{i=1}^nf(\xi_i)\Delta x_i&gt; \sum_{i=1}^nM_i\Delta
x_i-\varepsilon.
\]</span> 即存在 <span class="math inline">\(\sigma_0\)</span> 使得
<span class="math inline">\(\sigma_0&gt; S-\varepsilon\)</span>.</p>
<p>故 <span class="math inline">\(S\)</span> 为上确界, 同理 <span
class="math inline">\(s\)</span> 为下确界.</p>
</blockquote>
</details>
<ul>
<li><strong>性质 2</strong> 对一个给定的分割, 增加新的分点, 则下和不减,
上和不增.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>只需对增加一个分点的情况证明, 设增加的分点为 <span
class="math inline">\(\bar x\)</span>, 且 <span
class="math inline">\(x_0&lt;x_1&lt;\cdots&lt;x_{k-1}&lt;\bar
x&lt;x_k&lt;\cdots&lt;x_n\)</span>. 则原上和 <span
class="math display">\[
S=\sum_{i=1, i\ne k}^nM_i\Delta x_i+M_k\Delta x_k.
\]</span> 新的上和 <span class="math display">\[
S&#39;=\sum_{i=1, i\ne k}^nM_i\Delta x_i+M&#39;_k(\bar
x-x_{k-1})+M&#39;&#39;_k(x_k-\bar x).
\]</span> 由于 <span class="math inline">\(M&#39;_k\le M_k\)</span>,
<span class="math inline">\(M&#39;&#39;_k\le  M_k\)</span>, 有 <span
class="math inline">\(S&#39;\le S\)</span>. 同理，<span
class="math inline">\(s&#39;\ge s\)</span>.</p>
</blockquote>
</details>
<ul>
<li><strong>性质 3</strong> 对<strong>任意</strong>两个分割 <span
class="math inline">\(\pi_1, \pi_2\)</span>, 有 <span
class="math inline">\(s(\pi_1)\le S(\pi_2)\)</span>.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>若 <span class="math inline">\(\pi_1, \pi_2\)</span> 相同, 显然.
否则, 设 <span class="math inline">\(\pi\)</span> 为合并了 <span
class="math inline">\(\pi_1, \pi_2\)</span> 的分点的分割.</p>
<p>那么, <span class="math inline">\(\pi\)</span> 可以视为 <span
class="math inline">\(\pi_1\)</span> 或 <span
class="math inline">\(\pi_2\)</span> 增加分点得到.有性质 <span
class="math inline">\(2\)</span> 可知, <span
class="math inline">\(s(\pi_1)\le s(\pi)\le S(\pi)\le S(\pi_2)\)</span>,
得证.</p>
</blockquote>
</details>
<ul>
<li><strong>性质 4</strong> 对一切分割 <span
class="math inline">\(\pi\)</span>, <span class="math inline">\(\lbrace
s\rbrace\)</span> 有上界 <span class="math inline">\(I_*\)</span>, <span
class="math inline">\(\lbrace S\rbrace\)</span> 有下界 <span
class="math inline">\(I^*\)</span>, 且 <span
class="math inline">\(s(\pi_1)\le I_*\le I^*\le S(\pi_2)\)</span>. <span
class="math inline">\(I_*\)</span> 和 <span
class="math inline">\(I^*\)</span> 分别称为 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上的下积分和上积分.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>根据 性质 3, 任意 <span class="math inline">\(S\)</span> 都是 <span
class="math inline">\(\lbrace s\rbrace\)</span> 的上界, 故有上确界 <span
class="math inline">\(I_*\)</span>. 故 <span
class="math inline">\(\forall s\)</span>, <span
class="math inline">\(s\le I_*\)</span>. 同理, <span
class="math inline">\(\lbrace S\rbrace\)</span> 有下确界 <span
class="math inline">\(I^*\)</span>, 且 <span
class="math inline">\(\forall S\)</span>, <span
class="math inline">\(I^*\le S\)</span>. 由于 <span
class="math inline">\(\forall S\)</span>, <span
class="math inline">\(S\)</span> 是 <span class="math inline">\(\lbrace
s\rbrace\)</span> 的上界, 故 <span class="math inline">\(I_*\le
S\)</span>, 故 <span class="math inline">\(I_*\)</span> 是 <span
class="math inline">\(\lbrace S\rbrace\)</span> 的一个下界, 故 <span
class="math inline">\(I_*\le I^*\)</span>, 综合可得 <span
class="math inline">\(\forall s, S\)</span>, <span
class="math inline">\(s\le I_*\le I^*\le S\)</span>.</p>
</blockquote>
</details>
<p><strong>可积的充要条件</strong> <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,
b]\)</span> 可积的充分必要条件是 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,
b]\)</span> 有界且 <span class="math display">\[
    \lim_{\lambda\to 0}(S-s)=0.
\]</span> 或者后一条件也可以写为 <span class="math display">\[
    \lim_{\lambda\to 0}\sum_{i=1}^n\omega_i\Delta x_i=0.
\]</span></p>
<blockquote>
<p>用 <span class="math inline">\(\varepsilon-\delta\)</span> 语言写为:
<span class="math inline">\(\forall \epsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta&gt;0\)</span>, 对任意模 <span
class="math inline">\(\lambda&lt;\delta\)</span> 的分割, 均有 <span
class="math display">\[
\sum_{i=1}^n\omega_i\Delta x_i&lt;\varepsilon.
\]</span></p>
</blockquote>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p><strong>必要性</strong> 由 <span class="math inline">\(f(x)\)</span>
可积知 <span class="math inline">\(f(x)\)</span> 有界, 且 <span
class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta &gt;0\)</span>, 对任意分割 <span
class="math inline">\(\pi\)</span> 满足 <span
class="math inline">\(\lambda(\pi)&lt;\delta\)</span> 时, 有 <span
class="math inline">\(|\sigma-I|&lt;\varepsilon\)</span>, 即 <span
class="math inline">\(I-\varepsilon&lt;\sigma&lt;I+\varepsilon\)</span>.</p>
<p>又 <span class="math inline">\(s=\inf\lbrace \sigma\rbrace\)</span>,
<span class="math inline">\(S=\sup\lbrace \sigma\rbrace\)</span>, 有
<span class="math inline">\(I-\varepsilon\le s\le S\le
I+\varepsilon\)</span>,</p>
<p>故 <span class="math inline">\(\lim_{\lambda\to 0}S=\lim_{\lambda\to
0}s=0\)</span>, 从而 <span class="math display">\[
\lim_{\lambda\to 0}(S-s)=0.
\]</span> <strong>充分性</strong> 由上知 <span
class="math inline">\(s\le I_*\le I^*\le S\)</span>, 故 <span
class="math inline">\(0\le I^*-I_*\le S-s\)</span>.</p>
<p>由 <span class="math inline">\(\lim_{\lambda\to 0}(S-s)=0\)</span>,
得 <span class="math inline">\(I^*=I_*\)</span>(设为 <span
class="math inline">\(I\)</span>).</p>
<p>由于 <span class="math inline">\(s\le I\le S\)</span> 且 <span
class="math inline">\(s\le \sigma\le S\)</span>, 有 <span
class="math inline">\(|\sigma-I|\le S-s&lt;\varepsilon\)</span>.</p>
<p>故可积, 且积分为 <span class="math inline">\(I\)</span>.</p>
</blockquote>
</details>
<h2 id="常见的可积函数">常见的可积函数</h2>
<ul>
<li>在 <span class="math inline">\([a, b]\)</span>
上的连续函数可积.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>

</blockquote>
<blockquote>
<p>由于 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 连续, 故在 <span
class="math inline">\([a, b]\)</span> 有界且一致连续.</p>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta&gt;0\)</span>, 对 <span
class="math inline">\(\lambda&lt;\delta\)</span> 的任意分割, 在任意
<span class="math inline">\([x_{i-1}, x_i]\)</span> 中的任意两点 <span
class="math inline">\(x_1, x_2\)</span> 均满足 <span
class="math inline">\(|x_1-x_2|\le \lambda&lt;\delta\)</span>. 所以,
由一致连续性, 有 <span
class="math inline">\(|f(x_1)-f(x_2)|&lt;\dfrac{\varepsilon}{2(b-a)}\)</span>.</p>
<p>则 <span
class="math inline">\(\omega_i=\sup\lbrace|f(x&#39;)-f(x&#39;&#39;):
x&#39;,x&#39;&#39;\in[x_{i-1}, x_i]\rbrace\le
\dfrac{\varepsilon}{2(b-a)}&lt;\dfrac{\varepsilon}{b-a}\)</span>.</p>
<p>故 <span class="math display">\[
\sum_{i=1}^n\omega_i\Delta
x_i&lt;\dfrac{\varepsilon}{b-a}=\sum_{i=1}^n\Delta x_i=\varepsilon.
\]</span> 故 <span class="math inline">\(\lim_{\lambda\to
0}\sum_{i=1}^n\omega_i\Delta x_i=0\)</span>, <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 可积.</p>
</blockquote>
</details>
<ul>
<li>在 <span class="math inline">\([a, b]\)</span>
上只有有限个间断点的有界函数是可积的.</li>
</ul>
<blockquote>
<p>若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span>
上除有限个第一类间断点外都是连续的, 则称 <span
class="math inline">\(f\)</span> 为<strong>分段连续函数</strong>.
此定理的一个更弱的形式为, 分段连续函数是可积的.</p>
</blockquote>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上的振幅为 <span
class="math inline">\(\Omega\)</span>, 共有 <span
class="math inline">\(k\)</span> 个间断点.</p>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta &gt;0\)</span>, 对任意模 <span
class="math inline">\(\lambda&lt;\min\left\lbrace\dfrac{s}{4k\Omega},
\delta\right\rbrace\)</span> 的分割来说, 把 <span
class="math inline">\(\sum_{i=1}^n\omega_i\Delta x_i\)</span> 分为两部分
<span class="math display">\[
\sum_{i=1}^n\omega_i\Delta x_i=\sum_{i\in T}\omega_i\Delta
x_i+\sum_{i\notin T}\omega_i\Delta x_i,
\]</span> 其中 <span class="math inline">\(T\)</span>
是所有包含了间断点的指标集.</p>
<p>对于前者: 由于 <span class="math inline">\(|T|\le 2k\)</span>, 故
<span class="math display">\[
\sum_{i\in T}\omega_i\Delta x_i\le \Omega\cdot 2k \cdot
\lambda&lt;\dfrac{\varepsilon}{2}.
\]</span> 对于后者, 是若干个闭区间上连续函数的黎曼和的和,
由之前的证明可知, <span class="math display">\[
\sum_{i\notin T}\omega_i\Delta x_i\le \dfrac{\varepsilon}{2}.
\]</span> 综合可知, <span class="math display">\[
\sum_{i=1}^n\omega_i\Delta x_i&lt;\varepsilon.
\]</span> 故 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积.</p>
</blockquote>
</details>
<ul>
<li>在 <span class="math inline">\([a, b]\)</span>
上单调有界的函数可积.</li>
</ul>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>不妨设 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 单调递增. 在区间 <span
class="math inline">\([x_{i-1}, x_i]\)</span> 有 <span
class="math inline">\(\omega_i=f(x_i)-f(x_{i-1})\)</span>.</p>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>, 取
<span
class="math inline">\(\delta=\dfrac{\varepsilon}{f(b)-f(a)}\)</span>,
对于模 <span class="math inline">\(\lambda&lt;\delta\)</span>
的分割来说, 有 <span class="math display">\[
\sum_{i=1}^n\omega_i\Delta x_i&lt;\delta \sum_{i=1}^nw_i=\varepsilon.
\]</span> 故 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积.</p>
</blockquote>
</details>
<h2 id="定积分的性质">定积分的性质</h2>
<ol type="1">
<li>线性性</li>
</ol>
<p><span class="math display">\[
    \int_a^b (pf(x)+qg(x))\mathrm dx=p\int_a^bf(x)\mathrm
dx+q\int_a^bg(x)\mathrm dx.
\]</span></p>
<ol start="2" type="1">
<li>区间可加性, 在三个积分均可积的前提下, 有</li>
</ol>
<p><span class="math display">\[
    \int_a^b f(x)\mathrm dx=\int_a^c f(x)\mathrm dx+\int_c^b f(x)\mathrm
dx.
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>先证明 <span class="math inline">\(a&lt; c &lt; b\)</span> 的情况. 在
<span class="math inline">\([a, b]\)</span>
可积的前提下证明子区间可积(用振幅), 再以 <span
class="math inline">\(c\)</span> 为分点, 取极限.</p>
<p>然后其它情况可以取不同的点作为分点得证.</p>
</blockquote>
</details>
<ol start="3" type="1">
<li><p>设 <span class="math inline">\(f, g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积, 且 <span
class="math inline">\(f(x)\ge g(x)\)</span>, 则 <span
class="math display">\[
\int_a^b f(x)\mathrm dx\ge \int_a^bg(x)\mathrm dx.
\]</span></p></li>
<li><p>若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上<strong>连续</strong>, 且 <span
class="math inline">\(f(x)\ge 0, f(x)\not\equiv 0\)</span>, 则 <span
class="math display">\[
\int_a^b f(x)\mathrm dx&gt;0.
\]</span></p></li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>对性质 3, 由极限的性质易得.</p>
<p>对性质 4, 不妨设有一点 <span class="math inline">\(x_0\)</span> 满足
<span class="math inline">\(f(x_0)\ge 0\)</span>, 则由于连续性, 存在
<span class="math inline">\(U(x_0, \delta)\)</span> 邻域(不妨设 <span
class="math inline">\(x_0\)</span> 是内点), 对邻域内的 <span
class="math inline">\(x\)</span> 有 <span class="math inline">\(f(x)\ge
\dfrac{f(x_0)}{2}\)</span>. 那么 <span class="math display">\[
\begin{aligned}
\int_a^bf(x)\mathrm dx&amp;=\int_a^{x-\delta/2}f(x)\mathrm
dx+\int_{x-\delta/2}^{x+\delta/2}f(x)\mathrm
dx+\int_{x+\delta/2}^bf(x)\mathrm dx
\\
&amp;\ge 0+\int_{x-\delta/2}^{x+\delta/2}\dfrac{f(x_0)}{2}\mathrm dx+0
\\
&amp;=\dfrac{\delta f(x_0)}{2}&gt;0.
\end{aligned}
\]</span> 若 <span class="math inline">\(x\)</span> 是端点,
类似可得.</p>
</blockquote>
</details>
<ol start="5" type="1">
<li>若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积, 则 <span
class="math inline">\(|f|\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上也可积, 且 <span class="math display">\[
\left|\int_a^bf(x)\mathrm dx\right|\le \int_a^b|f(x)|\mathrm dx.
\]</span></li>
</ol>
<blockquote>
<p>若 <span class="math inline">\(|f|\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积, 则称 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上<strong>绝对可积</strong>, 反之不一定成立.</p>
</blockquote>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>可积性: 由三角不等式易得 <span class="math inline">\(\omega(|f|)\le
\omega(f)\)</span>, 故容易证得可积.</p>
<p>由 <span class="math inline">\(-|f(x)|\le f(x)\le |f(x)|\)</span>,
容易得到 <span class="math inline">\(-\int |f(x)|\le \int f(x)\le \int
|f(x)|\)</span>, 从而 <span class="math inline">\(|\int f(x)|\le \int
|f(x)|\)</span>.</p>
</blockquote>
</details>
<ol start="6" type="1">
<li>若 <span class="math inline">\(f, g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积, 则 <span
class="math inline">\(f\cdot g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上也可积, 但一般地,
积的定积分不等于定积分的积.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<p><img src="fg_canint.png" /></p>
</details>
<ol start="7" type="1">
<li><p>(积分第一中值定理) 若 <span class="math inline">\(f, g\)</span>
在 <span class="math inline">\([a, b]\)</span> 上可积, <span
class="math inline">\(g\)</span> 可积且在 <span
class="math inline">\([a, b]\)</span> 上定号, <span
class="math inline">\(f\)</span> 的一个上下界分别为 <span
class="math inline">\(M\)</span> 和 <span
class="math inline">\(m\)</span>, 那么</p>
<ul>
<li>存在 <span class="math inline">\(\mu\in [m, M]\)</span> 使得 <span
class="math display">\[
\int_a^bf(x)g(x)\mathrm dx=\mu\int_a^bg(x)\mathrm dx.
\]</span> 特别地, 若 <span class="math inline">\(g(x)\equiv 1\)</span>,
则 <span class="math display">\[
\int_a^bf(x)\mathrm dx=\mu(b-a).
\]</span></li>
<li>若进一步地, <span class="math inline">\(f, g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上连续, 那么存在 <span
class="math inline">\(\xi\in(a, b)\)</span> 使得 <span
class="math display">\[
\int_a^b f(x)g(x)\mathrm dx=f(\xi)\int_a^bg(x)\mathrm dx.
\]</span> 特别地, 若 <span class="math inline">\(g(x)\equiv 1\)</span>,
则 <span class="math display">\[
\int_a^b f(x) \mathrm dx=f(\xi)(b-a).
\]</span></li>
</ul></li>
</ol>
<blockquote>
<p>书上的证明是证明了若 <span class="math inline">\(f\)</span> 连续则
<span class="math inline">\(\xi\)</span> 可以取到闭区间. 若 <span
class="math inline">\(f, g\)</span> 均连续, 那么 <span
class="math inline">\(\xi\)</span> 在开区间内也可以做到! 其实若 <span
class="math inline">\(f\)</span> 连续, <span
class="math inline">\(\int_a^b g(x)\mathrm dx\ne 0\)</span>, 也可以推出
<span class="math inline">\(\xi\)</span> 在开区间内可以取到.</p>
</blockquote>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>对于第一部分: 不妨设 <span class="math inline">\(g(x)\ge 0\)</span>,
那么 <span class="math display">\[
\int_a^bg(x)\ge 0.
\]</span> 由于 <span class="math inline">\(m\le f(x)\le M\)</span>, 有
<span class="math inline">\(mg(x)\le f(x)g(x)\le Mg(x)\)</span>. 故
<span class="math display">\[
m\int_a^bg(x)\mathrm dx\le \int_a^bf(x)g(x)\mathrm dx\le
M\int_a^bg(x)\mathrm dx.
\]</span> 于是存在 <span class="math inline">\(\mu\in [m, M]\)</span>
使得 <span class="math display">\[
\int_a^bf(x)g(x)\mathrm dx=\mu\int_a^b g(x)\mathrm dx.
\]</span> 对于第二部分: 有三种情况.</p>
<ol type="1">
<li><p>若想证 <span class="math inline">\(\xi\)</span> 取闭区间上的情况,
利用介值定理即可.</p></li>
<li><p>若想证 <span class="math inline">\(\xi\)</span> 取开区间上, 在
<span class="math inline">\(f, g\)</span> 连续的条件下, 那么先讨论 <span
class="math inline">\(m\)</span> 和 <span
class="math inline">\(M\)</span> 的关系, 再利用上面的性质 4 即证,
或者你可以用微分中值定理.</p></li>
<li><p>若想证 <span class="math inline">\(\xi\)</span> 取开区间上, 在
<span class="math inline">\(g\)</span> 可积且 <span
class="math inline">\(\int_a^bg(x)\mathrm dx\ne 0\)</span> 的条件下,
那么你可以看<a
href="https://www.zhihu.com/question/53396732/answer/153621393">这个回答</a>.</p></li>
</ol>
</blockquote>
</details>
<ol start="8" type="1">
<li>施瓦兹不等式: 若 <span class="math inline">\(f, g\)</span> 在 <span
class="math inline">\([a, b]\)</span> 上可积, 则</li>
</ol>
<p><span class="math display">\[
    \left(\int_a^b f(x)g(x)\mathrm dx\right)^2\le \int_a^b f^2(x)\mathrm
dx\cdot \int_a^bg^2(x)\mathrm dx.
\]</span></p>
<h2 id="原函数变上限积分与不定积分">原函数、变上限积分与不定积分</h2>
<p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上有定义. 如果在 <span
class="math inline">\(I\)</span> 上存在 <span
class="math inline">\(F\)</span> 使得</p>
<p><span class="math display">\[
    F&#39;(x)=f(x), \forall x\in I\ \textnormal{或}\ \mathrm
dF(x)=f(x)\mathrm dx,
\]</span></p>
<p>则称 <span class="math inline">\(F\)</span> 是 <span
class="math inline">\(f\)</span> 在区间 <span
class="math inline">\(I\)</span> 上的一个原函数.</p>
<p><strong>变上限积分</strong> 设 <span class="math inline">\(f\)</span>
在 <span class="math inline">\(I\)</span> 上可积, <span
class="math inline">\(a\in I\)</span>, 则定义</p>
<p><span class="math display">\[
    \varPhi(x)=\int_a^x f(t)\mathrm dt
\]</span></p>
<p>是 <span class="math inline">\(I\)</span> 上的一个关于 <span
class="math inline">\(x\)</span> 的函数, 称为变上限积分.</p>
<p><strong>变上限积分的连续性</strong> 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上可积, 则 <span
class="math inline">\(\varPhi\)</span> 在 <span
class="math inline">\(I\)</span> 上连续.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>由于 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上可积, 则 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上有界, 设界为 <span
class="math inline">\(M\)</span>.</p>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>, 取
<span class="math inline">\(\delta=\dfrac{\varepsilon}{M}\)</span>, 则当
<span class="math inline">\(|\Delta x|&lt; \delta\)</span> 时, 有 <span
class="math display">\[
\begin{aligned}
|\varPhi(x+\Delta x)-\varPhi(x)|&amp;=\left|\int_a^{x+\Delta
x}f(t)\mathrm dt - \int_a^x f(t)\mathrm dt\right|
\\
&amp;=\left|\int_x^{x+\Delta x}f(t)\mathrm dt\right|
\\
&amp;=|\mu|\cdot \Delta x\ (|\mu|\le M)
\\
&amp;\le \varepsilon.
\end{aligned}
\]</span> 故 <span class="math inline">\(\varPhi\)</span> 在 <span
class="math inline">\(I\)</span> 上连续.</p>
</blockquote>
</details>
<p><strong>变上限积分可导的充分条件</strong> 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上连续, 则 <span
class="math inline">\(\varPhi\)</span> 在 <span
class="math inline">\(I\)</span> 上可导, 且 <span
class="math inline">\(\varPhi&#39;(x)=f(x)\)</span>.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>由于 <span class="math display">\[
\begin{aligned}
\dfrac{\varPhi(x+\Delta x)-\varPhi(x)}{\Delta
x}&amp;=\dfrac{\int_x^{x+\Delta x}f(t)\mathrm dt}{\Delta x}
\\
&amp;=\dfrac{f(\xi)\Delta x}{\Delta x}
\\
&amp;=f(\xi),
\end{aligned}
\]</span> 其中 <span class="math inline">\(\xi\)</span> 位于 <span
class="math inline">\(x\)</span> 和 <span class="math inline">\(x+\Delta
x\)</span> 之间. 当 <span class="math inline">\(\Delta x\to 0\)</span>
时, 有 <span class="math inline">\(\xi\to x\)</span>.</p>
<p>故 <span class="math display">\[
\varPhi&#39;(x)=\lim_{\Delta x\to 0}\dfrac{\varPhi(x+\Delta
x)-\varPhi(x)}{\Delta x}=\lim_{\xi\to x}f(\xi)=f(x).
\]</span></p>
</blockquote>
</details>
<p><strong>变上限积分在一点处可导的充分条件</strong> 若 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上可积, 在 <span
class="math inline">\(x_0\in I\)</span> 上连续, 则 <span
class="math inline">\(\varPhi\)</span> 在 <span
class="math inline">\(x_0\)</span> 处可导, 且 <span
class="math inline">\(\varPhi&#39;(x_0)=f(x_0)\)</span>.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>, <span
class="math inline">\(\exists \delta &gt;0\)</span>, 当 <span
class="math inline">\(|x-x_0|&lt;\delta\)</span> 时, 有 <span
class="math inline">\(|f(x)-f(x_0)|&lt;\varepsilon\)</span>.</p>
<p>从而 <span class="math display">\[
\begin{aligned}
\left|\dfrac{\varPhi(x_0+\Delta x)-\varPhi(x_0)}{\Delta
x}-f(x_0)\right|&amp;=\left|\dfrac{\int_{x_0}^{x_0+\Delta x}f(t)\mathrm
dt-f(x_0)\Delta x}{\Delta x}\right|
\\
&amp;=\left|\dfrac{\int_{x_0}^{x_0+\Delta x}(f(t)-f(x_0))\mathrm
dt}{\Delta x}\right|
\\
&amp;\le \dfrac{\int_{x_0}^{x_0+\Delta x}|f(t)-f(x_0)|\mathrm dt}{\Delta
x}
\\
&amp;&lt; \dfrac{\int_{x_0}^{x_0+\Delta x}\varepsilon\mathrm dt}{\Delta
x}=\varepsilon
\end{aligned}
\]</span> 故 <span
class="math inline">\(\varPhi&#39;(x_0)=f(x_0)\)</span>.</p>
</blockquote>
</details>
<p><strong>连续函数的变上限积分是一个原函数</strong> 即若 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(I\)</span> 上连续, 则其变上限积分 <span
class="math inline">\(\varPhi(x)=\int_a^xf(t)\mathrm dt\)</span> 满足
<span class="math display">\[
    \varPhi&#39;(x)=f(x),
\]</span> 故<strong>任意连续函数都有原函数</strong>.</p>
<blockquote>
<p>然而, 可积与存在原函数之间没有任何关联. 可积可能不存在原函数,
存在原函数也不一定可积.</p>
<p>例如, 根据达布定理, 若 <span class="math inline">\(f(x)\)</span>
在区间内有定义且存在第一类间断点, 则其不存在原函数,
但它可以是可积的.</p>
<p>而存在原函数的函数不可积, 可见<a
href="https://www.zhihu.com/question/364504118/answer/961662594">此回答</a>.</p>
</blockquote>
<p><strong>不定积分/全部原函数</strong> 若 <span
class="math inline">\(F(x)\)</span> 是 <span
class="math inline">\(f(x)\)</span> 的一个原函数, 则 <span
class="math inline">\(f(x)\)</span> 的全部原函数可表示为 <span
class="math inline">\(F(x)+C\)</span>, <span
class="math inline">\(C\)</span> 为任意常数, 称为 <span
class="math inline">\(f(x)\)</span> 的不定积分, 记为</p>
<p><span class="math display">\[
    \int f(x)\mathrm dx=F(x)+C.
\]</span></p>
<p><span class="math inline">\(f(x)\)</span>
的不定积分是一族互相只差常数的关于 <span
class="math inline">\(x\)</span> 的函数.</p>
<p>有性质如下:</p>
<p><span class="math display">\[
    \begin{aligned}
        \left(\int f(x)\mathrm dx\right)&#39;&amp;=f(x), &amp;\mathrm
d\int f(x)\mathrm dx&amp;=f(x)\mathrm dx,
        \\
        \int F&#39;(x)\mathrm dx&amp;=F(x)+C, &amp;\int \mathrm
dF(x)&amp;=F(x)+C.
    \end{aligned}
\]</span></p>
<h2 id="牛顿-莱布尼兹公式">牛顿-莱布尼兹公式</h2>
<p>设 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上连续, <span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(f\)</span> 的一个原函数, 若 <span
class="math inline">\(a, b\in I\)</span>, 则</p>
<p><span class="math display">\[
    \int_a^b f(x)\mathrm dx=F(b)-F(a)=F(x)\bigg |_a^b.
\]</span></p>
<p>其实, 把条件弱化为 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上可积亦成立.</p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p><strong>若条件为连续</strong> 可知变上限积分 <span
class="math display">\[
\varPhi(x)=\int_a^xf(t)\mathrm dt
\]</span> 是 <span class="math inline">\(f\)</span> 的一个原函数, 那么
<span class="math inline">\(\varPhi(x)=F(x)+C\)</span>. 分别代入 <span
class="math inline">\(x=a\)</span> 和 <span
class="math inline">\(x=b\)</span>, 有 <span class="math display">\[
\begin{aligned}
0&amp;=F(a)+C
\\
\int_a^bf(t)\mathrm dt&amp;=F(b)+C
\end{aligned}
\]</span> 故 <span class="math display">\[
\int_a^bf(x)\mathrm dx=F(b)-F(a).
\]</span> <strong>若条件为可积</strong> 不妨设 <span
class="math inline">\(a&lt; b\)</span>. 作 <span
class="math inline">\([a, b]\)</span> 的分割为 <span
class="math inline">\(a=x_0&lt;x_1&lt;\cdots&lt;x_{i-1}&lt;x_i&lt;\cdots&lt;x_n&lt;b\)</span>,
那么 <span class="math display">\[
F(b)-F(a)=\sum_{i=1}^n(F(x_i)-F(x_{i-1}))=\sum_{i=1}^nf(\xi_i)\Delta
x_i.
\]</span> 其中 <span class="math inline">\(\xi_i\in (x_{i-1},
x_i)\)</span>. 取极限得 <span class="math display">\[
\int_a^bf(x)\mathrm dx=F(b)-F(a).
\]</span></p>
</blockquote>
</details>
<p>从而定积分的计算可以转化为不定积分的计算.</p>
<h2 id="换元积分法">换元积分法</h2>
<p>设 <span class="math inline">\(f\)</span> 在区间 <span
class="math inline">\(I\)</span> 上连续, <span
class="math inline">\(x=\varphi(t)\)</span> 在区间 <span
class="math inline">\(J\)</span> 上有连续导数, 且 <span
class="math inline">\(\varphi(J)\subseteq I\)</span>, 则有 <span
class="math display">\[
    \int f(x)\mathrm dx=\int f(\varphi(t))\mathrm d\varphi(t)=\int
f(\varphi(t))\varphi&#39;(t)\mathrm dt
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>设 <span class="math inline">\(F\)</span> 是 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上的一个原函数, 那么求导得 <span
class="math display">\[
\dfrac{\mathrm d}{\mathrm dt}
F(\varphi(t))=f(\varphi(t))\varphi&#39;(t).
\]</span></p>
<p>故 <span class="math inline">\(F\circ \varphi\)</span> 是 <span
class="math inline">\((f\circ \varphi)\varphi&#39;\)</span> 在 <span
class="math inline">\(J\)</span> 上的一个原函数, 故 <span
class="math display">\[
\int f(\varphi(t))\varphi&#39;(t)=F(\varphi(t))+C=\int f(x)\mathrm dx.
\]</span></p>
</blockquote>
</details>
<p>由上述定理可以引申出:</p>
<p><strong>不定积分的凑微分法</strong> 使用条件: 没啥条件.</p>
<p><strong>不定积分的变量替代法</strong> 使用条件: 替代的 <span
class="math inline">\(x=\varphi(t)\)</span>
在区间上连续可导且存在反函数(代回), 故要求单调.</p>
<p><strong>定积分的的凑微分法</strong> 使用条件: 没啥条件.
但是要注意凑微分后的上下限保持不变(积分变量不变).</p>
<p><strong>定积分的变量替代法</strong> 使用条件: 替代的 <span
class="math inline">\(x=\varphi(t)\)</span> 在区间上连续可导,
不过因为不用代回, 所以不要求有反函数. 注意要改变上下限.</p>
<p><strong>一些常用结论</strong>:</p>
<ol type="1">
<li>对于周期函数 <span class="math inline">\(f(x)=f(x+T)\)</span>, 有
<span class="math display">\[
\int_a^{a+nT}f(x)\mathrm dx = n\int_b^{b+T}f(x)\mathrm dx.
\]</span></li>
<li>对于奇函数 <span class="math inline">\(f(x)=-f(-x)\)</span>, 有
<span class="math display">\[
\int_{-a}^af(x)\mathrm dx = 0.
\]</span> (注意需要是常义积分)</li>
<li>对于偶函数 <span class="math inline">\(f(x)=f(-x)\)</span>, 有 <span
class="math display">\[
\int_{-a}^af(x)\mathrm dx = 2\int_0^{a}f(x)\mathrm
dx=2\int_{-a}^0f(x)\mathrm dx.
\]</span></li>
</ol>
<h2 id="分部积分法">分部积分法</h2>
<p>设 <span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 在区间 <span
class="math inline">\(I\)</span> 内有连续导数, 则有</p>
<p><span class="math display">\[
    \int u(x)\mathrm dv(x)=u(x)v(x)-\int v(x)\mathrm du(x).
\]</span></p>
<p>或有定积分形式为:</p>
<p><span class="math display">\[
    \int_a^bu(x)\mathrm dv(x)=u(x)v(x)\bigg|_a^b-\int_a^b v(x)\mathrm
du(x).
\]</span></p>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>由乘积的求导公式可得.</p>
</blockquote>
</details>
<blockquote>
<p>常见的分部积分的技巧:</p>
<ol type="1">
<li>幂函数与 <span class="math inline">\(e^x, \sin x, \cos x\)</span>
等的乘积, 把后者放到 <span class="math inline">\(\mathrm d\)</span>
里面去.</li>
<li>幂函数与对数函数、反三角函数、反双曲函数的乘积， 把前者放到 <span
class="math inline">\(\mathrm d\)</span> 后面去.</li>
<li>分母有 <span class="math inline">\(f^2(x)\)</span> 的形式,
可以考虑把 <span class="math inline">\(1/f(x)\)</span> 放到 <span
class="math inline">\(\mathrm d\)</span> 后面去.</li>
</ol>
</blockquote>
<h2 id="基本积分表">基本积分表</h2>
<details>
<summary>
<b>展开</b>
</summary>
<p><img src="integ_table1.png" /></p>
<p><img src="integ_table2.png" /></p>
<p><img src="integ_table3.png" /></p>
<p><img src="integ_table4.png" /></p>
</details>
<h2
id="有理分式函数积分与有理三角函数的积分">有理分式函数积分与有理三角函数的积分</h2>
<p><strong>前置知识</strong> 一个积分的算法: 求 <span
class="math display">\[
    I_n=\int\dfrac{\mathrm dx}{(x^2+a^2)^n}.
\]</span></p>
<details>
<summary>
<b>求法</b>
</summary>
<blockquote>
<p>由于 <span class="math display">\[
\begin{aligned}
I_n&amp;=\int\dfrac{\mathrm dx}{(x^2+a^2)^n}
\\
&amp;=\dfrac{x}{(x^2+a^2)^n}+2n\int\dfrac{x^2\mathrm
dx}{(x^2+a^2)^{n+1}}.
\\
&amp;=\dfrac{x}{(x^2+a^2)^n}+2n(I_n-a^2I_{n+1}).
\end{aligned}
\]</span> 故 <span class="math display">\[
I_{n+1}=\dfrac{1}{2na^2}\left(\dfrac{x}{(x^2+a^2)^n}+(2n-1)I_n\right).
\]</span></p>
</blockquote>
</details>
<p><strong>有理函数积分的系统方法</strong></p>
<ol type="1">
<li>设对 <span class="math inline">\(f(x)=\dfrac{P(x)}{Q(x)}\)</span>
积分, 其中 <span class="math inline">\(P(x), Q(x)\)</span> 均是多项式.
无妨设 <span class="math inline">\(P(x)\)</span> 的次数小于 <span
class="math inline">\(Q(x)\)</span>
的次数(否则可以提出容易积分的多项式并变成真分式), 且 <span
class="math inline">\(Q(x)\)</span> 为首一多项式.</li>
<li>把 <span class="math inline">\(Q(x)\)</span> 在实数范围内分解, 变成
<span class="math display">\[
Q(x)=\prod_i\dfrac{1}{(x-x_i)^{\lambda_i}}\cdot
\prod_j\dfrac{1}{(x^2+p_jx+q_j)^{\mu_j}}.
\]</span> 其中第二项的所有的分母 <span
class="math inline">\(\Delta&lt;0\)</span>.</li>
<li>用待定系数法把 <span
class="math inline">\(\dfrac{P(x)}{Q(x)}\)</span> 拆成一系列和:
<ul>
<li>对于每一个 <span class="math inline">\(Q(x)\)</span> 的因式 <span
class="math inline">\(\dfrac{1}{(x-x_i)^{\lambda_i}}\)</span>,
相应地设出 <span class="math inline">\(\sum\limits_{1\le k\le
\lambda_i}\dfrac{A_k}{(x-x_i)^k}\)</span> 加入到和中.</li>
<li>对于每一个 <span class="math inline">\(Q(x)\)</span> 的因式 <span
class="math inline">\(\dfrac{1}{(x^2+p_jx+q_j)^{\mu_j}}\)</span>,
相应地设出 <span class="math inline">\(\sum\limits_{1\le k\le
\mu_j}\dfrac{B_kx+C_k}{(x^2+p_jx+q_j)^k}\)</span> 加入到和中.</li>
</ul></li>
<li>对每一项分别积分.
<ul>
<li>对于 <span class="math inline">\(\dfrac{A_k}{(x-x_i)^k}\)</span>,
积分显然.</li>
<li>对于 <span
class="math inline">\(\dfrac{B_kx+C_k}{(x^2+p_jx+q_j)^k}\)</span>, 若
<span class="math inline">\(B_k\ne 0\)</span>, 可以在分子上凑 <span
class="math inline">\(B_kx+C_k=\dfrac{B_k}{2}(2x+p_j)+X\)</span>,
拆成两部分, 前部分是 <span class="math inline">\(\dfrac{B_k}{2}\int
\dfrac{\mathrm d(x^2+p_jx+q_j)}{(x^2+p_jx+q_j)}\)</span> 的形式,
而后部分是 <span class="math inline">\(B_k=0\)</span> 的情形(见下).</li>
<li>对于 <span
class="math inline">\(\dfrac{C_k}{(x^2+p_jx+q_j)^k}\)</span>,
分母配方后套用"前置知识"里面的公式即可.</li>
</ul></li>
</ol>
<p><strong>有理三角函数积分</strong></p>
<p>对于有理三角函数的积分 <span class="math inline">\(\displaystyle\int
R(\sin x, \cos x)\mathrm dx\)</span>,
一种通用的方法是转换为有理函数的积分进行计算.</p>
<p>总结规律如下:</p>
<ol type="1">
<li>若 <span class="math inline">\(R(-\sin x, \cos x)=-R(\sin x, \cos
x)\)</span>, 则可令 <span class="math inline">\(t=\cos x\)</span>
进行积分.</li>
<li>若 <span class="math inline">\(R(\sin x, -\cos x)=-R(\sin x, \cos
x)\)</span>, 则可令 <span class="math inline">\(t=\sin x\)</span>
进行积分.</li>
<li>若 <span class="math inline">\(R(-\sin x, -\cos x)=R(\sin x, \cos
x)\)</span>, 则可令 <span class="math inline">\(t=\tan x\)</span>
进行积分.</li>
<li>不论如何, 令 <span class="math inline">\(t=\tan
\dfrac{x}{2}\)</span>, 用万能公式一定可以做.</li>
</ol>
<h2 id="无理函数积分">无理函数积分</h2>
<ol type="1">
<li>对于 <span class="math inline">\(f(x)=R(\sqrt[m]{ax+b},
\sqrt[n]{ax+b})\)</span> 的情况, 令 <span
class="math inline">\(t=\sqrt[\operatorname{lcm}(m, n)]{ax+b}\)</span>
即可.</li>
<li>对于 <span class="math inline">\(f(x)=R\left(x,
\sqrt[m]{\dfrac{ax+b}{cx+d}}\right)\)</span> 的情况, 令 <span
class="math inline">\(t=\sqrt[m]{\dfrac{ax+b}{cx+d}}\)</span> 即可.</li>
<li>对于 <span class="math inline">\(f(x)=R(x,
\sqrt{ax^2+bx+c})\)</span> 的情况, 用欧拉代换:
<ul>
<li>若 <span class="math inline">\(a&gt;0\)</span>, 可令 <span
class="math inline">\(\sqrt{ax^2+bx+c}=\sqrt a x+t\)</span>.</li>
<li>若 <span class="math inline">\(c&gt;0\)</span>, 可令 <span
class="math inline">\(\sqrt{ax^2+bx+c}=tx+\sqrt c\)</span>.</li>
<li>若 <span class="math inline">\(\Delta &gt;0\)</span>, 且 <span
class="math inline">\(ax^2+bx+c=a(x-x_1)(x-x_2)\)</span>, 可令 <span
class="math inline">\(\sqrt{ax^2+bx+c}=t(x-x_1)\)</span>.</li>
</ul></li>
</ol>
<h2 id="定积分的应用">定积分的应用</h2>
<p>常用推导方法: 微元法</p>
<p><strong>计算面积</strong></p>
<ol type="1">
<li><span class="math inline">\(\lbrace a\le x\le b, f(x)\le y\le
g(x)\rbrace\)</span>, <span class="math display">\[
S=\int_a^b (g(x)-f(x))\mathrm dx.
\]</span></li>
<li><span class="math inline">\(\lbrace a\le y\le b, \psi(y)\le x \le
\varphi(y)\rbrace\)</span>, <span class="math display">\[
S=\int_a^b (\varphi(y)-\psi(y))\mathrm dy.
\]</span></li>
<li><span class="math inline">\(\lbrace a\le \theta\le b,
\rho_1(\theta)\le \rho\le \rho_2(\theta)\rbrace\)</span>, <span
class="math display">\[
S=\dfrac{1}{2}\int_a^b(\rho_2^2(\theta)-\rho_1^2(\theta))\mathrm
d\theta.
\]</span></li>
<li><span class="math inline">\(\lbrace a\le \rho\le b,
\theta_1(\rho)\le \theta \le \theta_2(\rho)\rbrace\)</span>, <span
class="math display">\[
S=\int_a^b(\theta_2(\rho)-\theta_1(\rho))\rho\mathrm d\rho.
\]</span></li>
</ol>
<p><strong>计算体积</strong></p>
<p>平行截面的面积已知的立体的体积: 若 <span class="math inline">\(a\le
x\le b\)</span>, 在 <span class="math inline">\(x\)</span> 处截面面积为
<span class="math inline">\(A(x)\)</span>, 那么 <span
class="math display">\[
    V=\int_a^bA(x)\mathrm dx.
\]</span></p>
<p>旋转体的体积: 对于 <span class="math inline">\(f(x), 0&lt;a\le x\le
b\)</span>, 它绕 <span class="math inline">\(x\)</span>
轴的旋转体的体积为 <span class="math display">\[
    V_x=\pi \int_a^b f^2(x)\mathrm dx.
\]</span></p>
<p>它绕 <span class="math inline">\(y\)</span> 轴的旋转体的体积为 <span
class="math display">\[
    V_y=2\pi\int_a^bx|f(x)|\mathrm dx.
\]</span></p>
<p><strong>计算曲线的弧长</strong></p>
<p>对于参数方程 <span class="math inline">\(\begin{cases}x=x(t),
\\y=y(t).\end{cases}, a\le t\le b\)</span>, 它的弧长公式为 <span
class="math display">\[
    L=\int_a^b\sqrt{(x&#39;(t))^2+(y&#39;(t))^2}\mathrm dt.
\]</span> 由此可以推出, 对于 <span class="math inline">\(y=f(x), a\le
x\le b\)</span>, 其弧长公式为 <span class="math display">\[
    L=\int_a^b\sqrt{1+(f&#39;(x))^2}\mathrm dx.
\]</span> 对于 <span class="math inline">\(x=\varphi(y), a\le y\le
b\)</span>, 其弧长公式为 <span class="math display">\[
    L=\int_a^b\sqrt{(\varphi&#39;(y))^2+1}\mathrm dy.
\]</span> 对于 <span class="math inline">\(\rho=\rho(\theta), a\le
\theta\le b\)</span>, 弧长公式为 <span class="math display">\[
    L=\int_a^b\sqrt{(\rho(\theta))^2+(\rho&#39;(\theta))^2}.
\]</span></p>
<details>
<summary>
<b>证明</b></b>
</summary>
<p><img src="length_of_curve1.png" /> <img src="length_of_curve2.png" />
<img src="length_of_curve3.png" /></p>
</details>
<p><strong>旋转面的面积</strong></p>
<p>比如 <span class="math inline">\(f(x), a\le x\le b\)</span> 绕 <span
class="math inline">\(x\)</span> 轴旋转得到的旋转体, 有 <span
class="math display">\[
    \mathrm dS=2\pi f(x)\mathrm dL
\]</span> 故 <span class="math display">\[
    S=2\pi \int_a^b f(x)\sqrt{1+(f&#39;(x))^2}\mathrm dx.
\]</span></p>
<p><strong>曲线的曲率</strong></p>
<p>定义为: <span class="math inline">\(k=\left|\lim\limits_{\Delta s\to
0}\dfrac{\Delta \alpha}{\Delta s}\right|\)</span>, <span
class="math inline">\(1/k\)</span> 称为曲率半径.</p>
<p>公式为</p>
<p><span class="math display">\[
    k = \dfrac{|y&#39;&#39;|}{(1+y&#39;^2)^{3/2}}.
\]</span></p>
<h2 id="广义积分的定义">广义积分的定义</h2>
<p><strong>无穷积分(第一类广义积分)</strong> 设 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,
+\infty]\)</span> 上定义, 任取 <span
class="math inline">\(b&gt;a\)</span>, 若 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上都可积, 且极限 <span class="math display">\[
    I=\lim_{b\to +\infty}\int_a^bf(x)\mathrm dx
\]</span> 存在有限, 则称无穷积分 <span
class="math inline">\(\displaystyle\int_a^{+\infty}f(x)\mathrm
dx\)</span> 收敛, 其积分值为 <span class="math inline">\(I\)</span>,
记作 <span class="math display">\[
    \int_a^{+\infty}f(x)\mathrm dx=\lim_{b\to
+\infty}\int_a^bf(x)\mathrm dx.
\]</span> 否则称为发散. <span class="math inline">\(+\infty\)</span>
称为奇点.</p>
<p>类似可定义 <span class="math display">\[
    \int_{-\infty}^bf(x)\mathrm dx=\lim_{a\to
-\infty}\int_a^bf(x)\mathrm dx
\]</span></p>
<p>若两个积分都收敛, 则称 <span class="math display">\[
    \int_{-\infty}^{+\infty}f(x)\mathrm dx=\int_{-\infty}^cf(x)\mathrm
dx+\int_{c}^{+\infty}f(x)\mathrm dx
\]</span> 收敛, 否则称为发散. <strong>多个奇点要分开!</strong></p>
<blockquote>
<p><strong>Cauchy 收敛</strong> 若 <span
class="math inline">\(\displaystyle I=\lim_{A\to +\infty}
\int_{-A}^{A}f(x)\mathrm dx\)</span> 收敛, 则称 <span
class="math inline">\(\displaystyle\int_{-\infty}^{+\infty} f(x)\mathrm
dx\)</span> 是 Cauchy 收敛, <span class="math inline">\(I\)</span>
称为它的 Cauchy 主值.</p>
</blockquote>
<p><strong>瑕积分(第二类广义积分)</strong> 考虑 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上无界, 有 <span class="math inline">\(c\in[a, b]\)</span>
是 <span class="math inline">\(f\)</span> 的无穷间断点(称为奇点).</p>
<p>先考虑唯一奇点的情况:</p>
<p>若 <span class="math inline">\(x=b\)</span> 是唯一奇点, 即 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,
b-\delta](\delta&gt;0)\)</span> 上可积, 且 <span
class="math inline">\(\lim\limits_{x\to b-}|f(x)|=+\infty\)</span>,
若极限 <span class="math display">\[
    I=\lim_{\delta\to 0+}\int_a^{b-\delta}f(x)\mathrm dx
\]</span> 存在有限, 则称瑕积分 <span class="math inline">\(\displaystyle
\int_a^bf(x)\mathrm dx\)</span> 收敛, 积分值为 <span
class="math inline">\(I\)</span>, 记作 <span class="math display">\[
    \int_a^bf(x)\mathrm dx=\lim_{\delta\to
0+}\int_a^{b-\delta}f(x)\mathrm dx.
\]</span> 否则称其发散.</p>
<p>类似地, 若 <span class="math inline">\(x=a\)</span> 是唯一奇点, 则
<span class="math display">\[
    \int_a^bf(x)\mathrm dx=\lim_{\delta\to
0+}\int_{a+\delta}^bf(x)\mathrm dx.
\]</span></p>
<p>若 <span class="math inline">\(c\in(a, b)\)</span> 是唯一奇点, 则
<span class="math display">\[
    \int_a^bf(x)\mathrm dx=\int_a^cf(x)\mathrm dx+\int_c^bf(x)\mathrm
dx.
\]</span> 当右侧两积分均收敛时, 才称左侧积分收敛, 否则发散.
(<strong>多个奇点要分开!</strong>)</p>
<blockquote>
<p>同样地, 若 <span class="math inline">\(\displaystyle
I=\lim_{\delta\to 0+}\left(\int_a^{c-\delta}f(x)\mathrm
dx+\int_{c+\delta}^bf(x)\mathrm dx\right)\)</span> 收敛, 则称 <span
class="math inline">\(\displaystyle\int_a^bf(x)\mathrm dx\)</span> 是
Cauchy 收敛, <span class="math inline">\(I\)</span> 称为它的 Cauchy
主值.</p>
</blockquote>
<p><strong>广义积分的牛顿-莱布尼兹公式</strong> 类似于常义积分的,
但是代入上下界时可能需要取极限.</p>
<blockquote>
<p>对于瑕积分: 若原函数 <span class="math inline">\(F(x)\)</span> 在
<span class="math inline">\([a, b]\)</span> 上连续, 则不管 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\([a,
b]\)</span> 上有几个分点, 积分均收敛, 且可用牛顿-莱布尼兹计算其值.</p>
</blockquote>
<h2 id="广义积分的性质">广义积分的性质</h2>
<ol type="1">
<li><span class="math inline">\(\displaystyle \int_a^bf(x)\mathrm
dx\)</span>(<span class="math inline">\(b\)</span> 是唯一奇点,
是无界的或者是 <span class="math inline">\(+\infty\)</span>) 收敛 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\forall c\in (a, b)\)</span>, <span
class="math inline">\(\displaystyle \int_c^bf(x)\mathrm dx\)</span>
收敛, 且 <span class="math display">\[
\int_a^b=\int_a^c+\int_c^b.
\]</span></li>
<li>线性性.</li>
<li>换元积分与分部积分也适用.</li>
<li>(Cauchy 收敛准则)
<ul>
<li><span class="math inline">\(\displaystyle\int_a^{+\infty}f(x)\mathrm
dx\)</span> 收敛 <span class="math inline">\(\Leftrightarrow\)</span>
<span class="math inline">\(\forall \varepsilon&gt;0, \exists
M&gt;a\)</span>, 当 <span
class="math inline">\(A&#39;&gt;A&gt;M\)</span> 时, 有 <span
class="math inline">\(\displaystyle \left|\int_A^{A&#39;}f(x)\mathrm
dx\right|&lt;\varepsilon\)</span>.</li>
<li><span class="math inline">\(\displaystyle\int_a^bf(x)\mathrm
dx\)</span>(<span class="math inline">\(b\)</span> 为唯一瑕点)收敛 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\forall \varepsilon&gt;0, \exists \delta
&gt;0\)</span>, 当 <span
class="math inline">\(0&lt;\eta&#39;&lt;\eta&lt;\delta\)</span> 时, 有
<span
class="math inline">\(\displaystyle\left|\int_{b-\eta}^{b-\eta&#39;}f(x)\mathrm
dx\right|&lt;\varepsilon\)</span>.</li>
</ul></li>
</ol>
<h2 id="广义积分的审敛法">广义积分的审敛法</h2>
<p><strong>第一种</strong> 设 <span class="math inline">\(0\le f(x)\le
g(x), a\le x&lt; b\)</span>, <span class="math inline">\(b\)</span>
是奇点.</p>
<ol type="1">
<li>若 <span class="math inline">\(\displaystyle \int_a^bg(x)\mathrm
dx\)</span> 收敛, 则 <span class="math inline">\(\displaystyle
\int_a^bf(x)\mathrm dx\)</span> 收敛, 且 <span
class="math inline">\(\displaystyle \int_a^bf(x)\mathrm dx\le
\int_a^bg(x)\mathrm dx\)</span>.</li>
<li>若 <span class="math inline">\(\displaystyle \int_a^bf(x)\mathrm
dx\)</span> 发散, 则 <span class="math inline">\(\displaystyle
\int_a^bg(x)\mathrm dx\)</span> 发散.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>

</blockquote>
<blockquote>
<p>2 是 1 的逆否, 故只证 1 即可.</p>
<p>一方面 <span class="math inline">\(\displaystyle\int_a^Af(x)\mathrm
dx(a&lt;A&lt;b)\)</span> 关于 <span class="math inline">\(A\)</span>
单调递增; 另一方面, 它有上界 <span
class="math inline">\(\displaystyle\int_a^bg(x)\mathrm dx\)</span>,
故极限存在, 故收敛.</p>
</blockquote>
</details>
<p><strong>第二种</strong> (极限形式)</p>
<p>若在 <span class="math inline">\(b\)</span> 的一个左邻域内有 <span
class="math inline">\(f(x)\ge 0, g(x)&gt; 0\)</span>, <span
class="math inline">\(b\)</span> 为唯一奇点, 且有 <span
class="math display">\[
    \lim_{x\to b-}\dfrac{f(x)}{g(x)}=\lambda.
\]</span></p>
<p>则:</p>
<ol type="1">
<li>当 <span class="math inline">\(0&lt;\lambda&lt;+\infty\)</span> 时,
<span class="math inline">\(\displaystyle\int_a^bf(x)\mathrm dx\)</span>
与 <span class="math inline">\(\displaystyle\int_a^bg(x)\mathrm
dx\)</span> 有相同的敛散性.</li>
<li>当 <span class="math inline">\(\lambda=0\)</span> 时, 由 <span
class="math inline">\(\displaystyle\int_a^bg(x)\mathrm dx\)</span>
收敛可推知 <span class="math inline">\(\displaystyle \int_a^bf(x)\mathrm
dx\)</span> 收敛.</li>
<li>当 <span class="math inline">\(\lambda=+\infty\)</span> 时, 由 <span
class="math inline">\(\displaystyle\int_a^bg(x)\mathrm dx\)</span>
发散可推知 <span class="math inline">\(\displaystyle \int_a^bf(x)\mathrm
dx\)</span> 发散.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>利用极限的保号性易得.</p>
</blockquote>
</details>
<p><strong>第三种</strong> (柯西审敛法)</p>
<p>对于无穷积分, 若 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, +\infty)\)</span> 上, 有 <span
class="math inline">\(f(x)\ge 0\)</span>, 且 <span
class="math inline">\(\displaystyle\lim_{x\to\infty}x^pf(x)=k\)</span>.</p>
<ol type="1">
<li>若 <span class="math inline">\(p&gt;1\)</span> 且 <span
class="math inline">\(0\le k&lt;+\infty\)</span>, 则 <span
class="math inline">\(\displaystyle\int_a^{+\infty}f(x)\mathrm
dx\)</span> 收敛.</li>
<li>若 <span class="math inline">\(p\le 1\)</span> 且 <span
class="math inline">\(0&lt;k\le +\infty\)</span>, 则 <span
class="math inline">\(\displaystyle\int_a^{+\infty}f(x)\mathrm
dx\)</span> 发散.</li>
</ol>
<p>对于瑕积分, 若 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a, b)\)</span> 上有 <span
class="math inline">\(f(x)\ge 0\)</span>, <span
class="math inline">\(b\)</span> 为唯一瑕点, 且 <span
class="math inline">\(\displaystyle \lim_{x\to
b-}(b-x)^pf(x)=k\)</span>.</p>
<ol type="1">
<li>若 <span class="math inline">\(p&lt;1\)</span> 且 <span
class="math inline">\(0\le k&lt;+\infty\)</span>, 则 <span
class="math inline">\(\displaystyle\int_a^bf(x)\mathrm dx\)</span>
收敛.</li>
<li>若 <span class="math inline">\(p\ge 1\)</span> 且 <span
class="math inline">\(0&lt;k\le +\infty\)</span>, 则 <span
class="math inline">\(\displaystyle\int_a^bf(x)\mathrm dx\)</span>
发散.</li>
</ol>
<details>
<summary>
<b>证明</b>
</summary>
<blockquote>
<p>由第二种与 <span class="math inline">\(x^p, (b-x)^p\)</span>
的敛散性可得.</p>
</blockquote>
</details>
<p><strong>第四种</strong> (狄利克雷判别法)</p>
<p>若 <span class="math inline">\(\displaystyle F(A)=\int_a^Af(x)\mathrm
dx\)</span> 在 <span class="math inline">\([a, b)\)</span> 上有界, <span
class="math inline">\(g(x)\)</span> 在 <span class="math inline">\([a,
b)\)</span> 上单调且 <span class="math inline">\(\displaystyle\lim_{x\to
b-}g(x)=0\)</span>, 则 <span
class="math inline">\(\displaystyle\int_a^{b}f(x)g(x)\mathrm dx\)</span>
(<span class="math inline">\(b\)</span> 为唯一奇点) 收敛.</p>
<p><strong>第五种</strong> (阿贝尔判别法)</p>
<p>若 <span class="math inline">\(\displaystyle \int_a^{b}f(x)\)</span>
收敛(<span class="math inline">\(b\)</span> 为唯一奇点), <span
class="math inline">\(g(x)\)</span> 在 <span class="math inline">\([a,
+\infty)\)</span> 上单调有界, 则 <span
class="math inline">\(\displaystyle\int_a^bf(x)g(x)\mathrm dx\)</span>
收敛.</p>
<h1 id="拓展内容">拓展内容</h1>
<h2 id="华利斯公式">华利斯公式</h2>
<details>
<summary>
<b>展开图片</b>
</summary>
<p><img src="hls1.png" /> <img src="hls2.png" /> <img src="hls3.png" />
<img src="hls4.png" /></p>
</details>
<h2 id="泰勒公式的积分型余项">泰勒公式的积分型余项</h2>
<details>
<summary>
<b>展开图片</b>
</summary>
<p><img src="taylor_integR1.png" /> <img src="taylor_integR2.png" /></p>
</details>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>Calculus</tag>
        <tag>Maths</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（二） Open Topic I 笔记</title>
    <url>/posts/1e552920/</url>
    <content><![CDATA[<p>选题为 4-1, 讲解生成函数.</p>
<span id="more"></span>
<p>演示文稿: 详见 <a href="1.pdf">Slide</a>.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数 学习笔记</title>
    <url>/posts/cb24788d/</url>
    <content><![CDATA[<p>一份简要的斯特林数学习笔记. 从<a
href="https://blog.csdn.net/qq_41996523/article/details/116004026">原博客</a>迁移而来.</p>
<span id="more"></span>
<h1 id="第二类斯特林数斯特林子集数">第二类斯特林数（斯特林子集数）</h1>
<p><span class="math inline">\(\begin{Bmatrix}n \\
k\end{Bmatrix}\)</span>，表示将 <span class="math inline">\(n\)</span>
个两两不同的元素，划分为 <span class="math inline">\(k\)</span>
个互不区分的非空集合的方案数。</p>
<p>有递推式 <span class="math inline">\(\begin{Bmatrix}n \\
k\end{Bmatrix}=k\cdot \begin{Bmatrix}n-1 \\
k\end{Bmatrix}+\begin{Bmatrix}n-1 \\ k-1\end{Bmatrix},\begin{Bmatrix}n
\\ 0\end{Bmatrix}=[n=0]\)</span>。</p>
<p>同时还有通项公式</p>
<p><span class="math display">\[
\begin{Bmatrix}n \\
k\end{Bmatrix}=\sum_{i=0}^k\dfrac{(-1)^{k-i}i^n}{(k-i)!i!}
\]</span></p>
<p>证明：</p>
<p>考虑这样一个问题：将 <span class="math inline">\(n\)</span>
个物品涂成 <span class="math inline">\(k\)</span>
种颜色，我们用两种方法计算它的方案数：</p>
<p><span class="math display">\[
k^n=\sum_{i=0}^k\binom{k}{i}\begin{Bmatrix}n \\ i\end{Bmatrix}i!
\]</span></p>
<p>左边是显然的。右边是枚举用几种颜色涂。（注意到第二类斯特林数不允许空集）</p>
<p>做一个二项式反演，得到</p>
<p><span class="math display">\[
\begin{Bmatrix}n \\
k\end{Bmatrix}k!=\sum_{i=0}^k(-1)^{k-i}\binom{k}{i}i^n
\]</span></p>
<p>稍加整理就能得到结论。</p>
<h1 id="第一类斯特林数斯特林轮换数">第一类斯特林数（斯特林轮换数）</h1>
<p><span class="math inline">\(\begin{bmatrix}n \\
k\end{bmatrix}\)</span>，将 <span class="math inline">\(n\)</span>
个两两不同的元素，划分为 <span class="math inline">\(k\)</span>
个互不区分的非空轮换的方案数。</p>
<p>有递推式 <span class="math inline">\(\begin{bmatrix}n \\
k\end{bmatrix}=(n-1)\begin{bmatrix}n-1 \\
k\end{bmatrix}+\begin{bmatrix}n-1 \\ k-1\end{bmatrix},\begin{bmatrix}n
\\ 0\end{bmatrix}=[n=0]\)</span></p>
<p>它没有实用的通项公式。</p>
<h1 id="斯特林数的计算">斯特林数的计算</h1>
<p>显然，两种斯特林数都可以 <span class="math inline">\(O(nk)\)</span>
求。</p>
<h2 id="第二类斯特林数-行">第二类斯特林数 · 行</h2>
<p>根据通项公式</p>
<p><span class="math display">\[
\begin{Bmatrix}n \\
k\end{Bmatrix}=\sum_{i=0}^n\dfrac{(-1)^{k-i}i^n}{(k-i)!i!}
\]</span></p>
<p>于是设 <span class="math inline">\(f_n=\sum_{k\ge 0}\begin{Bmatrix}n
\\ k\end{Bmatrix}x^k,g_n=\sum_{k\ge 0}\dfrac{i^n}{i!}x^k\)</span>，则
<span class="math inline">\(f_n=e^{-x}*g_n\)</span>。</p>
<h2 id="第二类斯特林数-列">第二类斯特林数 · 列</h2>
<p>先考虑把相同的集合变成不同的非空盒子，则最后答案需要除以 <span
class="math inline">\(k!\)</span>。</p>
<p>设一个非空盒子的 EGF（以物品数量为组合对象）为 <span
class="math inline">\(G(x)\)</span>，<span
class="math inline">\(k\)</span> 个非空盒子的 EGF 为 <span
class="math inline">\(F(x)\)</span>。故有</p>
<p><span class="math display">\[
G(x)=\sum_{i\ge 1} \dfrac{x^i}{i}=e^x-1,F(x)=G^k(x)
\]</span></p>
<p>于是有</p>
<p><span class="math display">\[
\sum_{i\ge 0}\begin{Bmatrix}i \\
k\end{Bmatrix}\dfrac{x^i}{i!}=\dfrac{(e^x-1)^k}{k!}
\]</span></p>
<p>直接多项式快速幂计算。</p>
<h2 id="第一类斯特林数-行">第一类斯特林数 · 行</h2>
<p>设 <span class="math inline">\(f_n(x)=\sum_{i\ge 0}\begin{bmatrix}n
\\ k\end{bmatrix}x^i\)</span>，由递推式得到</p>
<p><span class="math display">\[
f_{n+1}(x)=(x+n)f_n(x)
\]</span></p>
<p>得到</p>
<p><span class="math display">\[
f_n(x)=\prod_{i=0}^{n-1}(x+i)=x^{\overline n}
\]</span></p>
<p>我们的任务转化为计算上升幂。可以通过分治 FFT 以 <span
class="math inline">\(O(n\log^2n)\)</span> 完成。</p>
<p>但是，也可以如下计算：</p>
<p>考虑倍增，<span
class="math inline">\(f_{2n}(x)=x^{\overline{2n}}=x^{\overline
{n}}(x+n)^{\overline{n}}=f_n(x)f_n(x+n)\)</span></p>
<p>下面为了方便表述，设 <span class="math inline">\(f_n(x)=\sum_{i\ge
0}a_ix^i\)</span></p>
<p><span class="math display">\[
\begin{aligned}
    f_n(x+n)=&amp;\sum_{i=0}^na_i(x+n)^i
    \\=&amp;\sum_{i=0}^na_i\sum_{j=0}^i\binom{i}{j}x^jn^{i-j}
    \\=&amp;\sum_{j= 0}^n\dfrac{x^j}{j!}\sum_{i =
j}^n\dfrac{n^{i-j}}{(i-j)!}a_ii!
\end{aligned}
\]</span></p>
<p>设 <span
class="math inline">\(A_i=a_ii!,B_i=\dfrac{n^i}{i!}\)</span></p>
<p>故</p>
<p><span class="math display">\[
\begin{aligned}
    f_n(x+n)=&amp;\sum_{j=0}^n\dfrac{x^j}{j!}\sum_{i=j}^nA(i)B(i-j)
    \\=&amp;\sum_{j=0}^n\dfrac{x^j}{j!}
    \sum_{i=0}^{n-j}A(i+j)B(i)
\end{aligned}
\]</span></p>
<p>后面那部分显然可以卷积，于是再做个和、除以 <span
class="math inline">\(j!\)</span> 就可以得到 <span
class="math inline">\(f_n(x+n)\)</span>。</p>
<p>总复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="第一类斯特林数-列">第一类斯特林数 · 列</h2>
<p>先写出单个轮换的EGF：</p>
<p><span class="math display">\[
f(x)=\sum_{i\ge 1}(i-1)!\dfrac{x^i}{i!}=\sum_{i\ge
1}\dfrac{x^i}{i}=\ln\dfrac{1}{1-x}
\]</span></p>
<p>于是，<span class="math inline">\(k\)</span> 个轮换的 EGF 即为</p>
<p><span class="math display">\[
\dfrac{f^k(x)}{k!}
\]</span></p>
<p>做多项式快速幂即可。</p>
<h1 id="阶乘幂与方幂的转化">阶乘幂与方幂的转化</h1>
<p>根据上面第一类斯特林数的性质，有</p>
<p><span class="math display">\[
    x^{\overline{n}}=\sum_{i=0}^n\begin{bmatrix} n \\ i\end{bmatrix}x^i
\]</span></p>
<p>利用有符号第一类斯特林数，用类似的推导方法可以得到</p>
<p><span class="math display">\[
x^{\underline{n}}=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n \\
i\end{bmatrix}x^i
\]</span></p>
<p>我们再看看怎么转化回去：</p>
<p><span class="math display">\[
x^n=\sum_{i=0}^n\begin{Bmatrix}n \\ i\end{Bmatrix}\binom{x}{i} i!
\]</span></p>
<p>而 <span class="math inline">\(\binom{x}{i}i!=x^{\underline
i}\)</span>。</p>
<p>于是</p>
<p><span class="math display">\[
x^n=\sum_{i=0}^n\begin{Bmatrix}n \\ i\end{Bmatrix}x^{\underline i}
\]</span></p>
<p>同样有方幂转上升幂</p>
<p><span class="math display">\[
x^n=\sum_{i=0}^n(-1)^{n-i}\begin{Bmatrix}n \\
i\end{Bmatrix}x^{\overline{i}}
\]</span></p>
<p>这两个有符号斯特林数推出的式子，可以直接用上升幂和下降幂的相似性得到（它们展开后仅差一些负号）。</p>
<p>当然，这四个式子都可以数学归纳证明。</p>
<p>如何记忆呢？</p>
<p>将阶乘幂转化为方幂，使用第一类斯特林数（它的 OGF 决定了这一点）；</p>
<p>将方幂转化为阶乘幂，使用第二类斯特林数（它的 组合意义
决定了这一点）。</p>
<p>那么，什么时候添加 <span
class="math inline">\((-1)^{n-i}\)</span>？显然有 <span
class="math inline">\(x^{\overline{n}}\ge x^n \ge
x^{\underline{n}}\)</span>，当将大的幂转化为小的幂的时候，需要添加负号。</p>
<h1 id="斯特林反演">斯特林反演</h1>
<p>若</p>
<p><span class="math display">\[
g(n)=\sum_{i=0}^n\begin{Bmatrix}n \\ i\end{Bmatrix}f(i)
\]</span></p>
<p>则</p>
<p><span class="math display">\[
f(n)=\sum_{i=0}^n(-1)^{n-i}\begin{Bmatrix}n \\ i\end{Bmatrix}g(i)
\]</span></p>
<p>当然，把第一类和第二类反过来也对；根据反演的一般套路，改为枚举 <span
class="math inline">\(j\ge i\)</span> 也对。</p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Maths</tag>
        <tag>Computer Science</tag>
        <tag>Stirling Number</tag>
      </tags>
  </entry>
  <entry>
    <title>网页前端初步 总结</title>
    <url>/posts/d06840d0/</url>
    <content><![CDATA[<p>在学习一定的网页前端开发知识后, 所做的一些总结.</p>
<span id="more"></span>
<h1 id="背景">背景</h1>
<p>在南京大学新生研讨课"大分子--从材料到生命"(<a
href="https://wbhu.nju.edu.cn/">课程主页</a>)上,
课程作业是选择某种高分子, 建立面向中学生的科普网站.</p>
<h1 id="成果展示">成果展示</h1>
<p>我们选定的主题是液晶大分子. 网页的 GitHub 仓库为<a
href="https://github.com/rijuyuezhu/20222-webmake-lc">rijuyuezhu/20222-webmake-lc</a>.</p>
<ul>
<li>网页挂载到 Cloudflare 上为 <a
href="https://20222-webmake-lc.pages.dev/"
class="uri">https://20222-webmake-lc.pages.dev/</a>.</li>
<li>网页挂载到 GitHub Pages 上为 <a
href="https://rijuyuezhu.github.io/20222-webmake-lc/"
class="uri">https://rijuyuezhu.github.io/20222-webmake-lc/</a>.</li>
</ul>
<h1 id="网页制作方法">网页制作方法</h1>
<p>请看<a href="slide/slide.html">这个 Slide</a>. (好不容易配好的 slide
当然要用一用)</p>
<p>里面较为详细地讲述了前端的常用工具和语言.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Config on Ubuntu 22.04</title>
    <url>/posts/f924642d/</url>
    <content><![CDATA[<p>This article mainly talks about what to do after installing Ubuntu
22.04.</p>
<span id="more"></span>
<p>This time I configure Ubuntu 22.04 and form my own configuration. And
I record the process below.</p>
<h1 id="install-ubuntu-22.04">Install Ubuntu 22.04</h1>
<p><a
href="https://www.linuxteck.com/how-to-install-ubuntu-22-04-lts-step-by-step/">Here</a>
is a pretty-written tutorial for installing Ubuntu 22.04, but there are
some stuffs to notice:</p>
<ol type="1">
<li>Do not give <code>/home</code> too much space and <code>/</code> too
few, or it will be difficult later when installing many softwares. For
me, I recommend that you don't specifically give <code>/home</code>
space additionally.</li>
<li>Use Filesystem type <code>ext4</code> instead of
<code>xfs</code>.</li>
</ol>
<p>For a SSD of size 256GB, I attribute it into districts like:</p>
<p><img src="SSD-distribution.png" /></p>
<p>After that, see <a
href="https://itsfoss.com/things-to-do-after-installing-ubuntu-22-04/">Things
to do After Installing Ubuntu 22.04</a> for some basic settings.</p>
<p>To install some basic sofewares, google it.</p>
<p>One problem that needs to be treated carefully is the Chinese input
method. <a href="https://zhuanlan.zhihu.com/p/508797663">This</a> is a
tutorial to configure an input method based on Fcitx5.</p>
<h1 id="oh-my-zsh">Oh My Zsh</h1>
<p><a href="https://ohmyz.sh/">Oh My Zsh</a> is one of the greatest
platform to manage zsh configuration. Surf the official documentation
for installing it.</p>
<p>After that, you can have some plugins for it. <a
href="https://zhuanlan.zhihu.com/p/589706383">This</a> one shows some of
the awesome plugins for oh my zsh. One thing you shall notice is that
for the installation of the plugins, you'd better turn to the official
documentation for help, instead of the article provided.</p>
<h1 id="tmux">Tmux</h1>
<p>Following are some of the configuration note for <a
href="https://github.com/tmux/tmux">Tmux</a>:</p>
<ol type="1">
<li><a href="https://www.jianshu.com/p/fd3bbdba9dc9"
class="uri">https://www.jianshu.com/p/fd3bbdba9dc9</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/166557307"
class="uri">https://zhuanlan.zhihu.com/p/166557307</a></li>
<li><a
href="https://www.rushiagr.com/blog/2016/06/16/everything-you-need-to-know-about-tmux-copy-pasting-ubuntu/"
class="uri">https://www.rushiagr.com/blog/2016/06/16/everything-you-need-to-know-about-tmux-copy-pasting-ubuntu/</a></li>
<li><a href="https://www.cnblogs.com/ericte/p/13613303.html"
class="uri">https://www.cnblogs.com/ericte/p/13613303.html</a></li>
</ol>
<p>After that, I recommend a plugin called <a
href="https://github.com/tmux-plugins/tmux-resurrect">tmux-resurrect</a>
along with <a
href="https://github.com/tmux-plugins/tmux-continuum">tmux-continuum</a>,
which help to restore the status of tmux even after restarting.</p>
<h1 id="vim">Vim</h1>
<p>Following are some of the configuration note for <a
href="https://www.vim.org/">vim</a> or <a
href="https://neovim.io/">neovim</a>. (I recommend neovim)</p>
<ol type="1">
<li><a href="https://ruanyifeng.com/blog/2018/09/vimrc.html"
class="uri">https://ruanyifeng.com/blog/2018/09/vimrc.html</a></li>
<li><a href="https://www.bilibili.com/video/BV164411P7tw"
class="uri">https://www.bilibili.com/video/BV164411P7tw</a></li>
</ol>
<p>And for plugins, turn to my configuration repository.</p>
<h1 id="configuration-repository">Configuration repository</h1>
<p>See <a href="https://github.com/rijuyuezhu/config-repo"
class="uri">https://github.com/rijuyuezhu/config-repo</a> for my
configurations.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use customized domain for GitHub Pages</title>
    <url>/posts/61f05c0b/</url>
    <content><![CDATA[<p>I managed to set up my own website(Blog, and personal homepage later)
by GitHub Pages. The service provides default domains for the pages. But
I would like to use my own domain.</p>
<span id="more"></span>
<h1 id="default-domain">Default domain</h1>
<p>In detail, suppose that your GitHub username is
<code>&lt;username&gt;</code>, then by default, the service gives the
domains like:</p>
<ul>
<li>For user page(in the special repository
<code>&lt;username&gt;.github.io</code>), it provides the domain
<code>&lt;username&gt;.github.io</code> for it.</li>
<li>For project page(in repository named <code>&lt;repo&gt;</code>), it
provides the domain <code>&lt;username&gt;.github.io/&lt;repo&gt;</code>
for it.</li>
</ul>
<p>For more information, see the <a
href="https://docs.github.com/en/pages">official documentation</a>.</p>
<h2 id="buy-own-domain-configure">Buy own domain &amp; Configure</h2>
<p>I recommend <a href="https://www.namesilo.com/">namesilo</a> to buy
your own domain. <a
href="https://zhuanlan.zhihu.com/p/333502225">Here</a> is a good
tutorial for it.</p>
<p>After that, use <a href="https://www.dnspod.cn/">DNSPOD</a> for DNS.
It's easy: follow the instructions on DNSPOD to change the DNS server on
namesilo DNS configuration page. After this step, everything you shall
do is to configure DNS rules on DNSPOD, with no regard to the namesilo
configuration.</p>
<p>Then we can transparent the domains by default.</p>
<p>To add coustomized subdomain and apex domain, see the <a
href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">official
documentation</a>. But here are some notations.</p>
<p>Firstly, If you change the user page domain
<code>&lt;username&gt;.github.io/</code> to customized domain
<code>&lt;subdomain&gt;.example.com/</code>, then all the repository
pages will be on
<code>&lt;subdomain&gt;.example.com/&lt;repo&gt;</code>. If the user
page is not transparented, the repository page remains
<code>&lt;username&gt;.github.io/&lt;repo&gt;</code>. However, if you
configure <strong>any</strong> repository page with customized domain
with <strong>no customized domain for user page</strong>, supposing the
domain for <code>&lt;another-subdomain&gt;.example.com</code>, the link
to <code>&lt;username&gt;.github.io/&lt;repo&gt;</code> will be resolved
automatically into
<code>&lt;another-subdomain&gt;.example.com/&lt;repo&gt;</code>, where
no site is here. As a result, always give a main page,</p>
<p>Secondly, here are some methods to use one domain to jump to another
domain. Here is a template:</p>
<p>At the repository where we want to jump to another, we use a
<code>404.html</code> file only, which contains</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Redirecting<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> domain = <span class="string">&quot;&lt;domain jump to&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> current = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> target = current.<span class="title function_">substring</span>(current.<span class="title function_">indexOf</span>(<span class="string">&#x27;/&#x27;</span>, current.<span class="title function_">indexOf</span>(<span class="string">&#x27;:&#x27;</span>) + <span class="number">3</span>));</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;//&quot;</span> + domain + target;</span></span><br><span class="line"><span class="language-javascript">        location.<span class="property">href</span> = <span class="string">&quot;//&quot;</span> + domain + target;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（二） Open Topic II 笔记</title>
    <url>/posts/c0a6679e/</url>
    <content><![CDATA[<p>选题为 6-1, 讲解在 <a
href="https://www.youtube.com/watch?v=vkUNH9r6UCI">Stanford Lecture -
Don Knuth: The Analysis of Algorithms</a> 中的算法分析.</p>
<span id="more"></span>
<p>演示文稿: 详见 <a href="2.pdf">Slide</a>.</p>
<h1 id="问题引入">问题引入</h1>
<p>算法分析初探：</p>
<p>对于以下寻找最大值的算法(假设元素互不相同)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Given a[1..n]</span></span><br><span class="line">m = a[n]</span><br><span class="line">k = n-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> k != <span class="number">0</span> : </span><br><span class="line">    <span class="keyword">if</span> a[k] &gt; m :</span><br><span class="line">        m = a[k] <span class="comment"># (*)</span></span><br><span class="line">    k = k - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>尝试分析 (*) 句的执行次数.</p>
<h1 id="数据特征">数据特征</h1>
<p>要分析一个语句的执行次数,
我们可以从它的最小值、最大值、平均值、方差入手.</p>
<p>(*) 的执行次数的最小值是 <span class="math inline">\(0\)</span> (当
<span class="math inline">\(a[n]\)</span> 即为最大值), 最大值是 <span
class="math inline">\(n-1\)</span> (当序列降序), 平均值和方差呢?</p>
<p>平均值可以用 TC 中提及的指示性随机变量得到, <span
class="math inline">\(X_i\)</span> 表示在 <span
class="math inline">\(k=i\)</span> 时发生替换的次数, 等价于 <span
class="math inline">\(a[i]\)</span> 是 <span
class="math inline">\(a[i..n]\)</span> 中的最大值, 那么有 <span
class="math inline">\(E[X_i]=1/(n-i+1)\)</span>, 进一步有</p>
<p><span class="math display">\[
    E(X)=\sum_{i=1}^{n-i}\dfrac{1}{n-i+1}=H_n-1.
\]</span></p>
<p>其中 <span class="math inline">\(H_n\)</span> 是调和数.</p>
<p>那么方差呢? 这时我们就需要一些其它的方法了. 我们尝试直接考虑 (*)
的概率分布, 即求 <span class="math inline">\(p_{n, k}\)</span>, 意为在
<span class="math inline">\(n\)</span> 个数时执行次数为 <span
class="math inline">\(k(0\le k\le n-1)\)</span> 的概率.</p>
<h1 id="斯特林数">斯特林数</h1>
<h2 id="斯特林数介绍">斯特林数介绍</h2>
<p>首先来介绍第一类斯特林数(斯特林轮换数), 在 TC
作业里第二类斯特林数(斯特林子集数). 第一类斯特林数和它类似.</p>
<p><strong>斯特林轮换数:</strong> 将 <span
class="math inline">\(n\)</span> 个两两不同的元素划分为 <span
class="math inline">\(k\)</span> 个互不区分的非空轮换(圆排列)的方案数,
记为 <span class="math inline">\(\begin{bmatrix}n \\
k\end{bmatrix}\)</span>.</p>
<p>有递推公式为</p>
<p><span class="math display">\[
\begin{bmatrix}
    n \\ k
\end{bmatrix}
=(n-1)
\begin{bmatrix}
    n-1 \\ k
\end{bmatrix}
+
\begin{bmatrix}
    n-1 \\ k-1
\end{bmatrix}, (n\ge 1, k\ge 1).
\]</span></p>
<p>初始条件为 <span class="math inline">\(\begin{bmatrix}n \\
0\end{bmatrix} = [n=0]\)</span>.</p>
<p>证明: 考虑第 <span class="math inline">\(n\)</span> 个元素,
有两种可能:</p>
<ol type="1">
<li>被加入原先某一个元素的后面, 有 <span
class="math inline">\(n-1\)</span> 种可能. 没有形成新轮换, 所以乘上
<span class="math inline">\(\begin{bmatrix}n-1 \\
k\end{bmatrix}\)</span>,</li>
<li>独占一个轮换, 那么先前 <span class="math inline">\(n-1\)</span>
个元素需要填另外 <span class="math inline">\(k-1\)</span> 个轮换, 所以是
<span class="math inline">\(\begin{bmatrix}n-1 \\
k-1\end{bmatrix}\)</span>.</li>
</ol>
<h2 id="斯特林轮换数和原问题的关系">斯特林轮换数和原问题的关系</h2>
<p><span class="math display">\[
    p_{n, k}=\dfrac{1}{n!}\begin{bmatrix}n \\ k+1\end{bmatrix}, (0\le
k\le n-1).
\]</span></p>
<p>理解方法:</p>
<p>要使得 (*) 执行 <span class="math inline">\(k\)</span> 次,
那么原序列必然能分成非空的 <span class="math inline">\(k+1\)</span>
部分, 每一部分的最右边的元素是该部分的最大元素, 而且各部分之间,
最大元素(每一部分的最右边元素)递减. 于是我们发现:
每一部分内元素可以随便排列, 但是最后要"移动"使得最大元在最右边,
等价于一个圆排列; 由于各部分之间要求最大元素递减, 相当于使得这 <span
class="math inline">\(k+1\)</span> 个圆排列(轮换)不加以区分,
符合第一类斯特林数的定义. 最后除以 <span
class="math inline">\(n!\)</span> 就是概率.</p>
<h2 id="斯特林轮换数的生成函数">斯特林轮换数的生成函数</h2>
<p>考虑对于每一个 <span class="math inline">\(n\)</span> 值,
斯特林轮换数的生成函数为 <span
class="math inline">\(S_n(z)\)</span>.</p>
<p>于是 <span class="math inline">\(S_0(z)=1, S_1(z)=z\)</span>, 且当
<span class="math inline">\(n\ge 2\)</span>,</p>
<p><span class="math display">\[
    \begin{aligned}
        S_n(z) &amp;= \sum_{k\ge 0} \begin{bmatrix}n \\
k\end{bmatrix}z^k
        \\
        &amp;=\sum_{k\ge 1} \left((n-1)\begin{bmatrix}n-1 \\
k\end{bmatrix}+\begin{bmatrix}n-1 \\ k-1\end{bmatrix}\right)z^k
        \\
        &amp;=(n-1)\sum_{k\ge 1}\begin{bmatrix}n-1 \\
k\end{bmatrix}z^k+z\sum_{t\ge 0}\begin{bmatrix}n-1 \\ t\end{bmatrix}z^t
        \\
        &amp;=(n-1+z)S_{n-1}(z).
    \end{aligned}
\]</span></p>
<p>归纳可得 <span
class="math inline">\(S_n(z)=z(z+1)\cdots(z+n-1)=z^{\overline{n}}\)</span>.</p>
<h1 id="概率生成函数">概率生成函数</h1>
<h2 id="引入">引入</h2>
<p>回到原问题, 我们看一看以下这个生成函数, 固定 <span
class="math inline">\(n\)</span> 有</p>
<p><span class="math display">\[
    P_n(z)=\sum_{k\ge 0}p_{n, k}z^k
\]</span></p>
<p>它称为<strong>概率生成函数</strong>,
我们研究它的性质来研究均值和方差.</p>
<h2 id="概率生成函数的基本特征">概率生成函数的基本特征</h2>
<p>对于随机变量 <span class="math inline">\(X\)</span>
的概率生成函数</p>
<p><span class="math display">\[
    G(z)=\sum_{k\ge 0}p_kz^k.
\]</span></p>
<p>有 <span class="math inline">\(\displaystyle G(1)=\sum_{k\ge
0}p_k=1\)</span>. (概率生成函数的必要条件)</p>
<p>求导有</p>
<p><span class="math display">\[
    G&#39;(z)=\sum_{k\ge 1}kp_kz^{k-1}.
\]</span></p>
<p>有 <span class="math inline">\(\displaystyle G&#39;(1)=\sum_{k\ge
1}kp_k=E(X)\)</span>. (均值)</p>
<p>再求导有</p>
<p><span class="math display">\[
    G&#39;&#39;(z)=\sum_{k\ge 2}k(k-1)p_kz^{k-2}.
\]</span></p>
<p>有 <span class="math inline">\(\displaystyle
G&#39;&#39;(1)=\sum_{k\ge 2}(k^2-k)p_k\)</span>.</p>
<p>那么 <span class="math inline">\(\displaystyle
G&#39;&#39;(1)+G&#39;(1)=\sum_{k\ge 1}k^2p_k=E(X^2)\)</span>.</p>
<p>于是 <span class="math inline">\(\displaystyle
G&#39;&#39;(1)+G&#39;(1)-[G&#39;(1)]^2=E(X^2)-E^2(X)=D(X)\)</span>.
(方差)</p>
<p>所以我们成功用 <span class="math inline">\(G&#39;(1),
G&#39;&#39;(1)\)</span> 得到了 <span class="math inline">\(X\)</span>
的期望和方差, 总结是:</p>
<p><span class="math display">\[
    \begin{aligned}
        E(X) &amp;= G&#39;(1),
        \\
        D(X) &amp;= G&#39;&#39;(1)+G&#39;(1)-[G&#39;(1)]^2.
    \end{aligned}
\]</span></p>
<h2 id="概率生成函数卷积的均值和方差">概率生成函数卷积的均值和方差</h2>
<p>设 <span class="math inline">\(X\)</span> 的生成函数为 <span
class="math inline">\(G(z)\)</span>, <span
class="math inline">\(Y\)</span> 的生成函数为 <span
class="math inline">\(H(z)\)</span>, 令它们的卷积 <span
class="math inline">\(F=G*H\)</span></p>
<ol type="1">
<li>若 <span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 独立, 那么 <span
class="math inline">\(F(z)=(G*H)(z)\)</span> 是 <span
class="math inline">\(X+Y\)</span> 的生成函数.</li>
<li>若 <span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 不一定独立, 那么 <span
class="math inline">\(F(z)\)</span> 不一定表示 <span
class="math inline">\(X+Y\)</span> 的生成函数, 但这不影响 <span
class="math inline">\(F\)</span> 的均值和方差的计算,
它的均值和方差的公式不依赖于 <span class="math inline">\(X\)</span> 和
<span class="math inline">\(Y\)</span> 的独立性.</li>
</ol>
<p>首先验证 <span class="math inline">\(F\)</span> 是概率生成函数. 显然
<span class="math inline">\(F\)</span> 各项非负, 且 <span
class="math inline">\(F(1)=G(1)H(1)=1\)</span>, 故 <span
class="math inline">\(F\)</span> 是概率生成函数. 假设是 <span
class="math inline">\(Z\)</span> 的生成函数.</p>
<p>然后试着求求 <span class="math inline">\(Z\)</span> 的均值.
先求导</p>
<p><span class="math display">\[
    F&#39;(z)=G&#39;(z)H(z)+G(z)H&#39;(z).
\]</span></p>
<p>故 <span
class="math inline">\(E(Z)=F&#39;(1)=G&#39;(1)H(1)+G(1)H&#39;(1)=G&#39;(1)+H&#39;(1)=E(X)+E(Y)\)</span>.
<span class="math inline">\(Z\)</span> 的均值是 <span
class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 的均值的和.</p>
<p>然后试着求求 <span class="math inline">\(Z\)</span> 的方差.
再求导</p>
<p><span class="math display">\[
    F&#39;&#39;(z)=G&#39;&#39;(z)H(z)+2G&#39;(z)H&#39;(z)+G(z)H&#39;&#39;(z)
\]</span></p>
<p>故</p>
<p><span class="math display">\[
    \begin{aligned}
        D(Z) &amp;= F&#39;&#39;(1)+F&#39;(1)-[F&#39;(1)]^2
        \\
        &amp;=
G&#39;&#39;(1)+2G&#39;(1)H&#39;(1)+H&#39;&#39;(1)+G&#39;(1)+H&#39;(1)-[G&#39;(1)+H&#39;(1)]^2
        \\
        &amp;= \lbrace G&#39;&#39;(1)+G&#39;(1)-[G&#39;(1)]^2\rbrace +
\lbrace H&#39;&#39;(1)+H&#39;(1)-[H&#39;(1)]^2\rbrace
        \\
        &amp;=D(X)+D(Y).
    \end{aligned}
\]</span></p>
<p><span class="math inline">\(Z\)</span> 的方差是 <span
class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 的方差的和.</p>
<h1 id="解决问题">解决问题</h1>
<p>最后我们回到原题, 我们要求随机变量 <span
class="math inline">\(X_n\)</span> 对应的生成函数</p>
<p><span class="math display">\[
    P_n(z)=\sum_{k\ge 0}p_{n, k}z^k
\]</span></p>
<p>的均值和方差.</p>
<p>首先做点变形, 利用斯特林轮换数的生成函数有</p>
<p><span class="math display">\[
    \begin{aligned}
        P_n(z) &amp;=\sum_{k\ge 0}p_{n, k}z^k
        \\
        &amp;=\sum_{k\ge 0} \left(\dfrac{1}{n!}\begin{bmatrix}n \\
k+1\end{bmatrix}\right)z^k
        \\
        &amp;=\dfrac{1}{n!\cdot z}\sum_{i\ge 0}\begin{bmatrix}n \\
i\end{bmatrix}z^i
        \\
        &amp;=\dfrac{1}{n!\cdot z} [z(z+1)\cdots(z+n-1)]
        \\
        &amp;=\dfrac{1}{n!}(z+1)(z+2)\cdots (z+n-1)
    \end{aligned}
\]</span></p>
<p>为了求 <span class="math inline">\(P_n(z)\)</span> 的均值和方差,
我们把它分成 <span class="math inline">\(n-1\)</span>
个概率生成函数的乘积:</p>
<p><span class="math display">\[
    \begin{gather*}
        P_n=A_2*A_3*\cdots*A_{n}
        \\
        A_i(z)=\dfrac{z+i-1}{i}.
    \end{gather*}
\]</span> 容易验证 <span class="math inline">\(A_i(1)=1\)</span>, 故此处
<span class="math inline">\(A_i\)</span> 均是概率生成函数. 然后来求求
<span class="math inline">\(A_i(z)\)</span> 的均值和方差. 易得 <span
class="math inline">\(A_i&#39;(z)=1/i, A_i&#39;&#39;(z)=0\)</span>,
故</p>
<p><span class="math display">\[
    \begin{aligned}
        E(A_i)&amp;=A_i&#39;(z)=\dfrac{1}{i}
        \\
        D(A_i)&amp;=A_i&#39;&#39;(z)+A_i&#39;(z)-[A_i&#39;(z)]^2=\dfrac{1}{i}-\dfrac{1}{i^2}
    \end{aligned}
\]</span></p>
<p>那么,</p>
<p><span class="math display">\[
    \begin{gather*}
        E(X_n)=\sum_{i=2}^n\dfrac{1}{i}=H_n-1
        \\
        D(X_n)=\sum_{i=2}^n(\dfrac{1}{i}-\dfrac{1}{i^2})=H_n-H_n^{(2)}
    \end{gather*}
\]</span></p>
<p>其中 <span class="math inline">\(H_n\)</span> 为调和数 <span
class="math inline">\(1+\dfrac{1}{2}+\dfrac{1}{3}+\cdots+\dfrac{1}{n}\)</span>,
<span class="math inline">\(H_n^{(2)}\)</span> 为二阶调和数 <span
class="math inline">\(1+\dfrac{1}{2^2}+\dfrac{1}{3^2}+\cdots+\dfrac{1}{n^2}\)</span>.</p>
<h1 id="应用与总结">应用与总结</h1>
<h2 id="应用">应用</h2>
<p>于是我们得到了 (*) 的执行次数的数据如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">最小值</th>
<th style="text-align: center;">最大值</th>
<th style="text-align: center;">均值</th>
<th style="text-align: center;">方差</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(n-1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(H_n-1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(H_n-H_n^{(2)}\)</span></td>
</tr>
</tbody>
</table>
<p>得到这些数据有什么用? 由于 <span class="math inline">\(H_n=\Theta(\lg
n)\)</span>, 我们得知了在平均情况下只有 <span class="math inline">\(\lg
n\)</span> 次最大值替换,
这样我们可能可以在该支路运行高复杂度的算法(如插入数据库等)但不改变平均情况复杂度.
对原序列进行随机打乱可以使得无针对性输入.</p>
<h2 id="总结">总结</h2>
<p>Knuth 介绍了很多算法分析里的常用方法, 包括定量分析, 计数技巧,
生成函数等等. 这些工具可帮助我们完成算法分析.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to Rijuyuezhu&#39;s Blog</title>
    <url>/posts/24f2c823/</url>
    <content><![CDATA[<p>Glad to meet you! This is <a
href="https://blog.rijuyuezhu.top">Rijuyuezhu's Blog</a>, where I record
awesome things. Enjoy yourself!</p>
<span id="more"></span>
<h1 id="my-homepage">My homepage</h1>
<ul>
<li><a href="https://wrhuang.top/">My Personal Homepage</a>.</li>
</ul>
<h1 id="friend-links">Friend links</h1>
<p>(Might be one-way)</p>
<ul>
<li><a href="https://blog.water-mi.com/">water_mi</a>.</li>
<li><a href="https://www.cnblogs.com/520Enterprise">Enty520</a>.</li>
<li><a href="https://detect.wiki/">detect</a>.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Install easyconnect on Linux</title>
    <url>/posts/3bd1e424/</url>
    <content><![CDATA[<p>In order to visit some websites only in LAN, we need to use VPN. For
Nanjing University, its VPN is provided at <a
href="https://vpn.nju.edu.cn" class="uri">https://vpn.nju.edu.cn</a>,
easyconnect software. Its Linux version is too old to use in Ubuntu
22.04, and I use a docker contain to get through.</p>
<span id="more"></span>
<h1 id="resources">Resources</h1>
<p>Here are some tutorials:</p>
<ol type="1">
<li><a
href="https://www.bilibili.com/video/BV163411Z7BD/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bcaa4a86a7d65f8e08c87d5e75b0736f">Video
by Sakiyary</a></li>
<li><a href="https://github.com/Hagb/docker-easyconnect/tree/master">The
repo of docker-easyconnect</a></li>
<li><a
href="https://qiyuan-z.github.io/2020/02/16/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AESwitchyOmega%E6%8F%92%E4%BB%B6/">Configure
SwitchyOmega and Clash</a>.</li>
</ol>
<h1 id="steps">Steps</h1>
<p>My environment is Ubuntu 22.04 LTS.</p>
<p>Firstly, install <a href="https://www.docker.com/">docker
desktop</a>.</p>
<p>Then, install <a
href="https://www.realvnc.com/en/connect/download/viewer/">VNC
Viewer</a> for GUI version. (NJU VPN needs vertification code).</p>
<p>Next, view the <a
href="https://github.com/Hagb/docker-easyconnect/">note of the repo</a>.
My configuration is as follows:</p>
<ol type="1">
<li>run in terminal</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull hagb/docker-easyconnect:7.6.7</span><br></pre></td></tr></table></figure>
<p>to install image 7.6.7.</p>
<ol start="2" type="1">
<li>run</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name NJUEC --device /dev/net/tun --cap-add NET_ADMIN -ti -e PASSWORD=xxxx -v <span class="variable">$HOME</span>/.ecdata:/root -p 127.0.0.1:5901:5901 -p 127.0.0.1:6897:1080 hagb/docker-easyconnect:7.6.7</span><br></pre></td></tr></table></figure>
<p>Here we created a contain named <code>NJUEC</code>, with:</p>
<ul>
<li><code>127.0.0.1:5901</code>, ip &amp; port for remote desktop, i.e.
VNC Viewer.</li>
<li><code>127.0.0.1:6897</code>, ip &amp; port for socks5.</li>
</ul>
<ol start="3" type="1">
<li>open VNC Viewer, and enter <code>127.0.0.1:5901</code>, log in.</li>
<li>use SwitchyOmega to get rule configuration. See <a
href="https://www.bilibili.com/video/BV163411Z7BD/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bcaa4a86a7d65f8e08c87d5e75b0736f">Video
by Sakiyary</a> for steps, and replace the socks5 port by
<code>6897</code> here.</li>
<li>configure SwitchyOmega to work with Clash, see <a
href="https://qiyuan-z.github.io/2020/02/16/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AESwitchyOmega%E6%8F%92%E4%BB%B6/">Configure
SwitchyOmega and Clash</a>.</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker/Podman</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式 学习笔记</title>
    <url>/posts/9d0d7ccc/</url>
    <content><![CDATA[<p>之前学习多项式相关算法的学习笔记, 从<a
href="https://blog.csdn.net/qq_41996523/article/details/113404556">原博客</a>搬运而来.</p>
<span id="more"></span>
<p align="center" style="font-weight: bold; color: purple;">
(以下为原内容)
</p>
<p>这篇博客会讲一下我学多项式的板子（可能不太完善, 还请谅解）.</p>
<p>板子参考了 <a
href="https://venusnero.github.io/2019/03/19/poly_algorithm_note/">这里</a>.</p>
<p>学习资料:</p>
<p><a
href="https://www.cnblogs.com/lsq147/p/13798943.html">多项式与生成函数学习笔记</a></p>
<p><a href="https://karry5307.github.io/">Karry5307's Blog</a></p>
<h2 id="写在前面的话板子使用指南">写在前面的话（板子使用指南）</h2>
<p>基本所有的运算都可以大胆使用, 不用要求结果数组为空.</p>
<p>把用来计算的数组叫做操作数组, 存储结果的数组叫做结果数组.
则这个板子操作数组一般可以相同,
操作数组与结果数组之间一般不可以相同.</p>
<p>除多项式除法外, 所有的<code>n</code>意为多项式的
<strong>项数</strong> （或者说是 <strong>界</strong> ）,
而非度数（应为度数+1）.</p>
<p>所有的代码都附了一个检验方法, 用来判断是否打对,
建议每完成1~2个模块就检验一次.</p>
<h2 id="fft-ntt">FFT &amp; NTT</h2>
<p><a
href="https://blog.csdn.net/qq_41996523/article/details/113348016">多项式乘法(FFT/NTT)</a></p>
<p>这篇博客里有详细代码.
这里给一个下面都会用到的"封装版"多项式乘法（预处理了 单位根 和
逆元（方便积分））:</p>
<blockquote>
<p>检验方法:</p>
<p>找一个多项式平方. 我喜欢找 <span
class="math inline">\(1+x+x^2+\cdots\)</span>,
它的平方相当于求前缀和.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> clr(f, s, t) memset(f + (s), 0x00, sizeof(int) * ((t) - (s)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpy(f, g, n) memcpy(g, f, sizeof(int) * (n))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">5</span>, bas = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>, invG = <span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pls</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &lt; P ? a + b : a + b - P;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mns</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a + P - b : a - b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span> * a * b % P;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span> </span>&#123;<span class="type">int</span> ret = <span class="number">1</span>; <span class="keyword">for</span>(; n; n &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a)) <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = <span class="built_in">mul</span>(ret, a); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="type">int</span> _g[<span class="number">2</span>][MAXN], tf, tr[MAXN], inv[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bas; i++) &#123;</span><br><span class="line">		_g[<span class="number">1</span>][i] = <span class="built_in">qpow</span>(G, (P<span class="number">-1</span>) / bas * i);</span><br><span class="line">		_g[<span class="number">0</span>][i] = <span class="built_in">qpow</span>(invG, (P<span class="number">-1</span>) / bas * i);</span><br><span class="line">	&#125;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) inv[i] = <span class="built_in">mul</span>(P - P/i, inv[P % i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getlim</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lim = <span class="number">1</span>; <span class="keyword">for</span>(; lim &lt; n + n; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tpre</span><span class="params">(<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tf == lim) <span class="keyword">return</span> ;</span><br><span class="line">	tf = lim; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? (lim &gt;&gt; <span class="number">1</span>) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span> lim, <span class="type">int</span> fl)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">tpre</span>(lim); <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) <span class="keyword">if</span>(i &lt; tr[i]) <span class="built_in">swap</span>(f[i], f[tr[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">2</span>, k = <span class="number">1</span>; l &lt;= lim; l &lt;&lt;= <span class="number">1</span>, k &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i += l) </span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; i+k; j++) &#123;</span><br><span class="line">				<span class="type">int</span> tt = <span class="built_in">mul</span>(f[j+k], _g[fl][bas / l * (j-i)]);</span><br><span class="line">				f[j+k] = <span class="built_in">mns</span>(f[j], tt);</span><br><span class="line">				f[j] = <span class="built_in">pls</span>(f[j], tt);</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">if</span>(!fl) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) f[i] = <span class="built_in">mul</span>(f[i], inv[lim]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span>* h, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN], b[MAXN];</span><br><span class="line">	<span class="type">int</span> lim = <span class="built_in">getlim</span>(n);</span><br><span class="line">	<span class="built_in">cpy</span>(f, a, n); <span class="built_in">clr</span>(a, n, lim);</span><br><span class="line">	<span class="built_in">cpy</span>(g, b, n); <span class="built_in">clr</span>(b, n, lim);</span><br><span class="line">	<span class="built_in">NTT</span>(a, lim, <span class="number">1</span>); <span class="built_in">NTT</span>(b, lim, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) h[i] = <span class="built_in">mul</span>(a[i], b[i]);</span><br><span class="line">	<span class="built_in">NTT</span>(h, lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, f[MAXN], g[MAXN];</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	Mul(f, f, g, n);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 1 1 1 1</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="任意模数nttmtt">任意模数NTT（MTT）</h2>
<p><a href="https://www.luogu.com.cn/problem/P4245">P4245
【模板】任意模数多项式乘法</a></p>
<blockquote>
<p>给 2 个多项式 <span class="math inline">\(F(x),G(x)\)</span>, 求
<span class="math inline">\(F(x)G(x)\)</span>. 系数对 <span
class="math inline">\(p\)</span> 取模, 不保证 <span
class="math inline">\(p\)</span> 是 NTT 模数.</p>
</blockquote>
<p>也就是MTT, 使用 4 次 FFT 完成任意模数的多项式乘法.</p>
<p>设 <span class="math inline">\(K=2^{15}\)</span>,
我们把多项式每项系数分为两部分（高低位）.<br />
<span class="math display">\[
F(x)=K\cdot F_1(x)+F_0(x)
\\
G(x)=K\cdot G_1(x)+G_0(x)
\\
\therefore
F(x)G(x)=K^2\cdot F_1(x)G_1(x)+K\cdot
[F_1(x)G_0(x)+F_0(x)G_1(x)]+F_0(x)G_0(x)
\]</span> 如何快速得到这四个多项式的点值表示？</p>
<p>构造 <span class="math display">\[
P(x)=F_0(x)+iG_0(x)
\\
Q(x)=F_0(x)-iG_0(x)
\]</span> 我们惊奇地发现: <span class="math display">\[
\mathrm{DFT}(P)[j]=P(w_n^j)=F_0(w_n^j)+iG_0(w_n^j)
\\
=\sum_{k=0}^{n-1}F_0[k]w_n^{kj}+i\sum_{k=0}^{n-1}G_0[k]w_n^{kj}
\\
=\sum_{k=0}^{n-1}(F_0[k]+iG_0[k])(\cos(\dfrac {2\pi
kj}{n})+i\sin(\dfrac{2\pi kj}n))
\\
=\sum_{k=0}^{n-1}(F_0[k]\cos(\dfrac{2\pi kj}n)-G_0[k]\sin(\dfrac {2\pi
kj}n))+\\
i\sum_{k=0}^{n-1}(F_0[k]\sin(\dfrac {2\pi kj}n)+G_0[k]\sin(\dfrac {2\pi
kj}n))
\]</span></p>
<p>同理 <span class="math display">\[
\mathrm{DFT}(Q)[n-j]=P(w_n^{-j})=F_0(w_n^{-j})-iG_0(w_n^{-j})
\\
=\sum_{k=0}^{n-1}F_0[k]w_n^{-kj}-i\sum_{k=0}^{n-1}G_0[k]w_n^{-kj}
\\
=\sum_{k=0}^{n-1}(F_0[k]-iG_0[k])(\cos(\dfrac {2\pi
kj}{n})-i\sin(\dfrac{2\pi kj}n))
\\
=\sum_{k=0}^{n-1}(F_0[k]\cos(\dfrac{2\pi kj}n)-G_0[k]\sin(\dfrac {2\pi
kj}n))+\\
i\sum_{k=0}^{n-1}(F_0[k]\sin(\dfrac {2\pi kj}n)+G_0[k]\sin(\dfrac {2\pi
kj}n))
\]</span> 故 <span class="math inline">\(P\)</span> 的第 <span
class="math inline">\(j\)</span> 项点值与 <span
class="math inline">\(Q\)</span> 的第 <span
class="math inline">\(n-j\)</span> 项点值共轭.</p>
<p>于是我们可以使用 1 次 FFT 得到 <span
class="math inline">\(P(x)\)</span> 和 <span
class="math inline">\(Q(x)\)</span> 的点值, 再解方程就可得到 <span
class="math inline">\(F_0(x)\)</span> 和 <span
class="math inline">\(G_0(x)\)</span> 的点值.</p>
<p>同样地可得到 <span class="math inline">\(F_1(x),G_1(x)\)</span>,
使用了 2 次FFT.</p>
<p>然后考虑怎么求解 回系数.</p>
<p>构造 <span class="math display">\[
P(x)=F_1(x)G_1(x)+i(F_1(x)G_0(x)+F_0(x)G_1(x))
\\
Q(x)=F_0(x)G_0(x)
\]</span> 做两次 IDFT 即可.</p>
<p>下面是与上面相对的另一个板子. 如果要把其它多项式运算运用到任意模数下,
要求把所有的乘法用 Mul 代替.</p>
<blockquote>
<p>检验方法: 同上</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> clr(f, s, t) memset(f + (s), 0x00, sizeof(int) * ((t) - (s)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpy(f, g, n) memcpy(g, f, sizeof(int) * (n))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">5</span>, bas = <span class="number">1</span> &lt;&lt; <span class="number">19</span>;</span><br><span class="line"><span class="type">const</span> db PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pls</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b &lt; P ? a + b : a + b - P;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mns</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a + P - b : a - b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span> * a * b % P;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span> </span>&#123;<span class="type">int</span> ret = <span class="number">1</span>; <span class="keyword">for</span>(; n; n &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a)) <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = <span class="built_in">mul</span>(ret, a); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cp</span> &#123;db x, y;&#125;;</span><br><span class="line">cp <span class="keyword">operator</span> + (<span class="type">const</span> cp&amp; a, <span class="type">const</span> cp&amp; b) &#123;<span class="keyword">return</span> (cp)&#123;a.x + b.x, a.y + b.y&#125;;&#125;</span><br><span class="line">cp <span class="keyword">operator</span> - (<span class="type">const</span> cp&amp; a, <span class="type">const</span> cp&amp; b) &#123;<span class="keyword">return</span> (cp)&#123;a.x - b.x, a.y - b.y&#125;;&#125;</span><br><span class="line">cp <span class="keyword">operator</span> * (<span class="type">const</span> cp&amp; a, <span class="type">const</span> cp&amp; b) &#123;<span class="keyword">return</span> (cp)&#123;a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x&#125;;&#125;</span><br><span class="line">cp <span class="keyword">operator</span> * (<span class="type">const</span> cp&amp; a, <span class="type">const</span> db&amp; k) &#123;<span class="keyword">return</span> (cp)&#123;a.x * k, a.y * k&#125;;&#125;</span><br><span class="line"><span class="type">const</span> cp I = (cp)&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">cp _g[<span class="number">2</span>][MAXN];</span><br><span class="line"><span class="type">int</span> tr[MAXN], tf;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bas; i++) &#123;</span><br><span class="line">		db a = <span class="built_in">cos</span>(<span class="number">2</span> * PI * i / bas), b = <span class="built_in">sin</span>(<span class="number">2</span> * PI * i / bas);</span><br><span class="line">		_g[<span class="number">1</span>][i] = (cp)&#123;a, b&#125;;</span><br><span class="line">		_g[<span class="number">0</span>][i] = (cp)&#123;a, -b&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getlim</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lim = <span class="number">1</span>; <span class="keyword">for</span>(; lim &lt; n + n; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tpre</span><span class="params">(<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tf == lim) <span class="keyword">return</span>;</span><br><span class="line">	tf = lim; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? (lim &gt;&gt; <span class="number">1</span>) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">tran</span><span class="params">(db x)</span> </span>&#123;<span class="keyword">return</span> ((ll)(x &gt; <span class="number">0</span> ? x + <span class="number">.5</span> : x - <span class="number">.5</span>) % P + P) % P;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(cp* f, <span class="type">int</span> lim, <span class="type">int</span> fl)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">tpre</span>(lim); <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) <span class="keyword">if</span>(i &lt; tr[i]) <span class="built_in">swap</span>(f[i], f[tr[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">2</span>, k = <span class="number">1</span>; l &lt;= lim; l &lt;&lt;= <span class="number">1</span>, k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i += l)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; i+k; j++) &#123;</span><br><span class="line">				cp tt = f[j+k] * _g[fl][(j-i) * (bas / l)];</span><br><span class="line">				f[j+k] = f[j] - tt;</span><br><span class="line">				f[j] = f[j] + tt;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">if</span>(!fl) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) f[i].x /= lim, f[i].y /= lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span>* h, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> cp f0[MAXN], f1[MAXN], g0[MAXN], g1[MAXN];</span><br><span class="line">	<span class="type">int</span> lim = <span class="built_in">getlim</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f0[i].x = f[i] &gt;&gt; <span class="number">15</span>, f0[i].y = f[i] &amp; <span class="number">32767</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) g0[i].x = g[i] &gt;&gt; <span class="number">15</span>, g0[i].y = g[i] &amp; <span class="number">32767</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &lt; lim; i++) f0[i] = (cp)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &lt; lim; i++) g0[i] = (cp)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">FFT</span>(f0, lim, <span class="number">1</span>); <span class="built_in">FFT</span>(g0, lim, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">		f1[i] = f0[i ? lim - i : <span class="number">0</span>], f1[i].y *= <span class="number">-1</span>;</span><br><span class="line">		g1[i] = g0[i ? lim - i : <span class="number">0</span>], g1[i].y *= <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">		cp a = (f0[i] + f1[i]) * <span class="number">0.5</span>;		<span class="comment">//f0</span></span><br><span class="line">		cp b = (f1[i] - f0[i]) * <span class="number">0.5</span> * I;	<span class="comment">//f1</span></span><br><span class="line">		cp c = (g0[i] + g1[i]) * <span class="number">0.5</span>;		<span class="comment">//g0</span></span><br><span class="line">		cp d = (g1[i] - g0[i]) * <span class="number">0.5</span> * I;	<span class="comment">//g1</span></span><br><span class="line">		f0[i] = a * c + I * (a * d + b * c);</span><br><span class="line">		g0[i] = b * d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FFT</span>(f0, lim, <span class="number">0</span>); <span class="built_in">FFT</span>(g0, lim, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		h[i] = (<span class="number">1ll</span> * <span class="built_in">tran</span>(f0[i].x) * (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) + <span class="number">1ll</span> * <span class="built_in">tran</span>(f0[i].y) * (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) % P + <span class="built_in">tran</span>(g0[i].x)) % P;</span><br><span class="line">	<span class="built_in">clr</span>(h, n, lim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式乘法逆">多项式乘法逆</h2>
<p><a href="https://www.luogu.com.cn/problem/P4238">P4238
【模板】多项式乘法逆</a></p>
<blockquote>
<p>已知 <span class="math inline">\(F(x)\)</span>, 要求 <span
class="math inline">\(G(x)\)</span>, 使得 <span
class="math inline">\(F(x)G(x)\equiv 1\pmod {x^n}\)</span></p>
<p>保证 <span class="math inline">\(F[0]\ne 0\)</span>. 系数对
998244353取模.</p>
</blockquote>
<p>我们采用倍增的思想.</p>
<p>假设我们已知多项式 <span class="math inline">\(G_0(x)\)</span>
满足:</p>
<p><span class="math display">\[
G_0(x)F(x)\equiv 1\pmod{x^{n/2}}​
\]</span> 又 <span class="math display">\[
G(x)F(x)\equiv 1\pmod {x^{n/2}}​
\]</span> 则由于 <span class="math inline">\(F(x)\not\equiv
0\pmod{x^{n/2}}\)</span>, 作差得</p>
<p><span class="math display">\[
G(x)-G_0(x)\equiv 0\pmod{x^{n/2}}​
\]</span> 平方得</p>
<p><span class="math display">\[
G^2(x)-2G_0(x)G(x)+G_0^2(x)\equiv 0\pmod{x^n}​
\]</span> 则 <span class="math display">\[
G^2(x)\equiv 2G_0(x)G(x)-G_0^2(x)\pmod {x^n}
\]</span> 两边同乘 <span class="math inline">\(F(x)\)</span> ,由于 <span
class="math inline">\(G(x)F(x)\equiv 1\pmod {x^n}\)</span>, 得</p>
<p><span class="math display">\[
G(x)\equiv 2G_0(x)-F(x)G_0^2(x)\equiv G_0(x)[2-F(x)G_0(x)]\pmod {x^n}​
\]</span> 这就是递归计算式了. 使用NTT转成点值进行计算.</p>
<p>最后的终止条件为 <span class="math inline">\(F[0]\equiv
(G[0])^{-1}\)</span>.</p>
<p><strong>多项式有逆的充要条件是常数项有乘法逆. </strong></p>
<p>时间复杂度:</p>
<p><span class="math display">\[
T(n)=T(n/2)+O(n\log n)​\\
T(n)=O(n\log n)​
\]</span></p>
<blockquote>
<p>检验方法:</p>
<p>求 <span class="math inline">\(1-x\)</span> 的逆为 <span
class="math inline">\(\dfrac 1 {1-x}=1+x+x^2+\cdots\)</span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inv</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN];</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;g[<span class="number">0</span>] = <span class="built_in">qpow</span>(f[<span class="number">0</span>], P<span class="number">-2</span>); <span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="built_in">Inv</span>(f, g, (n<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>); <span class="type">int</span> lim = <span class="built_in">getlim</span>(n);</span><br><span class="line">	<span class="built_in">clr</span>(g, (n<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>, lim);</span><br><span class="line">	<span class="built_in">cpy</span>(f, a, n); <span class="built_in">clr</span>(a, n, lim);</span><br><span class="line">	<span class="built_in">NTT</span>(a, lim, <span class="number">1</span>); <span class="built_in">NTT</span>(g, lim, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) g[i] = <span class="built_in">mul</span>(g[i], <span class="built_in">mns</span>(<span class="number">2</span>, <span class="built_in">mul</span>(a[i], g[i])));</span><br><span class="line">	<span class="built_in">NTT</span>(g, lim, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, f[MAXN], g[MAXN];</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	Inv(f, g, n);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 998244352 0 0 0</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">1 1 1 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多项式除法-取模">多项式除法 &amp; 取模</h2>
<p><a href="https://www.luogu.com.cn/problem/P4512">P4512
【模板】多项式除法</a></p>
<blockquote>
<p>已知 <span class="math inline">\(n\)</span> 次多项式 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(m\)</span> 次多项式 <span
class="math inline">\(G(x)\)</span> , 求 <span
class="math inline">\(Q(x)\)</span>, <span
class="math inline">\(R(x)\)</span> 满足</p>
<ol type="1">
<li><span class="math inline">\(Q(x)\)</span> 的度数为 <span
class="math inline">\(n-m\)</span>, <span
class="math inline">\(R(x)\)</span> 的度数 <span
class="math inline">\(&lt;m\)</span></li>
<li><span class="math inline">\(F(x)=Q(x)G(x)+R(x)\)</span></li>
</ol>
<p>对 998244353 取模</p>
</blockquote>
<p>不妨就认为 <span class="math inline">\(\mathrm{deg}\
R(x)=m-1\)</span>, 最高位用 <span class="math inline">\(0\)</span>
补齐.</p>
<p>定义 <span class="math inline">\(A_T(x)=x^{\mathrm{deg}\
A(x)}A(\dfrac 1 x)\)</span>, 可以发现 <span
class="math inline">\(A_T(x)\)</span> 就是把 <span
class="math inline">\(A(x)\)</span> 的系数反过来的多项式.</p>
<p>故有 <span class="math display">\[
F(\dfrac 1x)=Q(\dfrac 1x)G(\dfrac 1 x)+R(\dfrac 1x)
\\
x^nF(\dfrac 1x)=x^{n-m}Q(\dfrac 1x)\cdot x^mG(\dfrac 1x)+x^{n-m+1}\cdot
x^{m-1}R(\dfrac 1x)
\\
F_T(x)=Q_T(x)G_T(x)+x^{n-m+1}R_T(x)
\\
F_T(X)=Q_T(x)G_T(x) \pmod{x^{n-m+1}}
\\
Q_T(x)=\dfrac {F_T(x)}{G_T(x)}\pmod {x^{n-m+1}}
\]</span> 又由于 <span class="math inline">\(\mathrm{deg}\
Q(x)=n-m&lt;n-m+1\)</span>, 所以得到的结果是正确的.</p>
<p>然后 <span class="math inline">\(R(x)=F(x)-Q(x)G(x)\)</span>.</p>
<p>（特别注意: 代码中的 <span class="math inline">\(n,m\)</span>
指的是度数而不是界！！！）</p>
<blockquote>
<p>检验方法: 除一除就好了嘛!</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Div</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span>* q, <span class="type">int</span>* r, <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN], b[MAXN];</span><br><span class="line">	<span class="type">int</span> lim = <span class="built_in">getlim</span>(n<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">cpy</span>(g, a, m<span class="number">+1</span>); <span class="built_in">reverse</span>(a, a+m<span class="number">+1</span>); <span class="built_in">clr</span>(a, m<span class="number">+1</span>, lim);</span><br><span class="line">	<span class="built_in">Inv</span>(a, b, n-m<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">cpy</span>(f, a, n<span class="number">+1</span>); <span class="built_in">reverse</span>(a, a+n<span class="number">+1</span>); <span class="built_in">clr</span>(a, n<span class="number">+1</span>, lim);</span><br><span class="line">	<span class="built_in">Mul</span>(a, b, q, n-m<span class="number">+1</span>); <span class="built_in">reverse</span>(q, q+n-m<span class="number">+1</span>); <span class="built_in">clr</span>(q, n-m<span class="number">+1</span>, lim);</span><br><span class="line">	<span class="built_in">Mul</span>(g, q, a, m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) r[i] = <span class="built_in">mns</span>(f[i], a[i]);</span><br><span class="line">	<span class="built_in">clr</span>(r, m, lim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, m, f[MAXN], g[MAXN], q[MAXN], r[MAXN];</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read(); m = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt;= n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt;= m; i++) g[i] = read();</span></span><br><span class="line"><span class="comment">	Div(f, g, q, r, n, m);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt;= n-m; i++) printf(&quot;%d &quot;, q[i]);</span></span><br><span class="line"><span class="comment">	printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt;= m-1; i++) printf(&quot;%d &quot;, r[i]);</span></span><br><span class="line"><span class="comment">	printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 2 1</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多项式ln">多项式ln</h2>
<p><a href="https://www.luogu.com.cn/problem/P4725">P4725
【模板】多项式对数函数（多项式 ln）</a></p>
<blockquote>
<p>已知 <span class="math inline">\(F(x)\)</span>, 求 <span
class="math inline">\(G(x)\equiv\ln F(x)\pmod{x^n}\)</span>.</p>
<p>保证 <span class="math inline">\(F[0]=1\)</span>. 对 998244353
取模</p>
</blockquote>
<p>这怎么求呢？我们可以先求微, 得 <span class="math display">\[
dG(x)\equiv d\ln F(x)\equiv \dfrac{F&#39;(x)dx}{F(x)}\pmod{x^{n}}​
\]</span> 再两边积分得 <span class="math display">\[
G(x)\equiv\ln F(x)\equiv\int_0^x\dfrac{F&#39;(x)dx}{F(x)}\pmod {x^n}
\]</span> 而 <span class="math inline">\(G[0]\equiv  \ln
F[0]\)</span>.</p>
<p>当 <span class="math inline">\(F[0]=1\)</span> 时, <span
class="math inline">\(G[0]\equiv0\)</span>;</p>
<p>当 <span class="math inline">\(F[0]\ne 1\)</span> 时, <span
class="math inline">\(G[0]\equiv \ln a(a\ne 1\wedge a\in\mathbb
N_+)\not\in \mathbb Q\)</span>, 在模意义下没有意义.</p>
<p>这也是题目要保证 <span class="math inline">\(F[0]=1\)</span>
的原因.</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span></p>
<blockquote>
<p>检验方法:</p>
<p>求 <span class="math inline">\(1-x\)</span> 的对数为 <span
class="math inline">\(-\sum_{k\ge 1}\dfrac {x^k} k\)</span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Deriv</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) g[i<span class="number">-1</span>] = <span class="built_in">mul</span>(f[i], i);</span><br><span class="line">	g[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Integ</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) g[i] = <span class="built_in">mul</span>(f[i<span class="number">-1</span>], inv[i]);</span><br><span class="line">	g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ln</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN], b[MAXN];</span><br><span class="line">	<span class="type">int</span> lim = <span class="built_in">getlim</span>(n);</span><br><span class="line">	<span class="built_in">Deriv</span>(f, a, n); <span class="built_in">clr</span>(a, n, lim);</span><br><span class="line">	<span class="built_in">Inv</span>(f, b, n); <span class="built_in">clr</span>(b, n, lim);</span><br><span class="line">	<span class="built_in">NTT</span>(a, lim, <span class="number">1</span>); <span class="built_in">NTT</span>(b, lim, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) a[i] = <span class="built_in">mul</span>(a[i], b[i]);</span><br><span class="line">	<span class="built_in">NTT</span>(a, lim, <span class="number">0</span>); <span class="built_in">Integ</span>(a, g, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, f[MAXN], g[MAXN];</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	Ln(f, g, n);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, qpow(g[i], P-2));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 998244352 0 0 0</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">0 998244352 998244351 998244350 998244349 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="泰勒展开">泰勒展开</h2>
<p>在进入 exp 前, 我们先来看看泰勒展开 &amp;牛顿迭代</p>
<p>对于一个函数 <span class="math inline">\(f(x)\)</span>,
我们可以利用其在 <span class="math inline">\(x=x_0\)</span>
处的多阶导函数的值来多项式逼近 <span
class="math inline">\(f(x)\)</span>. <span class="math display">\[
f(x)=f(x_0)+\dfrac{f&#39;(x_0)}{1!}(x-x_0)+\dfrac{f&#39;&#39;(x_0)}{2!}(x-x_0)^2+\cdots+\dfrac{f^{(n)}(x_0)}{n!}(x-x_0)^n+\cdots
\]</span> 怎么理解？我们不妨让右边那串为 <span
class="math inline">\(g(x)\)</span>, 验证可知: <span
class="math display">\[
f(x_0)=g(x_0)\\
f&#39;(x_0)=g&#39;(x_0)\\
\cdots\\
f^{(n)}(x_0)=g^{(n)}(x_0)\\
\cdots
\]</span> 这就叫 "逼近".</p>
<h2 id="牛顿迭代多项式复合求根">牛顿迭代（多项式复合求根）</h2>
<blockquote>
<p>已知 <span class="math inline">\(G(x)\)</span>, 求 <span
class="math inline">\(F(x)\)</span>使 <span
class="math inline">\(G(F(x))\equiv 0\pmod {x^n}\)</span></p>
</blockquote>
<p>考虑使用倍增法. 假如我们已经知道了 <span
class="math inline">\(G(F_0(x))\equiv 0\pmod {x^{n/2}}\)</span>.</p>
<p>将 <span class="math inline">\(G(F(x))\)</span> 在 <span
class="math inline">\(F(x)=F_0(x)\)</span> 处泰勒展开, 有</p>
<p><span class="math display">\[
G(F(x))=G(F_0(x))+G&#39;(F_0(x))(F(x)-F_0(x))+\dfrac{G&#39;&#39;(F_0(x))}{2!}(F(x)-F_0(x))^2+\cdots​
\]</span> 又因为</p>
<p><span class="math display">\[
G(F(x))\equiv 0\pmod {x^n})\\
\mathrm{and}\\
F(x)-F_0(x)\equiv0\pmod {x^{n/2}}\\\Rightarrow(F(x)-F_0(x))^2\equiv
0\pmod {x^n}​
\]</span> 代入得 <span class="math display">\[
0\equiv G(F_0(x))+G&#39;(F_0(x))(F(x)-F_0(x))\pmod {x^n}​
\]</span> 移项得 <span class="math display">\[
F(x)\equiv F_0(x)-\dfrac{G(F_0(x))}{G&#39;(F_0(x))}\pmod {x^n}​
\]</span> 这便是递推公式.</p>
<h2 id="多项式exp">多项式exp</h2>
<blockquote>
<p>已知 <span class="math inline">\(F(x)\)</span>, 求 <span
class="math inline">\(G(x)\equiv\exp F(x)\pmod {x^n}\)</span></p>
<p>保证 <span class="math inline">\(F[0]=0\)</span>.</p>
</blockquote>
<p>直接求并不好求, 我们不妨先取对数.</p>
<p><span class="math display">\[
\ln G(x)-F(x)\equiv0\pmod{x^n}​
\]</span> 直接套用牛顿迭代, 令 <span class="math inline">\(H(X)=\ln
X-F(x)\)</span>.</p>
<p>则求解 <span class="math display">\[
H(G(x))\equiv 0\pmod {x^n}​
\]</span> 则有</p>
<p><span class="math display">\[
G(x)\equiv G_0(x)-\dfrac{H(G_0(x))}{H&#39;(G_0(x))}\\
\equiv G_0(x)-G_0(x)[\ln G_0(x)-F(x)]\\
\equiv G_0(x)[1-\ln G_0(x)+F(x)]
\]</span> 而又有 <span class="math inline">\(G[0]\equiv
\exp{F[0]}\)</span>.</p>
<p>可以递归求解. 看起来很麻烦, 但时间复杂度还是 <span
class="math inline">\(O(n\log n)\)</span> （虽然比较慢）.</p>
<p>类似地, 由于 <span class="math inline">\(G[0]\equiv \exp
F[0]\)</span>, 当 <span class="math inline">\(F[0]\ne 0\)</span>
时在模意义下无意义, 所以题目保证了 <span
class="math inline">\(F[0]=0\)</span>.</p>
<blockquote>
<p>检验方法:</p>
<p>求 <span class="math inline">\(x\)</span> 的 指数为 <span
class="math inline">\(\sum_{k\ge 0}\dfrac{x^k}{k!}\)</span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exp</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN];</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;g[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="built_in">Exp</span>(f, g, (n<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>); <span class="type">int</span> lim = <span class="built_in">getlim</span>(n);</span><br><span class="line">	<span class="built_in">clr</span>(g, (n<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>, lim);</span><br><span class="line">	<span class="built_in">Ln</span>(g, a, n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = <span class="built_in">mns</span>(f[i], a[i]);</span><br><span class="line">	a[<span class="number">0</span>] = <span class="built_in">pls</span>(a[<span class="number">0</span>], <span class="number">1</span>); <span class="built_in">clr</span>(a, n, lim);</span><br><span class="line">	<span class="built_in">NTT</span>(a, lim, <span class="number">1</span>); <span class="built_in">NTT</span>(g, lim, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++) g[i] = <span class="built_in">mul</span>(a[i], g[i]);</span><br><span class="line">	<span class="built_in">NTT</span>(g, lim, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, f[MAXN], g[MAXN];</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	Exp(f, g, n);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, qpow(g[i], P-2));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0 1 0 0 0</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">1 1 2 6 24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多项式快速幂-1">多项式快速幂 1</h2>
<p><a href="https://www.luogu.com.cn/problem/P5245">P5245
【模板】多项式快速幂</a></p>
<blockquote>
<p>已知 <span class="math inline">\(F(x)\)</span>, 求 <span
class="math inline">\(G(x)\equiv F^k(x)\pmod {x^n}\)</span></p>
<p><strong>保证</strong> <span
class="math inline">\(F[0]=1\)</span>.</p>
<p>答案对 998244353 取模</p>
</blockquote>
<p>我们根据对数恒等式, <span class="math display">\[
F^k(x)\equiv\exp(k\ln F(x))
\]</span> 先求<span class="math inline">\(\ln\)</span>, 再做数乘,
再求<span class="math inline">\(\exp\)</span> 即可. 时间复杂度 <span
class="math inline">\(O(n\log n)\)</span>. 常数巨大.</p>
<p>从这里我们也知道了, 多项式快速幂不符合费马小定理, 指数应当 <span
class="math inline">\(\mod P\)</span> 才对.</p>
<h2 id="多项式快速幂-2">多项式快速幂 2</h2>
<p><a href="https://www.luogu.com.cn/problem/P5273">P5273
【模板】多项式幂函数 (加强版)</a></p>
<blockquote>
<p>已知 <span class="math inline">\(F(x)\)</span>, 求 <span
class="math inline">\(G(x)\equiv F^k(x)\)</span>, 对 998244353 取模.</p>
</blockquote>
<p>如果 <span class="math inline">\(F[0]\equiv 1\)</span>,
那么直接仿照上面计算即可. 如果<span class="math inline">\(F[0]\not\equiv
1\)</span>, 则需要进行一些转化.</p>
<p>找到 <span class="math inline">\(F(x)\)</span> 的第一项非零项 <span
class="math inline">\(a_tx^t\)</span> , 把其提出, 得到</p>
<p><span class="math inline">\(F(x)\equiv a_tx^tH(x)\)</span>, 其中
<span class="math inline">\(H[n]\equiv\dfrac {F[n+t]}{a_k}\)</span>.</p>
<p>则 <span class="math inline">\(G(x)\equiv F^k(x)\equiv
a_t^kx^{tk}H^k(x)\)</span></p>
<p><span class="math inline">\(H^k(x)\)</span> 再如上计算即可.
值得注意的是, <span class="math inline">\(H^k(x)\)</span> 的 <span
class="math inline">\(k\)</span> 应 <span class="math inline">\(\bmod
P\)</span>, 而 <span class="math inline">\(a_t^k\)</span> 中的 <span
class="math inline">\(k\)</span> 应 <span class="math inline">\(\bmod
\varphi(P)\)</span></p>
<p>代码极丑:</p>
<blockquote>
<p>检验方法:</p>
<p>找一个多项式随便平方一下吧.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qpow</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n, <span class="type">int</span> k1, <span class="type">int</span> k2, <span class="type">bool</span> out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//k1 表示 k mod P, k2 表示 k mod \phi(P), out 表示 k 是否取过模. </span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN];</span><br><span class="line">	<span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(k1 == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">clr</span>(g, <span class="number">0</span>, n); g[<span class="number">0</span>] = <span class="built_in">qpow</span>(f[<span class="number">0</span>], k2);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(shift &lt; n &amp;&amp; !f[shift]) shift++;</span><br><span class="line">	<span class="keyword">if</span>((shift &amp;&amp; out) || <span class="number">1ll</span> * shift * k1 &gt;= n) &#123;</span><br><span class="line">		<span class="built_in">clr</span>(g, <span class="number">0</span>, n);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> in = <span class="built_in">qpow</span>(f[shift], P<span class="number">-2</span>), t = <span class="built_in">qpow</span>(f[shift], k2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i] = i + shift &lt; n ? <span class="built_in">mul</span>(f[i + shift], in) : <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Ln</span>(f, a, n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = <span class="built_in">mul</span>(a[i], k1);</span><br><span class="line">	<span class="built_in">Exp</span>(a, f, n);</span><br><span class="line">	shift *= k1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i] = i - shift &gt;= <span class="number">0</span> ? <span class="built_in">mul</span>(f[i - shift], t) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char sk[MAXL];</span></span><br><span class="line"><span class="comment">int n, f[MAXN], g[MAXN], len, out;</span></span><br><span class="line"><span class="comment">ll k1, k2;</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read(); scanf(&quot;%s&quot;, sk+1); len = strlen(sk+1);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	for(int i = 1; i &lt;= len; i++) &#123;</span></span><br><span class="line"><span class="comment">		k1 = k1 * 10 + int(sk[i] - &#x27;0&#x27;);</span></span><br><span class="line"><span class="comment">		if(k1 &gt;= P) k1 %= P, out = 1;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for(int i = 1; i &lt;= len; i++) &#123;</span></span><br><span class="line"><span class="comment">		k2 = k2 * 10 + int(sk[i] - &#x27;0&#x27;);</span></span><br><span class="line"><span class="comment">		if(k2 &gt;= P-1) k2 %= P-1, out = 1;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Qpow(f, g, n, k1, k2, out);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">10 3</span></span><br><span class="line"><span class="comment">0 1 1 1 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">0 0 0 1 3 6 7 6 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多项式开根">多项式开根</h2>
<p><a href="https://www.luogu.com.cn/problem/P5205">P5205
【模板】多项式开根</a></p>
<p><a href="https://www.luogu.com.cn/problem/P5277">P5277
【模板】多项式开根（加强版）</a></p>
<blockquote>
<p>已知 <span class="math inline">\(F(x)\)</span>, 求 <span
class="math inline">\(G(x)\equiv \sqrt{F(x)}\pmod {x^n}\)</span>.</p>
<p>保证 <span class="math inline">\(F[0]\)</span>
是模998244353意义下的二次剩余.</p>
<p>答案对 998244353 取模</p>
</blockquote>
<p>你当然可以向下面讲到的多项式快速幂一样计算, 但是那样太慢.</p>
<p>原式化为<span class="math inline">\(G^2(x)-F(x)\equiv 0\pmod
{x^n}\)</span></p>
<p>牛顿迭代可得 <span class="math display">\[
G(x)\equiv G_0(x)-\dfrac{G^2_0(x)-F(x)}{2G_0(x)}\equiv
\dfrac{G_0(x)}2+\dfrac{F(x)}{2G_0(x)}​
\]</span> 递归终点是 <span class="math display">\[
G[0]\equiv \sqrt{F[0]}\pmod p​
\]</span> 这里给出加强版的代码（其中<code>Sqrt_P::solve(n)</code> 是求
<span class="math inline">\(n\)</span> 的 <a
href="https://blog.csdn.net/qq_41996523/article/details/113797568">二次剩余</a>）.</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span></p>
<blockquote>
<p>检验方法:</p>
<p>求一个多项式的平方根.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Sqrt_P &#123;</span><br><span class="line">	<span class="type">int</span> a, I2;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">F2</span> &#123;<span class="type">int</span> x, y;&#125;;</span><br><span class="line">	F2 <span class="keyword">operator</span> * (<span class="type">const</span> F2&amp; a, <span class="type">const</span> F2&amp; b) &#123;<span class="keyword">return</span> (F2)&#123;<span class="built_in">pls</span>(<span class="built_in">mul</span>(a.x, b.x), <span class="built_in">mul</span>(<span class="built_in">mul</span>(a.y, b.y), I2)), <span class="built_in">pls</span>(<span class="built_in">mul</span>(a.x, b.y), <span class="built_in">mul</span>(a.y, b.x))&#125;;&#125;</span><br><span class="line">	<span class="function">F2 <span class="title">qpow2</span><span class="params">(F2 a, <span class="type">int</span> n)</span> </span>&#123;F2 ret = (F2)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;; <span class="keyword">for</span>(; n; n &gt;&gt;= <span class="number">1</span>, a = a * a) <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = a * ret;  <span class="keyword">return</span> ret;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		n %= P;</span><br><span class="line">		<span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">qpow</span>(n, (P<span class="number">-1</span>) / <span class="number">2</span>) == P<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			a = <span class="built_in">rand</span>() % P;</span><br><span class="line">			I2 = <span class="built_in">mns</span>(<span class="built_in">mul</span>(a, a), n);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">qpow</span>(I2, (P<span class="number">-1</span>) / <span class="number">2</span>) == P<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ret = <span class="built_in">qpow2</span>((F2)&#123;a, <span class="number">1</span>&#125;, (P<span class="number">+1</span>) / <span class="number">2</span>).x;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(ret, P-ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sqrt</span><span class="params">(<span class="type">int</span>* f, <span class="type">int</span>* g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[MAXN], b[MAXN];</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;g[<span class="number">0</span>] = Sqrt_P::<span class="built_in">solve</span>(f[<span class="number">0</span>]); <span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="built_in">Sqrt</span>(f, g, (n<span class="number">+1</span>) &gt;&gt; <span class="number">1</span>); <span class="type">int</span> lim = <span class="built_in">getlim</span>(n);</span><br><span class="line">	<span class="built_in">clr</span>(g, (n<span class="number">+1</span>) &gt;&gt; <span class="number">1</span>, lim);</span><br><span class="line">	<span class="built_in">cpy</span>(f, a, n); <span class="built_in">clr</span>(a, n, lim);</span><br><span class="line">	<span class="built_in">Inv</span>(g, b, n); <span class="built_in">clr</span>(b, n, lim);</span><br><span class="line">	<span class="built_in">Mul</span>(a, b, a, n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i] = <span class="built_in">mul</span>(inv[<span class="number">2</span>], <span class="built_in">pls</span>(g[i], a[i]));</span><br><span class="line">	<span class="built_in">clr</span>(g, n, lim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, f[MAXN], g[MAXN];</span></span><br><span class="line"><span class="comment">void test() &#123;</span></span><br><span class="line"><span class="comment">	n = read();</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) f[i] = read();</span></span><br><span class="line"><span class="comment">	Sqrt(f, g, n);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4 8 4</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2 2 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Maths</tag>
        <tag>Computer Science</tag>
        <tag>Generation Function</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 CCPC Guilin 解题报告</title>
    <url>/posts/9d9ffb80/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/103409">比赛链接</a></p>
<span id="more"></span>
<h1 id="a---a-hero-named-magnus">A - A Hero Named Magnus</h1>
<p>显然答案为 <span class="math inline">\(2x-1\)</span>.</p>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		cout &lt;&lt; <span class="number">2</span> * x - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="b---a-plus-b-problem">B - A Plus B Problem</h1>
<p>两个加数的变换位数是显然的. 接下来考虑和的变换位数.</p>
<p>对于每一位, 定义 <span class="math inline">\(C_i\)</span>
为是否有来自低位的进位, 则 <span
class="math inline">\(S_i=(A_i+B_i+C_i)\bmod 10\)</span>.</p>
<p>要考虑和数的变换位数, 将作了改动的第 <span
class="math inline">\(c\)</span> 列单独处理, 这个只要知道 <span
class="math inline">\(C_c\)</span> 即可判断.</p>
<p>对于不在 <span class="math inline">\(c\)</span> 列的列, <span
class="math inline">\(S_i\)</span> 变换等价于 <span
class="math inline">\(C_i\)</span> 发生变换. 于是只要维护 <span
class="math inline">\(C_i\)</span> 的总数即可在 <span
class="math inline">\(O(1)\)</span> 时间内得到 <span
class="math inline">\(S_i(i\ne c)\)</span> 变换位数. 具体地, 是 <span
class="math inline">\(|\Delta\text{总进位数}| - [C_c \text{
变化}]\)</span>.</p>
<p>那么怎么维护 <span class="math inline">\(C_i\)</span> 的总数呢?
学过数逻计组的话可能会知道, 一个位置有 <span
class="math inline">\(C_i\)</span> 等价于存在 <span
class="math inline">\(j\ge i\)</span> 满足 <span
class="math inline">\(x\in \lbrace i+1, i+2, \cdots, j-1\rbrace\)</span>
都是 <span class="math inline">\(A_x+B_x= 9\)</span> 且 <span
class="math inline">\(A_j+B_j\ge 10\)</span>.
(这里认为下标大的是低位).</p>
<p>于是可以用 set 维护所有 <span class="math inline">\(A_i+B_i\ge
10\)</span> 的位置作为"发射源", 然后用树状数组维护 <span
class="math inline">\(A_i+B_i=9\)</span> 的位置的前缀和,
每次二分得到发射源向左可以到达最远的 <span
class="math inline">\(A_i+B_i=9\)</span> 段的边界, 于是可以借此维护.
总复杂度 <span class="math inline">\(O((n+q)\log ^2 n)\)</span>.</p>
<blockquote>
<p>其实直接用 set 维护所有 <span class="math inline">\(A_i+B_i\ne
9\)</span> 的位置, 容易做到 <span class="math inline">\(O((n+q)\log
n)\)</span>.</p>
</blockquote>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[MAXN], b[MAXN], x[MAXN], ccnt;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">	<span class="type">int</span> t[MAXN], s[MAXN];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			s[i] = s[i<span class="number">-1</span>] + x[i];</span><br><span class="line">			t[i] = s[i] - s[i - <span class="built_in">lowbit</span>(i)];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">			t[i] += v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">			ret += t[i];</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(y) - <span class="built_in">sum</span>(x<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mdy</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = pos.<span class="built_in">lower_bound</span>(c<span class="number">+1</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == pos.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">return</span> n + <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> pw = *it;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">1</span>, r = pw - <span class="number">1</span>, ret = pw;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		<span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (BIT::<span class="built_in">sum</span>(m, pw<span class="number">-1</span>) == pw<span class="number">-1</span>-m<span class="number">+1</span>) &#123;</span><br><span class="line">			r = m - <span class="number">1</span>;</span><br><span class="line">			ret = m;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l = m + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ccnt += (pw - <span class="number">1</span> - ret + <span class="number">1</span> + (ret != <span class="number">1</span>)) * v;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v == <span class="number">9</span>) &#123;</span><br><span class="line">		BIT::<span class="built_in">add</span>(c, <span class="number">-1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">		<span class="built_in">mdy</span>(c<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">		pos.<span class="built_in">erase</span>(pos.<span class="built_in">find</span>(c));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enable</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v == <span class="number">9</span>) &#123;</span><br><span class="line">		BIT::<span class="built_in">add</span>(c, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">		pos.<span class="built_in">insert</span>(c);</span><br><span class="line">		<span class="built_in">mdy</span>(c<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> r, c, d;</span><br><span class="line">	cin &gt;&gt; r &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="type">int</span> lccnt = ccnt;</span><br><span class="line">	<span class="type">int</span> ori_c = (c &gt;= <span class="built_in">mdy</span>(c, <span class="number">-1</span>) - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ori = a[c] + b[c];</span><br><span class="line">	<span class="built_in">cancel</span>(c, ori);</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">1</span>)</span><br><span class="line">		a[c] = d;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		b[c] = d;</span><br><span class="line">	<span class="type">int</span> nwv = a[c] + b[c];</span><br><span class="line">	<span class="built_in">enable</span>(c, nwv);</span><br><span class="line">	<span class="type">int</span> nwv_c = (c &gt;= <span class="built_in">mdy</span>(c, <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">abs</span>(ccnt - lccnt) - (ori_c != nwv_c) + ((ori + ori_c) % <span class="number">10</span> != (nwv + nwv_c) % <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; (nwv + nwv_c) % <span class="number">10</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans+ (nwv != ori) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		cin &gt;&gt; ch;</span><br><span class="line">		a[i] = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		cin &gt;&gt; ch;</span><br><span class="line">		b[i] = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> s = a[i] + b[i];</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="number">9</span>)</span><br><span class="line">			x[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			pos.<span class="built_in">insert</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	BIT::<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> c : pos)</span><br><span class="line">		<span class="built_in">mdy</span>(c<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">		<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="c---ac-automatonundone">C - AC Automaton(UNDONE)</h1>
<h1 id="d---assumption-is-all-you-need">D - Assumption is All You
Need</h1>
<p align="center">
<b>做法1</b>
</p>
<p>一个结论: 从值为 <span class="math inline">\(n\)</span>
的元素到从值为 <span class="math inline">\(1\)</span> 的元素,
一个一个按照以下的规律挪动:</p>
<p>假设挪动的元素 <span class="math inline">\(v\)</span> 要从原位置
<span class="math inline">\(x\)</span> 挪到目标位置 <span
class="math inline">\(y\)</span>.</p>
<ol type="1">
<li>若 <span class="math inline">\(x&gt;y\)</span>, 那么无解;</li>
<li>若 <span class="math inline">\(x\le y\)</span>, 那么从 <span
class="math inline">\([x+1, y]\)</span> 区间中找到小于 <span
class="math inline">\(v\)</span> 的元素中最大的一个 <span
class="math inline">\(v&#39;\)</span>, 然后把 <span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(v&#39;\)</span> 交换, 直到 <span
class="math inline">\(x=y\)</span>.</li>
</ol>
<p>单次上述过程可以用一个单调栈 <span
class="math inline">\(O(n)\)</span> 完成, 总时间复杂度 <span
class="math inline">\(O(n^2)\)</span>.</p>
<p>这个贪心可以发现是对的: 每个元素会被尽力提前,
优先提前比较大的元素不会丧失比较小的元素的成功可能性.</p>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pr = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[MAXN], b[MAXN], p[MAXN], fp[MAXN];</span><br><span class="line"><span class="type">int</span> stk[MAXN], _stk;</span><br><span class="line">vector&lt;pr&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = p[v], y = fp[v];</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	stk[_stk = <span class="number">1</span>] = x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = x<span class="number">+1</span>; i &lt;= y; i++) </span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; v) &#123;</span><br><span class="line">			<span class="keyword">while</span> (_stk &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[stk[_stk]])</span><br><span class="line">				--_stk;</span><br><span class="line">			stk[++_stk] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= _stk; i++) &#123;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(<span class="built_in">pr</span>(stk[i<span class="number">-1</span>], stk[i]));</span><br><span class="line">		<span class="built_in">swap</span>(p[a[stk[i<span class="number">-1</span>]]], p[a[stk[i]]]);</span><br><span class="line">		<span class="built_in">swap</span>(a[stk[i<span class="number">-1</span>]], a[stk[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">			p[a[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; b[i];</span><br><span class="line">			fp[b[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">work</span>(i)) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">				<span class="keyword">goto</span> END;</span><br><span class="line">			&#125;</span><br><span class="line">		cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) &#123;</span><br><span class="line">			cout &lt;&lt; i.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">END:</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p align="center">
<b>做法2</b>
</p>
<p>题解的做法: 找到最小的使得 <span class="math inline">\(A_p\ne
B_p\)</span> 的位置 <span class="math inline">\(p\)</span>, <span
class="math inline">\(q\)</span> 为最小的满足 <span
class="math inline">\(q&gt;p\)</span> 且 <span
class="math inline">\(A_p&gt; A_q\ge B_p\)</span> 的位置 <span
class="math inline">\(q\)</span>, 交换 <span
class="math inline">\(A_p\)</span> 和 <span
class="math inline">\(A_q\)</span>, 重复操作直到不可以操作为止.
有解当且仅当这种方法是可行解.</p>
<p>这个证明感觉不是很显然...之后再想.</p>
<h1 id="e---buy-and-delete">E - Buy and Delete</h1>
<p>容易发现答案不超过 <span class="math inline">\(2\)</span> (比如,
一次删去 <span class="math inline">\(u&lt;v\)</span> 的边, 一次删除
<span class="math inline">\(u&gt;v\)</span> 的边).</p>
<ol type="1">
<li>如果任意一条边的权值比钱数 <span class="math inline">\(c\)</span>
大, 那么答案为 <span class="math inline">\(0\)</span>.</li>
<li>否则, 答案为 <span class="math inline">\(1\)</span> 或 <span
class="math inline">\(2\)</span>. 设图中最小环的权值是 <span
class="math inline">\(k\)</span>, 如果 <span class="math inline">\(c\ge
k\)</span> 即可以买下一个有向环, 那么答案为 <span
class="math inline">\(2\)</span>; 否则答案为 <span
class="math inline">\(1\)</span>.</li>
</ol>
<p>故只需要求解图的最小环, 可以使用 <span
class="math inline">\(n\)</span> 次 Dijkstra 算法得到任意两点间的距离
<span class="math inline">\(dist(u, v)\)</span>, 那么最小环的权值为
<span class="math display">\[
  \sum_{(u, v, w)\in E}(w+dist(v, u)).
\]</span> 时间复杂度 <span class="math inline">\(O(n(n+m)\log
m)\)</span>.</p>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pr = pair&lt;ll, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll LINF = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> v, nxt, w;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"><span class="type">int</span> cnt, head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	e[++cnt] = &#123;v, head[u], w&#125;;</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dist[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SSSP</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">	priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt; &gt; pq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dist[s][i] = LINF;</span><br><span class="line">		vis[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[s][s] = <span class="number">0</span>;</span><br><span class="line">	pq.<span class="built_in">push</span>(<span class="built_in">pr</span>(<span class="number">0</span>, s));</span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (vis[u])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">			<span class="keyword">if</span> (dist[s][v] &gt; dist[s][u] + w) &#123;</span><br><span class="line">				dist[s][v] = dist[s][u] + w;</span><br><span class="line">				pq.<span class="built_in">push</span>(<span class="built_in">pr</span>(dist[s][v], v));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">	<span class="type">int</span> mnw = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		<span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">		mnw = <span class="built_in">min</span>(mnw, w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mnw &gt; c) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">SSSP</span>(i);</span><br><span class="line">	ll ret = LINF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">			ret = <span class="built_in">min</span>(ret, w + dist[v][u]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; c)</span><br><span class="line">		cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="f---illuminations-ii">F - Illuminations II</h1>
<p>求解在外部多边形上任意一个点上可以看到内部多边形的长度的期望.
容易发现对于内部的每条边, 要么完全看不到, 要么完全看不到.
于是利用期望的可加性,
而每条边上的贡献是它的长度乘以它延长线所截的右边外多边形长度所占周长的比例.
所以只要对内部每条边求解它延长线所截的右边外多边形的长度,
这可以用双指针完成. 时间复杂度 <span
class="math inline">\(O(n+m)\)</span>.</p>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getint</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ssum=<span class="number">0</span>,ff=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">for</span>(ch=<span class="built_in">getchar</span>();!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>;ch=<span class="built_in">getchar</span>());</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) ff=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=<span class="built_in">getchar</span>()) ssum=ssum*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> ssum*ff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps = <span class="number">1e-10</span>, inf = <span class="number">1e10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : (x &gt; eps ? <span class="number">1</span> : <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function">db <span class="title">Abs</span><span class="params">(db x)</span> </span>&#123;<span class="keyword">return</span> x * <span class="built_in">dcmp</span>(x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pnt</span> &#123;</span><br><span class="line">	db x, y;</span><br><span class="line">	<span class="built_in">Pnt</span>(db x = <span class="number">0</span>, db y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> Vec = Pnt;</span><br><span class="line"><span class="function">db <span class="title">Dot</span><span class="params">(<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x * b.x + a.y * b.y;&#125;</span><br><span class="line"><span class="function">db <span class="title">Cro</span><span class="params">(<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x * b.y - a.y * b.x;&#125;</span><br><span class="line"><span class="function">db <span class="title">Len</span><span class="params">(<span class="type">const</span> Vec &amp;a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(a, a));&#125;</span><br><span class="line">Vec <span class="keyword">operator</span> + (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123;<span class="keyword">return</span> <span class="built_in">Vec</span>(a.x + b.x, a.y + b.y);&#125;</span><br><span class="line">Vec <span class="keyword">operator</span> - (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123;<span class="keyword">return</span> <span class="built_in">Vec</span>(a.x - b.x, a.y - b.y);&#125;</span><br><span class="line">Vec <span class="keyword">operator</span> * (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> db &amp;b) &#123;<span class="keyword">return</span> <span class="built_in">Vec</span>(a.x * b, a.y * b);&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123;<span class="keyword">return</span> !<span class="built_in">dcmp</span>(a.x - b.x) &amp;&amp; !<span class="built_in">dcmp</span>(a.y - b.y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pnt <span class="title">CrossPoint</span><span class="params">(<span class="type">const</span> Pnt &amp;a, <span class="type">const</span> Pnt &amp;b, <span class="type">const</span> Pnt &amp;c, <span class="type">const</span> Pnt &amp;d)</span> </span>&#123;</span><br><span class="line">	Vec ab = b-a, cd = d-c, ca = a-c;</span><br><span class="line">	<span class="keyword">return</span> a + ab * (<span class="built_in">Cro</span>(cd, ca) / <span class="built_in">Cro</span>(ab, cd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">righthand</span><span class="params">(<span class="type">const</span> Pnt &amp;a, <span class="type">const</span> Pnt &amp;b, <span class="type">const</span> Pnt &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dcmp</span>(<span class="built_in">Cro</span>(p-a, b-a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Poly = vector&lt;Pnt&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _out, _in, s, t;</span><br><span class="line">Poly out, in;</span><br><span class="line">vector&lt;db&gt; dis;</span><br><span class="line">db nowans, circ, ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> q = p + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q == _in) q = <span class="number">0</span>;</span><br><span class="line">	db ret = nowans;</span><br><span class="line">	<span class="type">int</span> sn = s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (sn == _out) sn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tp = t - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (tp &lt; <span class="number">0</span>) tp = _out - <span class="number">1</span>;</span><br><span class="line">	Pnt a = <span class="built_in">CrossPoint</span>(in[p], in[q], out[s], out[sn]);</span><br><span class="line">	ret += <span class="built_in">Len</span>(out[sn]-a);</span><br><span class="line">	Pnt b = <span class="built_in">CrossPoint</span>(in[p], in[q], out[tp], out[t]);</span><br><span class="line">	ret += <span class="built_in">Len</span>(b-out[tp]);</span><br><span class="line">	ans += <span class="built_in">Len</span>(in[q] - in[p]) * (ret / circ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> q = p + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q == _in) q = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sn = s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (sn == _out) sn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">righthand</span>(in[p], in[q], out[sn]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		nowans -= dis[sn];</span><br><span class="line">		s = sn;</span><br><span class="line">		sn = s + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (sn == _out) sn = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">righthand</span>(in[p], in[q], out[t]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tp = t - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (tp &lt; <span class="number">0</span>) tp = _out - <span class="number">1</span>;</span><br><span class="line">		nowans += dis[tp];</span><br><span class="line">		t++;</span><br><span class="line">		<span class="keyword">if</span> (t == _out) t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;_out, &amp;_in);</span><br><span class="line">	out.<span class="built_in">resize</span>(_out);</span><br><span class="line">	in.<span class="built_in">resize</span>(_in);</span><br><span class="line">	dis.<span class="built_in">resize</span>(_out);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _out; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		x=<span class="built_in">getint</span>();y=<span class="built_in">getint</span>();</span><br><span class="line">		out[i].x = x; out[i].y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _in; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		x=<span class="built_in">getint</span>();y=<span class="built_in">getint</span>();</span><br><span class="line">		in[i].x = x; in[i].y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _out; i++) &#123;</span><br><span class="line">		<span class="type">int</span> j = i<span class="number">+1</span>;</span><br><span class="line">		<span class="keyword">if</span> (j == _out) j = <span class="number">0</span>;</span><br><span class="line">		dis[i] = <span class="built_in">Len</span>(out[j] - out[i]);</span><br><span class="line">		circ += dis[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _out; i++) &#123;</span><br><span class="line">		<span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (j == _out) j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">righthand</span>(in[<span class="number">0</span>], in[<span class="number">1</span>], out[i]) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">righthand</span>(in[<span class="number">0</span>], in[<span class="number">1</span>], out[j]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			s = i;</span><br><span class="line">			t = j;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">		<span class="type">int</span> nxt = t + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (nxt == _out) nxt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">righthand</span>(in[<span class="number">0</span>], in[<span class="number">1</span>], out[t]) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">righthand</span>(in[<span class="number">0</span>], in[<span class="number">1</span>], out[nxt]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nowans += dis[t];</span><br><span class="line">		&#125;</span><br><span class="line">		t = nxt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">calc</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; _in; i++) &#123;</span><br><span class="line">		<span class="built_in">adjust</span>(i);</span><br><span class="line">		<span class="built_in">calc</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n&quot;</span>, (<span class="type">double</span>)ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="g---occupy-the-cities">G - Occupy the Cities</h1>
<p>容易发现, 如果迭代 <span class="math inline">\(k\)</span> 次,
那么原位置在 <span class="math inline">\(x\)</span> 的一个 1 可以扩展到
<span class="math inline">\([x-k, x+k-1]\)</span> 或 <span
class="math inline">\([x-k+1, x+k]\)</span>. 所以可以 <span
class="math inline">\(O(n)\)</span> 判定: 贪心地从左到右"连接",
尽量选择后者. 于是可以在 <span class="math inline">\(O(n\log n)\)</span>
的时间内二分+判定解决.</p>
<blockquote>
<p>将上述算法稍加修改, 用动态规划算法即可在 <span
class="math inline">\(O(n)\)</span> 内解决.</p>
</blockquote>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lst = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">			<span class="type">int</span> le, ri;</span><br><span class="line">			<span class="keyword">if</span> (lst + <span class="number">1</span> &gt;= i - k + <span class="number">1</span>) &#123;</span><br><span class="line">				le = i - k + <span class="number">1</span>;</span><br><span class="line">				ri = i + k;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				le = i - k;</span><br><span class="line">				ri = i + k - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (lst + <span class="number">1</span> &lt; le)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			lst = ri;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> lst &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cin &gt;&gt; (s<span class="number">+1</span>);</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			++cnt;</span><br><span class="line">	<span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> L = <span class="number">1</span>, R = n, ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">		<span class="type">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(M)) &#123;</span><br><span class="line">			ans = M;</span><br><span class="line">			R = M - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			L = M + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">		<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="h---popcount-wordsundone">H - Popcount Words(UNDONE)</h1>
<h1 id="i---ptsd">I - PTSD</h1>
<p>一个简单的贪心.</p>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, tot;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tot &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				ans += i;</span><br><span class="line">				tot--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tot++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">		<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="j---suffix-automatonundone">J - Suffix Automaton(UNDONE)</h1>
<h1 id="k---tax">K - Tax</h1>
<p>容易发现, 在 Dijkstra 后形成一个分层 DAG (按照离起点 <span
class="math inline">\(1\)</span> 的最短距离分层,仅层间有边),
合法的路径必定是该分层 DAG 上的一条路径. 一个结论是: <span
class="math inline">\(n\)</span> 个点的这样的分层 DAG,
搜素所有路径的复杂度是 <span class="math inline">\(O(3^{n/3})\)</span>
的.</p>
<blockquote>
<p>一个简要的证明: 假设分为 <span class="math inline">\(k\)</span> 层,
每层的节点数一次为 <span class="math inline">\(c_1, c_2, \cdots,
c_k\)</span>, 那么搜素所有路径的时间是不超过 <span
class="math display">\[
\prod_{1\le i\le k}c_i, \text{when } \sum_{1\le i\le k} c_i=n
\]</span> 的. 那么也就最大化前者. 根据均值不等式, 当 <span
class="math inline">\(c_1=c_2=\cdots =c_k=t\)</span> 时, 前者最大,
所以得到前者不超过 <span class="math display">\[
t^{k}=t^{n/t}, (t\in \mathbb N^+)
\]</span> 次, 即 <span class="math inline">\(e^{n\ln t/t}\)</span>. 而
<span class="math inline">\(\ln t/ t\)</span> 在 <span
class="math inline">\(t=3\)</span> 时取得最大值, 故最大值为 <span
class="math inline">\(3^{n/3}\)</span>.</p>
</blockquote>
<details>
<summary>
<b>代码</b>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXM = <span class="number">2505</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll lINF = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[MAXM];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> v, nxt, c;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[++cnt] = &#123;v, head[u], c&#125;; </span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[MAXN], vis[MAXN], num[MAXM];</span><br><span class="line">ll dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v;</span><br><span class="line">			<span class="keyword">if</span> (vis[v])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			vis[v] = <span class="number">1</span>;</span><br><span class="line">			que.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll nowans)</span> </span>&#123;</span><br><span class="line">	dist[u] = <span class="built_in">min</span>(dist[u], nowans);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v = e[i].v, c = e[i].c;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		num[c]++;</span><br><span class="line">		<span class="built_in">dfs</span>(v, nowans + num[c] * w[c]);</span><br><span class="line">		num[c]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v, c;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">		<span class="built_in">addedge</span>(u, v, c);</span><br><span class="line">		<span class="built_in">addedge</span>(v, u, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		dist[i] = lINF;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="l---wiring-engineeringundone">L - Wiring
Engineering(UNDONE)</h1>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>XCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（二） Open Topic III 笔记</title>
    <url>/posts/b0473663/</url>
    <content><![CDATA[<p>选题为 13-2, 讲解 TC Problem 15-3: Bitonic euclidean
traveling-salesman problem.</p>
<span id="more"></span>
<p>演示文稿: 详见 <a href="3.pdf">Slide</a>.</p>
<h1 id="问题引入">问题引入</h1>
<p><strong>双调欧几里得旅行商问题</strong></p>
<p>欧几里得平面上有 <span class="math inline">\(n\)</span> 个点,
每个点的横坐标均不相同, 从最左点沿某路径到达最右点,
再从最右点沿某路径到最左点, 使得除了初始点外, 每个点均恰好被经过一次,
求路径长度的最小值.</p>
<p><img src="BETSP_Ex.png" /></p>
<p>(Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C.
(2022). Introduction to algorithms. MIT press. p405)</p>
<p>形式化地，设每个点按横坐标从小到大排序后重编号为 <span
class="math inline">\(1\)</span> 至 <span
class="math inline">\(n\)</span>. 将序列 <span
class="math inline">\(2..n\)</span> 划分为两个单调递增的序列(可能为空)
<span class="math inline">\(\lbrace a_i\rbrace, 1\le i\le p\)</span> 和
<span class="math inline">\(\lbrace b_i\rbrace, 1\le i\le q\)</span>,
<span class="math inline">\(p+q=n-1\)</span>. 不妨设 <span
class="math inline">\(a_p=n\)</span>, 并另记 <span
class="math inline">\(a_0=b_0=1\)</span>, 求划分方法使得 <span
class="math display">\[
S=\sum_{i=0}^{p-1}d(a_i, a_{i+1})+\sum_{i=0}^{q-1}d(b_i, b_{i+1})+d(b_q,
n)
\]</span> 最小, 其中 <span class="math inline">\(d(u, v)\)</span>
表示编号为 <span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 的两点的欧几里得距离.
后文的讨论基于该转化后问题.</p>
<h1 id="设计动态规划算法">设计动态规划算法</h1>
<p>设 <span class="math inline">\(f[x, y] (x&gt;y\ge 1)\)</span>
表示将序列 <span class="math inline">\(2..x\)</span> 划分成 <span
class="math inline">\(a_{1..p}\)</span> 和 <span
class="math inline">\(b_{1..q}\)</span> 时 <span
class="math inline">\(\displaystyle \sum_{i=0}^{p-1}d(a_i,
a_{i+1})+\sum_{i=0}^{q-1}d(b_i, b_{i+1})\)</span> 的最小值, 满足 <span
class="math inline">\(a_p=x\)</span> 且 <span
class="math inline">\(b_q=y\)</span>. 若 <span
class="math inline">\(y\)</span> 等于 <span
class="math inline">\(1\)</span> 说明 <span
class="math inline">\(b\)</span> 仅含 <span
class="math inline">\(b_0=1\)</span>.</p>
<p>边界条件为 <span class="math inline">\(f[2, 1]=d(1, 2)\)</span>.</p>
<p>分以下两种情况讨论:</p>
<ol type="1">
<li>当 <span class="math inline">\(x-1 &gt; y\ge 1\)</span> 时,
这种情况下 <span class="math inline">\(y+1..x\)</span> 都会属于 <span
class="math inline">\(a_{1..p}\)</span>, 那么去掉 <span
class="math inline">\(x\)</span> 后, 把 <span
class="math inline">\(x-1\)</span> 当成最后的节点, 会形成 <span
class="math inline">\(f[x-1, y]\)</span> 的子问题. 转移方程为</li>
</ol>
<p><span class="math display">\[
  f[x,y]=f[x-1,y]+d(x-1,x).
\]</span></p>
<p><img src="Case1.png" /></p>
<ol start="2" type="1">
<li>当 <span class="math inline">\(x-1=y\ge 2\)</span> 时, 这种情况下
<span class="math inline">\(x\)</span> 一定存在一个小于 <span
class="math inline">\(y\)</span> 的前驱节点 <span
class="math inline">\(u\)</span>, 那么 <span
class="math inline">\(u+1..x-1\)</span> 都是属于 <span
class="math inline">\(b\)</span> 的. 去掉 <span
class="math inline">\(x\)</span> 后, 把 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span> 调换一下, 发现形成了 <span
class="math inline">\(f[x-1, u]\)</span> 的子问题, 转移方程为</li>
</ol>
<p><span class="math display">\[
  f[x, x-1]=\min_{1\le u&lt;x-1}\lbrace f[x-1, u] + d(u, x)\rbrace.
\]</span></p>
<p><img src="Case2.png" /></p>
<p>于是我们得到了完整的状态转移方程为:</p>
<p><span class="math display">\[
\begin{gather*}
  f[2, 1]=d(2, 1);\\
  f[x, y]=f[x-1,y]+d(x, x-1), \text{when } x-1&gt;y\ge 1;\\
  f[x, x-1]=\min_{1\le u&lt;x-1}\lbrace f[x-1, u] + d(u, x)\rbrace,
\text{when } x\ge 3.
\end{gather*}
\]</span></p>
<p>如何统计最终答案?</p>
<p>观察到 <span class="math inline">\(f[n, u](1\le u&lt;n)\)</span> 和
<span class="math inline">\(S\)</span> 仅差一项 <span
class="math inline">\(d(u, n)\)</span>, 于是 <span
class="math display">\[
  S=\min_{1\le u&lt;n}\lbrace f[n, u]+d(u, n)\rbrace.
\]</span></p>
<p>于是我们得到了一个时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>, 空间复杂度为 <span
class="math inline">\(O(n^2)\)</span> 的算法.</p>
<blockquote>
<p>时间复杂度证明:</p>
<p>共有 <span class="math inline">\(\sum_{1\le j&lt;i\le
n}1=\binom{n}{2}=\frac{n(n-1)}{2}\)</span> 种状态, 子问题图的点数为
<span class="math inline">\(|V|=\frac{n(n-1)}{2}\)</span>. 对于 <span
class="math inline">\((x, y), 1\le y\le x-2\)</span> 的状态,
在子问题图中仅有指向 <span class="math inline">\((x-1,y)\)</span>
的一条出边; 对于 <span class="math inline">\((x, x-1), 3\le x\le
n\)</span>, 有指向 <span class="math inline">\((x-1, u), 1\le u \le
x-2\)</span> 共 <span class="math inline">\(x-2\)</span> 条出边.
故总边数为 <span class="math display">\[
|E|=\sum_{x=3}^n\sum_{y=1}^{x-2}1+\sum_{x=3}^n(x-2)=(n-1)(n-2).
\]</span> 故时间复杂度为 <span class="math inline">\(O(|V| +
|E|)=O(n^2)\)</span>.</p>
</blockquote>
<h1 id="优化状态数">优化状态数</h1>
<p>接下来我们尝试对这个动态规划做一些优化, 想办法"压缩"子问题图.
在上面的解法中, 有相当多的状态仅有一条出边,
可以尝试用数学方法缩减状态数量!</p>
<p>对于状态转移方程中的第二项, 可以如下进行推导 <span
class="math display">\[
  \begin{aligned}
    f[x,y]&amp;=f[x-1,y]+d(x, x-1)\\
      &amp;=f[x-2, y]+d(x-1, x-2)+d(x, x-1)\\
      &amp;=\cdots\\
      &amp;=f[y+1, y]+d(y+2, y+1)+\cdots+d(x, x-1)\\
      &amp;=f[y+1, y]+D(x)-D(y+1), \text{when } 1\le y\le x-2.
  \end{aligned}
\]</span> 其中使用了前缀和, <span class="math inline">\(\displaystyle
D(x)=\sum_{i=2}^x d(i, i-1)\)</span>.</p>
<p>把它代入第三项, 有</p>
<p><span class="math display">\[
  \begin{aligned}
    f[x, x-1]&amp;=\min_{1\le u&lt;x-1}\lbrace f[x-1, u]+d(u,
x)\rbrace\\
    &amp;=\min\lbrace f[x-1, x-2], \min_{1\le u&lt;x-2}\lbrace f[u+1,
u]+D(x-1)-D(u+1)+d(u, x)\rbrace\rbrace\\
    &amp;=\min\lbrace f[x-1, x-2], \min_{2\le u\le x-2}\lbrace f[u,
u-1]+D(x-1)-D(u)+d(u-1, x)\rbrace\rbrace\\
    &amp;=\min_{2\le u\le x-1}\lbrace f[u, u-1]+D(x-1)-D(u)+d(u-1,
x)\rbrace, \text{when }x&gt;1.
  \end{aligned}
\]</span></p>
<p>把它代入 <span class="math inline">\(S\)</span>, 同理有</p>
<p><span class="math display">\[
  S=\min_{2\le u\le n}\lbrace f[u, u-1]+D(n)-D(u)+d(u-1, n)\rbrace.
\]</span></p>
<p>作代换 <span class="math inline">\(g[x]=f[x, x-1], x\ge 2\)</span>,
得到如下新的转移方程</p>
<p><span class="math display">\[
\begin{gather*}
  g[2]=d(2, 1);\\
  g[x]=\min_{2\le u\le x-1}\lbrace g[u]+D(x-1)-D(u)+d(u-1, x)\rbrace,
\text{when }x\ge 3.
\end{gather*}
\]</span></p>
<p>且最终答案 <span class="math display">\[
  S=\min_{2\le u\le n}\lbrace{g[u]+D(n)-D(u)+d(u-1, n)}\rbrace.
\]</span></p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>, 空间复杂度
<span class="math inline">\(O(n)\)</span>.</p>
<h1 id="变种">变种</h1>
<p>我们设计的动态规划算法在 <span class="math inline">\(O(n^2)\)</span>
时间、<span class="math inline">\(O(n)\)</span>
空间内解决了双调欧几里得旅行商问题, 其中空间无法再优化, 已达到最优.</p>
<p>对于时间, 瓶颈在于状态转移的第二个式子,
决策点的得到必须需要枚举所有的 <span class="math inline">\(2\le u\le
x-1\)</span>. 如果可以运用数据结构, 或是具有决策单调性等性质,
快速得到最小值的决策点, 便可以继续优化复杂度. 然而, 在原问题中,
欧几里得距离难以处理, 并且该问题不具有决策单调性的性质,
故笔者暂时没有好的想法.</p>
<p>但若是把欧几里得距离换为曼哈顿距离,
那么可以进一步使用平衡树等数据来优化转移, 可以使得最终的时间复杂度为
<span class="math inline">\(O(n\log n)\)</span>,
与排序的时间复杂度相同.</p>
<p>容易发现, 在曼哈顿距离的情况下, 第二个转移方程可以进一步写为</p>
<p><span class="math display">\[
\begin{aligned}
  g[x]&amp;=D(x-1)+\min_{2\le u\le x-1}\lbrace
g[u]-D(u)+|X_x-X_{u-1}|+|Y_x-Y_{u-1}|\rbrace\\
  &amp;=D(x-1)+X_x+\min_{2\le u\le x-1}\lbrace
g[u]-D(u)-X_{u-1}+|Y_x-Y_{u-1}|\rbrace\\
\end{aligned}
\]</span></p>
<p>分类讨论 <span class="math inline">\(Y_x\)</span> 和 <span
class="math inline">\(Y_{u-1}\)</span> 的关系. 对于 <span
class="math inline">\(Y_{u-1}\le Y_x\)</span> 的, 有 <span
class="math display">\[
  s_1=D(x-1)+X_x+Y_x+\min_{2\le u\le x-1, Y_{u-1}\le Y_x}\lbrace
g[u]-D(u)-X_{u-1}-Y_{u-1}\rbrace
\]</span></p>
<p>同理, 对于 <span class="math inline">\(Y_{u-1}&gt; Y_x\)</span> 的,
有</p>
<p><span class="math display">\[
  s_2=D(x-1)+X_x-Y_x+\min_{2\le u\le x-1, Y_{u-1}&gt; Y_x}\lbrace
g[u]-D(u)-X_{u-1}+Y_{u-1}\rbrace
\]</span></p>
<p>则 <span class="math inline">\(g[x]=\min\lbrace s_1,
s_2\rbrace\)</span>. 可以使用两棵平衡树以 <span
class="math inline">\(Y_i\)</span> 为 <span
class="math inline">\(key\)</span> 维护 <span
class="math inline">\(\min\)</span> 后的值, 从而在 <span
class="math inline">\(O(\log n)\)</span> 时间内得到最小值的决策点并转移.
故总时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h1 id="总结">总结</h1>
<p>本文以双调欧几里得旅行商问题为例, 讲解了其中的动态规划的设计方法,
并进行优化, 最后得到了 <span class="math inline">\(O(n^2)\)</span>
时间复杂度, <span class="math inline">\(O(n)\)</span> 空间复杂度的算法.
并且对变种问题展开讨论, 得到了 <span class="math inline">\(O(n\log
n)\)</span> 时间复杂度的算法.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（二） Open Topic IV 笔记</title>
    <url>/posts/34e7c893/</url>
    <content><![CDATA[<p>选题为 15-1, 讲解 Tarjan 离线 LCA 算法及其的线性改进.</p>
<span id="more"></span>
<p>演示文稿: 详见 <a href="4.pdf">Slide</a>.</p>
<h1 id="常见-lca-算法一览">常见 LCA 算法一览</h1>
<table style="width:100%;">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 38%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">在/离线</th>
<th style="text-align: center;">时间复杂度</th>
<th style="text-align: center;">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">倍增法</td>
<td style="text-align: center;">在线</td>
<td style="text-align: center;"><span class="math inline">\(O(n\log
n)\sim O(\log n)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(n\log
n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">树链剖分法</td>
<td style="text-align: center;">在线</td>
<td style="text-align: center;"><span class="math inline">\(O(n)\sim
O(\log n)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Link Cut Tree 法</td>
<td style="text-align: center;">在线</td>
<td style="text-align: center;"><span class="math inline">\(O(n\log
n)\sim O(\log n)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">RMQ, ST 表</td>
<td style="text-align: center;">在线</td>
<td style="text-align: center;"><span class="math inline">\(O(n\log
n)\sim O(1)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(n\log
n)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Tarjan LCA</strong></td>
<td style="text-align: center;">离线</td>
<td style="text-align: center;"><span
class="math inline">\(O(n+q\alpha(q+n, n))\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(n+q)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Tarjan LCA(改进)</strong></td>
<td style="text-align: center;">离线</td>
<td style="text-align: center;"><span
class="math inline">\(O(n+q)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(n+q)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">标准 RMQ</td>
<td style="text-align: center;">在线</td>
<td style="text-align: center;"><span class="math inline">\(O(n)\sim
O(1)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>其中定义树的节点个数为 <span class="math inline">\(n\)</span>.
在线算法的时间复杂度中, 符号 <span class="math inline">\(O(T_1)\sim
O(T_2)\)</span> 意为, 预处理需要时间 <span
class="math inline">\(O(T_1)\)</span>, 单次在线询问需要时间 <span
class="math inline">\(O(T_2)\)</span>. 离线算法中 <span
class="math inline">\(q\)</span> 为总询问个数. 以上复杂度分析均在 RAM
模型下进行.</p>
<p>另外, <span class="math inline">\(\alpha(m, n)=\min\lbrace i\ge 1:
A_i(\lfloor m/n \rfloor) \ge \log n\rbrace\)</span>, 它关于 <span
class="math inline">\(m\)</span> 递减, 关于 <span
class="math inline">\(n\)</span> 递增.</p>
<p>本文主要介绍 Tarjan 离线 LCA 算法及其改进算法.</p>
<h1 id="tarjan-离线-lca-算法">Tarjan 离线 LCA 算法</h1>
<h2 id="算法流程">算法流程</h2>
<p><img src="LCA-routine.png" /></p>
<h2 id="算法解释">算法解释</h2>
<p><img src="illustration%20of%20the%20algorithm.png" /></p>
<h2 id="算法的简要证明">算法的简要证明</h2>
<p>注意到几个事实:</p>
<ol type="1">
<li>如果 <span class="math inline">\(u\)</span> 为白色而 <span
class="math inline">\(v\)</span> 为黑色, 那么所有以 <span
class="math inline">\(v\)</span> 的祖先到 LCA(<span
class="math inline">\(u, v\)</span>)(不含
LCA)为根的子树都已经合并成了一个连通块(因为它们所在的递归已经完整退出).</li>
<li>LCA(<span class="math inline">\(u, v\)</span>) 还在执行中(因为 <span
class="math inline">\(v\)</span> 是 LCA(<span class="math inline">\(u,
v\)</span>) 的子孙), 故它尚未与它的父亲合并.
由于算法的执行过程保证该连通块的代表元(或者说代码中的 ancestor)
是深度最小的节点, 也就是 LCA.</li>
</ol>
<h2 id="算法时空分析">算法时空分析</h2>
<p>空间复杂度显然为 <span class="math inline">\(O(n+q)\)</span>,
时间复杂度分析如下:</p>
<p><strong>一、上界分析</strong></p>
<p>在每一次的递归过程中, 除去处理询问的部分, 其余部分均花费常数时间.
故累计 <span class="math inline">\(n\)</span> 次递归的时间为 <span
class="math inline">\(O(n)\)</span>; 每次处理询问需调用一次 Find-Set,
单次时间均摊为 <span class="math inline">\(O(\alpha(q+n, n))\)</span>.
故总时间为 <span class="math inline">\(O(n+q\alpha(q+n,
n))\)</span>.</p>
<p><strong>二、下界分析</strong></p>
<p>Tarjan 的一篇论文<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>给出了并查集在最坏情况下的下界是
<span class="math inline">\(\Omega(n+q\alpha(q+n, n))\)</span>.
该下界证明容易拓展到 Tarjan 离线 LCA 算法.</p>
<p>故综上, 该算法时间为 <span class="math inline">\(O(n+q\alpha(q+n,
n))\)</span> 并达到理论最优, 空间为 <span
class="math inline">\(O(n+q)\)</span>.</p>
<h1 id="一种改进到线性的做法">一种改进到线性的做法</h1>
<p>由 Gabow 和 Tarjan 提出<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>.
他们提出了一种并查集方法: 当并查集的 Union 过程事先已知(不要求顺序已知,
只要求操作已知)时, 可以将 <span class="math inline">\(n\)</span>
个点、<span class="math inline">\(q\)</span> 次在线 Find-Set 和 Union
的并查集的复杂度改进成线性 <span
class="math inline">\(O(n+q)\)</span>.</p>
<h2 id="算法描述">算法描述</h2>
<p>由于 Union 关系确定, 可以把需要执行 Union(<span
class="math inline">\(u, v\)</span>) 的元素之间建边,
则可以形成一棵"合并树"(如果 Union(<span class="math inline">\(u,
v\)</span>) 操作少于 <span class="math inline">\(n-1\)</span> 次,
得到的是一个森林, 但不影响我们的讨论). 容易发现, 当我们在讨论 Tarjan
离线 LCA 时, 原树就是合并树.
在合并树上我们的并查集只要求完成两种操作:</p>
<ol type="1">
<li>Union-Tree(<span class="math inline">\(u\)</span>): 把 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(u.p\)</span> 合并到同一个连通块中, 且把原来 <span
class="math inline">\(u.p\)</span>
所在连通块的代表元设置为新连通块的代表元. 每个结点仅可以执行一次,
且不可对根执行.</li>
<li>Find-Tree(<span class="math inline">\(u\)</span>): 查找 <span
class="math inline">\(u\)</span> 所在连通块的代表元.</li>
</ol>
<p>这个算法的主要思想是进行树分块, 在块的<strong>根</strong>之间使用带
<span class="math inline">\(\alpha\)</span> 复杂度的并查集进行维护,
在块内部使用查表得到结果. 利用这种并查集, 可以将 Tarjan 离线 LCA
的理论时间复杂度优化到 <span class="math inline">\(O(n+q)\)</span>.</p>
<p><img src="illustration%20of%20the%20blocks.png" /></p>
<p>每一个块的大小要求小于 <span class="math inline">\(b\)</span>,
是一个森林, 森林中的每一棵树都是原树中的一个连通块,
并且它们深度最低的节点有着公共的父亲, 称作这个块的<strong>根</strong>.
注意根不在该块中.</p>
<p>如果一个结点 <span class="math inline">\(u\)</span> 已经执行过
Union-Tree(<span class="math inline">\(u\)</span>)了,
称它是<strong>被标记</strong>的. 显然被标记的结点无法成为代表元. 那么,
在 Find-Tree(<span class="math inline">\(u\)</span>) 中, 要寻找的是离
<span class="math inline">\(u\)</span> 最近的未被标记的祖先.
这个祖先可能和 <span class="math inline">\(u\)</span> 在同一个块中,
也可能和 <span class="math inline">\(u\)</span> 不在同一个块中.
我们分情况如下:</p>
<h3 id="在块内进行查询">在块内进行查询</h3>
<p>使用 Find-In-Block(<span class="math inline">\(u\)</span>)
查询在块内的 <span class="math inline">\(u\)</span>
的最近未被标记的祖先. 如果没有(即在别的块中), 那么返回块的根.
由于每一块的大小至多为 <span class="math inline">\(b\)</span>,
故不同的块的形状至多为 <span class="math inline">\(b^{b-1}\)</span>
(枚举每一个元素的父亲. 实际上远远小于它,
因为很多情况不能构成合法的森林). 如果用一个二进制数存储, 需要 <span
class="math inline">\(2^{(b-1)\lceil \log b\rceil}\)</span> 位存储. 假设
RAM 的字长 <span class="math inline">\(w=O(\log n)\)</span>,
那么取适当的 <span class="math inline">\(b=O(\log n/\log \log
n)\)</span> 可以使得 <span class="math inline">\((b-1)\lceil \log
b\rceil\le w\)</span>. 那么可以用一个整数存储某个块的父亲状态. 除此以外,
如果得知了每个点是否被标记(有至多 <span
class="math inline">\(2^{b-1}\)</span> 个状态数), 要求的 Find-In-Block
是哪个点 <span class="math inline">\(u\)</span>, 那么可以用一个表
table<span class="math inline">\([0\cdots 2^{(b-1)\lceil \log
b\rceil}-1, 0\cdots 2^{b-1}-1, 1\cdots b-1]\)</span>
事先预处理相应块的答案(注意这个表的三维都可以用整数压缩), 从而在 <span
class="math inline">\(O(1)\)</span> 时间内完成 FInd-In-Block(<span
class="math inline">\(u\)</span>) 操作. 至于空间, 该表的空间需求是 <span
class="math display">\[
    2^{(b-1)\lceil \log b\rceil}\cdot 2^{b-1}\cdot (b-1).
\]</span> 当 <span class="math inline">\(b=O(\log n/\log \log
n)\)</span> 时, 上式是 <span class="math inline">\(O(n)\)</span> 的.
Gabow 和 Tarjan 在文中给出了在时间 <span
class="math inline">\(O(n)\)</span> 内构建该表的算法.</p>
<h3 id="在块间进行查询">在块间进行查询</h3>
<p>当在块内进行查询后返回的结点不在块内(即是它的根)时, 说明在块内找不到
<span class="math inline">\(u\)</span> 未被标记的祖先, 需要进行块间查询.
在<strong>每个块的根</strong>之间建立传统的 <span
class="math inline">\(\alpha\)</span> 并查集, 那么并查集中有 <span
class="math inline">\(O(n/b)\)</span> 个结点.</p>
<p>我们把块间查询算法叫 Find-Across-Block(<span
class="math inline">\(x\)</span>), 其中 <span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(u\)</span> 所在块的根. 方法如下:</p>
<ol type="1">
<li>执行 <span class="math inline">\(x\gets \alpha\)</span>-Find(<span
class="math inline">\(x\)</span>).</li>
<li>执行 <span class="math inline">\(y=\)</span> Find-In-Block(<span
class="math inline">\(x\)</span>). 如果得到的 <span
class="math inline">\(y\)</span> 和 <span
class="math inline">\(x\)</span> 在同一个块, 则返回; 否则, 执行 <span
class="math inline">\(\alpha\)</span>-Union(<span
class="math inline">\(y, x\)</span>), 并让 <span
class="math inline">\(x\gets \alpha-\)</span>Find(<span
class="math inline">\(x\)</span>), 重复执行 <span
class="math inline">\(2\)</span>.</li>
</ol>
<p>这里 <span class="math inline">\(\alpha\)</span> -
并查集的作用是快速排除某段路径:
在已经合并了的块的根之间不会再有没有标记的节点,
从而保证了均摊复杂度.</p>
<p>进行时间复杂度分析, 容易得到复杂度为 <span
class="math inline">\(O((q+O(n/b))\alpha(q+O(n/b),
O(n/b))+O(n/b))=O(q+n)\)</span>, 当 <span
class="math inline">\(b=\Omega(\log \log n)\)</span> 时.</p>
<h3 id="树上合并操作">树上合并操作</h3>
<p>是 <span class="math inline">\(O(1)\)</span> 的,
只需要在块中标记该节点即可.</p>
<h2 id="结论">结论</h2>
<p>在分块中取 <span class="math inline">\(b=\Omega(\log \log n)\)</span>
并 <span class="math inline">\(b=O(\log n/\log \log n)\)</span>,
则可以在 <span class="math inline">\(O(n+q)\)</span> 时间, <span
class="math inline">\(O(n)\)</span> 空间内解决 RAM
模型上的已知结构的在线并查集合并查询问题. 虽然可能并不实用,
但是具有理论价值.</p>
<h1 id="参考文献">参考文献</h1>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://www.sciencedirect.com/science/article/pii/0022000079900424">A
class of algorithms which require nonlinear time to maintain disjoint
sets</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://www.sciencedirect.com/science/article/pii/0022000085900145">A
linear-time algorithm for a special case of disjoint set union, Harold
N. Gabow, Robert Endre Tarjan</a>.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>Install Windows 11 virtual machine on Ubuntu</title>
    <url>/posts/5113700a/</url>
    <content><![CDATA[<p>In order to use Microsoft Office and Wechat on my laptop (the host
system is Ubuntu 22.04.3 LTS), I try to install a Windows 11 virtual
machine.</p>
<span id="more"></span>
<h1 id="tutorial-of-installing">Tutorial of installing</h1>
<p><a
href="https://ivonblog.com/posts/install-windows-11-qemu-kvm-on-linux/">This</a>
is a good-written tutorial.</p>
<h1 id="after-that">After that</h1>
<h2 id="install-spice-guest-tools-to-use-easier">Install
spice-guest-tools to use easier</h2>
<p>It is recommended to install spice guest tools on the guest machine.
This could be found at <a
href="https://www.spice-space.org/download.html"
class="uri">https://www.spice-space.org/download.html</a>, Guest -
Windows binaries - spice-guest-tools.</p>
<h2 id="install-sshfs-to-share-files">Install sshfs to share files</h2>
<p>It is wise to enable the guest machine to connect to the filesystem
of host machine directly. I use sshfs to achieve that. Please refer to
<a href="https://zhuanlan.zhihu.com/p/314245985">This tutorial</a>. The
second way in this post works for me.</p>
<h2 id="activate-the-system">Activate the system</h2>
<p><a
href="https://ivonblog.com/posts/microsoft-activation-scripts/">This</a>
is a good tutorial.</p>
<h2 id="use-cli">Use CLI</h2>
<p>The virt-manager benefits a lot when we install the virtual machine.
However, after that we have some of fancier ways to control the virtual
machines.</p>
<p>We can use <code>virsh list --all</code> to find the info of virtual
machines. Remenber the name of your guest machine. We try to use CLI to
control it.</p>
<ul>
<li><code>virsh start &lt;name&gt;</code>: Start the machine.</li>
<li><code>virsh shutdown &lt;name&gt;</code>: Shutdown the machine.</li>
<li><code>virsh suspend &lt;name&gt;</code>: Suspend the machine.</li>
<li><code>virsh resume &lt;name&gt;</code>: Resume a suspended
machine.</li>
<li><code>virt-viewer &lt;name&gt;</code>: Create a GUI session with the
machine. However, <code>virt-viewer</code> is more powerful than
<code>virt-manager</code>.</li>
</ul>
<p><code>virt-viewer</code> has a banch of shortcuts, for example,
<code>Ctrl+Alt</code> lets you escape from the control of guest machine;
<code>F11</code> toggle the full-screen mode.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It seems that this method to hold virtual machines is more efficient
than Virtual Box or VmWare (just from my point of view).</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 1 笔记</title>
    <url>/posts/19a57e20/</url>
    <content><![CDATA[<p>OT 题目：图在计算机和人工智能研究中有很多应用，例如程序分析中的<a
href="https://en.m.wikipedia.org/wiki/Control-flow_graph">控制流图</a>、信息检索中的<a
href="https://en.wikipedia.org/wiki/Webgraph">网页链接图</a>、知识表示中的<a
href="https://en.wikipedia.org/wiki/Knowledge_graph">知识图谱</a>等，请调研至少2种应用（其中至多1种来自上述例子），描述应用场景，讨论用图建模的方式，形式化描述问题并概述现有解决方案。</p>
<span id="more"></span>
<p><a href="1.pdf">Slide</a></p>
<p>以两个问题入手，分别是：编译系统的构建，以及正则表达式的匹配。</p>
<h1 id="一编译系统的构建">一、编译系统的构建</h1>
<h2 id="编译系统的概念">1.1 编译系统的概念</h2>
<p>当一个项目有着单独一个源文件，编译它是容易的；但是当一个项目有着多个源文件，编译会变得复杂：编译有了先后顺序，有了依赖关系，而且编译需要更多的时间。此时，可以使用一些编译系统来组织和优化编译。<a
href="https://www.gnu.org/software/make/">GNU Make</a>
是一种常见的编译系统。它使用特殊的语法来描述了依赖关系，并且有着智能化的编译控制系统，只编译确实需要编译的文件。</p>
<h2 id="编译系统的建模">1.2 编译系统的建模</h2>
<p>如果把编译系统中的每个需要编译的文件视作有向图 <span
class="math inline">\(G=\langle V, E\rangle\)</span>
中的一个顶点，而边则定义为依赖关系：若编译顶点 <span
class="math inline">\(u\)</span> 需要用到顶点 <span
class="math inline">\(v\)</span> 产生的库文件，则 <span
class="math inline">\(u\)</span> 依赖于 <span
class="math inline">\(v\)</span>，则有 <span class="math inline">\((u,
v)\in E\)</span>。这样，编译系统就被建模为一个有向图。</p>
<p>这个有向图有什么特征呢？它不能有环。因为若存在环 <span
class="math inline">\(u_1\to u_2\to \cdots u_k\to
u_1\)</span>，则对于环上任意一点，不妨是 <span
class="math inline">\(u_1\)</span>，要编译它，它依赖于 <span
class="math inline">\(u_2\)</span> 的结果，进一步依赖于 <span
class="math inline">\(u_3\)</span> 的结果...依次类推，它依赖于 <span
class="math inline">\(u_1\)</span>
的结果，故依赖它需要用到它自己的结果，这是不现实的。</p>
<p>因此，这个图是一个<strong>有向无环图</strong>(directed acyclic graph,
DAG)，它有着很好的性质：在上面动态规划没有后效性（存在拓扑序）。</p>
<p>例如，对于以下一个简单的项目：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/rijuyuezhu/Playground</span><br><span class="line"> ├──a.c</span><br><span class="line"> ├──a.h</span><br><span class="line"> ├──main.c</span><br><span class="line"> ├──main.h</span><br><span class="line"> └──Makefile</span><br></pre></td></tr></table></figure>
<p>其中 Makefile 为</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o a.o</span></span><br><span class="line">	gcc main.o a.o -o main</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c main.h</span></span><br><span class="line">	gcc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">a.o: a.c a.h main.h</span></span><br><span class="line">	gcc -c a.c</span><br></pre></td></tr></table></figure>
<p>其依赖关系图为</p>
<p><img src="3.png" /></p>
<h2 id="gnu-make-的核心工作原理">1.3 GNU Make 的核心工作原理</h2>
<p>GNU Make
根据给定的依赖关系，构建出一个有向无环图，在编译时，先依次编译它依赖的顶点（从它出发可以直接到达的顶点），再编译它自己。</p>
<blockquote>
<p>形式化的问题描述即为：给定 DAG <span class="math inline">\(G=\langle
G, E\rangle\)</span> 和 <span class="math inline">\(u\in
V\)</span>，要求按照正确的编译顺序（依赖顺序）得到 <span
class="math inline">\(u.result\)</span>。</p>
</blockquote>
<p>使用动态规划，可以避免重复编译。此处使用记忆化搜索的方式是高效的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_compiled = [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make</span>(<span class="params">u</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> is_compiled[u]:</span><br><span class="line">    <span class="keyword">for</span> v such that (u, v) <span class="keyword">in</span> E:</span><br><span class="line">      make(v)</span><br><span class="line">    u.result = call_compiler_to_compile([v: <span class="keyword">for</span> v such that (u, v) <span class="keyword">in</span> E])</span><br><span class="line">    is_compiled[u] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>
<h2 id="gnu-make-的智能化编译控制">1.4 GNU Make 的智能化编译控制</h2>
<p>当某个顶点所有的依赖顶点的编译结果的时间戳都未比当前顶点编译结果的时间戳晚，那么说明当前顶点的编译结果已经是最新的了，不需要重新编译。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_compiled = [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make</span>(<span class="params">u</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> is_compiled[u]:</span><br><span class="line">    need_to_compile = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> v such that (u, v) <span class="keyword">in</span> E:</span><br><span class="line">      make(v)</span><br><span class="line">      <span class="keyword">if</span> v.result.time &gt; u.result.time:</span><br><span class="line">        need_to_compile = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> need_to_compile:</span><br><span class="line">      u.result = call_compiler_to_compile([v: <span class="keyword">for</span> v such that (u, v) <span class="keyword">in</span> E])</span><br><span class="line">    is_compiled[u] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在多次编译中有很大的优化效果。</p>
<h2 id="编译系统的本质">1.5 编译系统的本质</h2>
<p>它的图论本质就是<strong>使用有向无环图表达偏序关系</strong>。依赖的本质是偏序关系（反自反性、反对称性、传递性）</p>
<h2 id="其他偏序关系">1.6 其他偏序关系</h2>
<p>例如，软件包管理器管理软件依赖、to do list
进行事情先修条件的组织等，以及更数学的集合的包含关系等，动态规划的状态依赖等都是一种偏序关系，可以使用
DAG 进行建模求解。</p>
<p>如果是全序关系，那么其实可以使用线性表（链）维护。链和树是特殊的图。</p>
<h2 id="扩展-1">1.7 扩展 1</h2>
<p><strong>思考题</strong>：刚刚提到的依赖管理和网络链接图、函数调用关系图（若
<code>A()</code> 调用 <code>B()</code>，建边
<code>A-&gt;B</code>）有什么本质区别？</p>
<blockquote>
<p>答：正如函数递归可以自己调用自己、或者相互递归调用，后两种关系得到的图可能含有有向环，和
DAG 具有许多不同的性质）</p>
</blockquote>
<h2 id="扩展-2">1.8 扩展 2</h2>
<p>除了依赖关系，使用图可以维护更多的关系：比如用有向边代表有向信息；用无向边代表双向信息（例如社交网络中的好友关系）；用带权边代表边独属的信息（例如知识图谱中的不同种类的信息）。</p>
<h2 id="二正则表达式的匹配">二、正则表达式的匹配</h2>
<h2 id="正则表达式和自动机介绍">2.1 正则表达式和自动机介绍</h2>
<p>正则表达式可以用来查找替换识别固定格式的字符串<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>。它使用特殊语法来描述字符串的格式：例如用
<code>[nz]ju</code> 可以匹配 <code>nju</code> 和
<code>zju</code>，<code>wt+qj</code> 可以匹配 <code>wtqj</code>,
<code>wttqj</code>, 可以有任意多个 <code>t</code>。</p>
<p>如果问求一好好学了的话，同学们知道可以用<strong>非确定性有限状态自动机(NFA)</strong>来进行正则表达式（最基础功能，等价与正则语言的）的匹配，比如把匹配到了正则表达式第
<span class="math inline">\(i\)</span> 个字符作为第 <span
class="math inline">\(i\)</span> 个状态。还可以通过进一步的算法将 NFA
转化为 DFA。</p>
<p>有限状态自动机由五大部分组成：<span
class="math inline">\(\Sigma\)</span> 输入字母表；<span
class="math inline">\(S\)</span> 是状态的非空有限集合；<span
class="math inline">\(S_0\)</span> 是初始状态集合；<span
class="math inline">\(\delta\)</span> 是状态转移函数；<span
class="math inline">\(F\)</span>
是终态集合。这种数学模型可以通过图论建模：对于 <span
class="math inline">\(S\)</span> 中的每个元素（即一个状态），都对应于图
<span class="math inline">\(G\)</span> 中的一个顶点；状态转移函数 <span
class="math inline">\(\delta(u, c), c\in \Sigma\)</span> 定义了所有从
<span class="math inline">\(u\)</span>
出发的边。有限状态自动机匹配一个字符串 <span
class="math inline">\(s_0s_1s_2\cdots
s_m\)</span>，看是否存在一个状态列表 <span class="math inline">\(\langle
u_0, u_1, \cdots ,u_{m+1}\rangle\)</span>，使得 <span
class="math inline">\(u_0\in S_0\)</span>, <span
class="math inline">\(\delta(u_0, s_0)=u_1\)</span>, <span
class="math inline">\(\delta(u_1, s_1)=u_2\)</span>, ...， <span
class="math inline">\(\delta(u_m, s_m)=u_{m+1}\)</span>, <span
class="math inline">\(u_{m+1}\in F\)</span>。如果是 NFA，允许 <span
class="math inline">\(\varepsilon\)</span>
移动。于是，就可以把正则表达式转化为 NFA 来进行字符串匹配。对于长度为
<span class="math inline">\(n\)</span> 的正则表达式去匹配长度为 <span
class="math inline">\(m\)</span> 的字符串，时间复杂度 <span
class="math inline">\(O(nm)\)</span>；如果进一步转化为 DFA，时间复杂度
<span class="math inline">\(O(m)\)</span>，但是需要的空间可能是 <span
class="math inline">\(O(2^n)\)</span> 的。</p>
<p>例如，正则表达式 <code>[nz]ju</code> 构造的状态机为</p>
<p><img src="4.png" /></p>
<p>正则表达式 <code>wt+qj</code> 构造的状态机为</p>
<p><img src="5.png" /></p>
<h2 id="自动机相关算法">2.2 自动机相关算法</h2>
<p>有限状态自动机是一个特殊的图，可以用特殊的算法来进行处理。例如，由于
DFA 和 NFA 的等价性，存在算法将 NFA 转化为 DFA；DFA
最小化相关算法可以优化 DFA 的存储。另外，由于 FSA 的特殊性，可以在 FSA
上进行动态规划（无后效性来自于，考虑字符串的匹配位数 <span
class="math inline">\(i\)</span>，则顶点的状态只依赖与 <span
class="math inline">\(i-1\)</span> 时所有顶点的状态）。</p>
<p>比如，用 NFA 进行字符串匹配时，就可以使用动态规划，用 <span
class="math inline">\(f[i, j], 1\le i\le m, 1\le j\le n\)</span>
表示匹配字符串的前 <span class="math inline">\(i\)</span>
个字符是否可以到达自动机的状态 <span
class="math inline">\(j\)</span>。状态转移方程由 <span
class="math inline">\(f[i-1, \cdot]\)</span> 转移到 <span
class="math inline">\(f[i, \cdot]\)</span>。转移方程略，需要注意 NFA
可能的 <span class="math inline">\(\varepsilon\)</span> 转移。</p>
<h2 id="其他自动机相关的应用">2.3 其他自动机相关的应用</h2>
<p>例如，现代计算机是一个有限状态自动机，可以利用
<code>&lt;存储器值1, 存储器值2, ..., 存储器值m&gt;</code>
（包括计数器，寄存器，缓存，RAM
等）的二进制序列来编码自动机的每一个状态；而匹配的字符串则是外界输入。因为现代计算机的内存是有限的，没有无限长的纸带，所以不等价与确定性图灵机。</p>
<p>再例如，在数字逻辑与计算机组成课里，对于时序逻辑电路的设计，使用了确定性有限状态自动机来建模状态的切换。从这个角度，时序逻辑电路也是一个状态机（但是并不是返回
Y/N，而是每次转移都有输出）。</p>
<p>当然，自动机用得最多的可能还是在字符串理论中，很多算法依赖于一些特殊的自动机（如
Aho–Corasick algorithm，Suffix
automaton）等等。这些算法在字符串问题中应用广泛。</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://zh.wikipedia.org/zh-hans/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"
class="uri">https://zh.wikipedia.org/zh-hans/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 2 笔记</title>
    <url>/posts/972a79c3/</url>
    <content><![CDATA[<p>OT：在DFS和BFS的基础上，形成了很多扩展的搜索算法，例如<a
href="https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search">词典序BFS</a>、<a
href="https://en.wikipedia.org/wiki/Bidirectional_search">双向搜索</a>、<a
href="https://en.wikipedia.org/wiki/Best-first_search">最佳优先搜索</a>等，请调研至少2种扩展搜索算法（其中至多1种来自上述例子），讨论适用场景，结合例子介绍算法的设计与分析，与DFS或BFS比较异同并分析优劣。</p>
<span id="more"></span>
<p><a href="2.pdf">slide</a></p>
<h1 id="一步步改造-bfs">一步步改造 BFS</h1>
<h2 id="bfs-本身可以解决的问题-5">BFS 本身可以解决的问题 <a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></h2>
<p>首先分析 BFS
本身可以解决的问题，主要是无权图上的最短路问题。为了方便起见，我们只考虑两点
<span class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 之间的最短路问题。设 <span
class="math inline">\(g(u)\)</span> 表示从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(u\)</span> 的距离。BFS
的算法正确性的核心在于所维护的队列的 <span
class="math inline">\(g(u)\)</span>
单调不减性。实际上，对于一切的<strong>一致代价搜索</strong>，s正确性的根本保证在于它维护了一个优先队列。</p>
<blockquote>
<p>一致代价搜索(UCS)：</p>
<p>定理：在<strong>非负权图</strong>中，维护一个优先队列（一开始只有
<span class="math inline">\(s\)</span>），关键词是 <span
class="math inline">\(g(u)\)</span>。每次取出其中关键词最小的点，然后更新其邻点的距离，若更新则入队（注意：不影响原队列中的关键词），第一次
<span class="math inline">\(t\)</span> 出队时，<span
class="math inline">\(g(t)\)</span> 的值就是最小值。</p>
<p>证明：这是很容易的。首先要注意到，当一个点出队后，它的值不会再改变了（剩下的点的
<span class="math inline">\(dist\)</span> 都 <span
class="math inline">\(\ge\)</span> 它）。其次，由于是第一次 <span
class="math inline">\(t\)</span> 出队，故之前出队的点都不是 <span
class="math inline">\(t\)</span>，其中可能有与 <span
class="math inline">\(t\)</span> 相邻的点 <span
class="math inline">\(u\)</span>，这些状态也会在队列中被考虑。由于 这个
<span class="math inline">\(t\)</span> 的状态是队列中所有 <span
class="math inline">\(t\)</span> 状态中最小的，所以是最优的。</p>
</blockquote>
<p>在无权图上，BFS
得到的队列其实就是一个优先队列（增加，且只有两种值保证了这一点），保证了算法的正确性。</p>
<p>很多问题可以抽象成无权图的最短路问题，比如编辑距离问题、游戏寻路问题（比如使用三角形网格建模，可以构造出无权图）等。</p>
<h2 id="扩展-01-bfs">扩展： 0/1 BFS</h2>
<p>如果图中有两种边，一种权为 <span
class="math inline">\(0\)</span>，一种权为 <span
class="math inline">\(1\)</span>，这个时候可以稍微扩展一下，从 <span
class="math inline">\(1\)</span> 边到达的邻点放到队尾，从 <span
class="math inline">\(0\)</span> 边到达的邻点放到队头，这样得到的队列和
BFS 的队列是一模一样的。</p>
<p>在问题中扩展零边是很方便的，比如铁路换乘方案选择中（如果考虑的是站数，也就是无权图），如果可以加入零边，可以对换乘站的处理变得更优雅：每个线路网构成一个子图，换乘站拆成好几个点，这几个点之间用零边连接。</p>
<blockquote>
<p>思考题：用原来的 BFS 真的不能够处理有零边的图吗？</p>
<p>事实上是可以的。先只考虑零边，找到图中所有的连通分支，每个连通分支内点之间的距离都是
<span class="math inline">\(0\)</span>，看作一个点构成新图，然后再考虑
<span class="math inline">\(1\)</span> 边进行 BFS。</p>
</blockquote>
<h2 id="两种不同的搜索问题">两种不同的搜索问题</h2>
<p>第一种，图比较小，这时我们往往可以直接得知图的全貌（比如点数 <span
class="math inline">\(n\)</span>、边数 <span
class="math inline">\(m\)</span>
和图的结构），这时往往可以搜寻整个图，得到关于 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(m\)</span> 的算法，比如我们熟知的：BFS 和 DFS
的时间、空间复杂度都是 <span class="math inline">\(O(n+m)\)</span>。e.g.
常见的寻路问题等。</p>
<p>第二种，图很大（甚至无限大），常常是无法得知图的全貌的，比如由大型迷宫建模而成的图，比如由各种搜索问题建模而成的图。这时，我们用另一种方法描述复杂度：图的分支因子
<span class="math inline">\(b\)</span> 和搜索所需的层数 <span
class="math inline">\(d\)</span>。比如，在这样的描述中，BFS
的时间、空间复杂度都是 <span
class="math inline">\(O(1+b+b^2+\cdots+b^d)=O(b^d)\)</span>，而 DFS
无法满足完备性和最优性，如果额外限定只搜索 <span
class="math inline">\(d\)</span> 层就返回，那么时间是 <span
class="math inline">\(O(b^d)\)</span>，但空间是 <span
class="math inline">\(O(d)\)</span> 的。e.g. <span
class="math inline">\(n\)</span>
皇后问题、竖式填写等一些经典搜索问题，还有超大迷宫的寻路问题，每次可以扩展的分支数
<span class="math inline">\(b\)</span> 一般是有上界的，但是点数 <span
class="math inline">\(n\)</span> 可能很大。</p>
<p>e.g.竖式填写</p>
<p><img src="2.png" /></p>
<h2 id="迭代加深-iddfs1-2-6">迭代加深 IDDFS<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a> <a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a></h2>
<p>看起来 BFS 的时间和空间都是 <span
class="math inline">\(O(b^d)\)</span>，都是较低的，但是实际上，空间往往比时间更不能忍受。</p>
<p>取 <span class="math inline">\(b=10\)</span>，计算机运算速度是 <span
class="math inline">\(1000\text{ nodes/s}\)</span>，内存消耗是 <span
class="math inline">\(1000\text{ bytes/s}\)</span>，计算得</p>
<p><img src="1.png" /></p>
<p>(from <a href="https://yey.world/2020/03/06/COMP90054-02/"
class="uri">https://yey.world/2020/03/06/COMP90054-02/</a>)</p>
<p>比如 depth 为 <span class="math inline">\(12\)</span> 时，<span
class="math inline">\(13\)</span> days
是可以忍受的，甚至有很多优化的方法，比如算法上利用剪支、利用并发等，但 1
PB 的内存是极其困难的。</p>
<p>这时可以考虑迭代加深 IDDFS，第一次只搜到 <span
class="math inline">\(d=1\)</span> 的结点就返回，第二次 <span
class="math inline">\(d=2\)</span>
就返回，依次类推多次迭代，直到找到目标顶点。容易发现，每次有意义的搜索就是在“返回层”，而在“返回层”之前的搜索都是重复的。于是，它的一次迭代也就相当于进行了一次
BFS 的扩展，和 BFS 是等价的。</p>
<p>接下来分析时间和空间复杂度。</p>
<p>时间上，第 <span class="math inline">\(1\)</span> 层算了 <span
class="math inline">\(d\)</span> 次，第 <span
class="math inline">\(2\)</span> 层算了 <span
class="math inline">\(d-1\)</span> 次，依次类推，第 <span
class="math inline">\(d\)</span> 层算了 <span
class="math inline">\(1\)</span> 次，其中第 <span
class="math inline">\(i\)</span> 层有 <span
class="math inline">\(b^{i-1}\)</span> 个节点，总代价为</p>
<p><span class="math display">\[
O(b^0\cdot d+b^1\cdot (d-1)+\cdots+b^{d-1}\cdot 1)=O(b^d). (b&gt;1)
\]</span></p>
<p>这时因为主要开销仍在最底层，所以和 BFS
的时间代价比起来，开销只有常数倍。但是空间上和 DFS 是一致的，都是 <span
class="math inline">\(O(d)\)</span>。</p>
<h2 id="一致代价搜索的算法dijkstra-3-4">一致代价搜索的算法(Dijkstra) <a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> <a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a></h2>
<p>上面提到了一致代价搜索。当边权全是 <span
class="math inline">\(1\)</span> 或者有 <span
class="math inline">\(0\)</span> 有 <span
class="math inline">\(1\)</span> 时，BFS
已经可以完美解决了。但是，普遍化地，如果边权可以是任意<strong>非负数</strong>（即一致代价搜索的定义），这时我们就要回到上面提到的定理了，使用数据结构来维护这样一个队列。当然，有一个性质是，此处其实不需要每个结点的多个
<span class="math inline">\(g\)</span> 状态，只用考虑一个。时间复杂度是
<span class="math inline">\(O(n^2+m)\)</span>（用线性表维护优先队列）或
<span class="math inline">\(O((n+m)\log
m)\)</span>（用二叉堆维护优先队列）。空间复杂度是 <span
class="math inline">\(O(n+m)\)</span>。若用 <span
class="math inline">\(b\)</span> 和 <span
class="math inline">\(d\)</span> 描述，时间是 <span
class="math inline">\(O(d\cdot b^d)\)</span>，空间和 BFS 一样是 <span
class="math inline">\(O(b^d)\)</span>。</p>
<h2 id="dijkstra-再加速---a-7">Dijkstra 再加速 - A* <a href="#fn7"
class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a></h2>
<p>之前考虑的都是“盲目搜索”：仅使用最基本的信息，不知道搜索空间的特征，这种搜索的效率一般是很低下的。但如果预先知道了额外的一些信息，可以使用启发式搜索来加速搜索。A*
算法就是一种启发式算法。</p>
<p>在 Dijkstra 的基础上，优先队列中排序的关键词发生了变化。原来是 <span
class="math inline">\(g(u)\)</span>（从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(u\)</span> 的距离），现在改为了 <span
class="math inline">\(f(u)=g(u)+h(u)\)</span>。其中 <span
class="math inline">\(h(u)\)</span>
是我们寻找的一个<strong>启发函数</strong>，代表从 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(t\)</span> 估计还需要的代价。另一个概念是 <span
class="math inline">\(h^*(u)\)</span>，即在事实上从 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(t\)</span> 估计还需要的代价。</p>
<p>自然而然，我们要询问，这样以后，我们是否还可以找到最优解呢？我们断言，只要
<span class="math inline">\(\forall u, 0\le h(u)\le
h^*(u)\)</span>，那么 A* 算法是满足最优性的（即，<span
class="math inline">\(h\)</span>
只能往少估不能往多估）。比如，在迷宫搜索问题中，选择 <span
class="math inline">\(h(u)\)</span> 是从 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(t\)</span> 的曼哈顿距离。</p>
<blockquote>
<p>简要证明：当 <span class="math inline">\(t\)</span>
出队时，它的代价是 <span
class="math inline">\(f(t)=g(t)+h(t)\)</span>，容易知道 <span
class="math inline">\(0\le h(t)\le h^*(t)\le 0\)</span>，故 <span
class="math inline">\(h(t)=0\)</span>，所以代价就是 <span
class="math inline">\(f(t)=g(t)\)</span>。对于其他可能到达 <span
class="math inline">\(t\)</span> 的它的邻点 <span
class="math inline">\(u\)</span>，它要么还没入队，要么在队列中在 <span
class="math inline">\(t\)</span> 的后面，所以有 <span
class="math inline">\(f(t)\le f(u)=g(u)+h(u)\le g(u)+h^*(u)\)</span>，而
<span class="math inline">\(g(u)+h^*(u)\)</span> 是从 <span
class="math inline">\(u\)</span> 继续到 <span
class="math inline">\(t\)</span> 的最低代价，所以不会更优了。</p>
</blockquote>
<p>A* 算法和其他一些算法有着千丝万缕的联系，比如取 <span
class="math inline">\(h(u)\equiv
0\)</span>（这是一定满足最优性的），就是 Dijkstra
算法。它还和贪婪最佳优先搜索算法、加权 A* 算法等有着联系。</p>
<p>A* 算法为何可以加快搜索？直观来看，选择合适的 <span
class="math inline">\(h\)</span> 可以让搜索得到的分支因子 <span
class="math inline">\(b\)</span> 减小，减少了搜索的状态数。</p>
<h2 id="ida-8">IDA* <a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a></h2>
<p>用 DFS 改写，每次只搜索代价 <span class="math inline">\(\le
L\)</span> 的结点；如果没有搜到 <span
class="math inline">\(t\)</span>，那么下次把 <span
class="math inline">\(L\)</span> 设定为这一次搜索中代价超出 <span
class="math inline">\(L\)</span> 的最小代价。这当然对 Dijkstra
也是适用的。这样可以把空间复杂度降低到 <span
class="math inline">\(O(d)\)</span>。</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://en.wikipedia.org/wiki/Breadth-first_search"
class="uri">https://en.wikipedia.org/wiki/Breadth-first_search</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://yey.world/2020/03/06/COMP90054-02/"
class="uri">https://yey.world/2020/03/06/COMP90054-02/</a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://yey.world/2021/03/12/COMP90054-03/"
class="uri">https://yey.world/2021/03/12/COMP90054-03/</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search"
class="uri">https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search</a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a
href="https://hljmssjg.github.io/2021/11/02/关于搜索算法的复习/"
class="uri">https://hljmssjg.github.io/2021/11/02/关于搜索算法的复习/</a><a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a
href="https://en.wikipedia.org/wiki/Uniform-cost_search"
class="uri">https://en.wikipedia.org/wiki/Uniform-cost_search</a><a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><a
href="https://en.wikipedia.org/wiki/A*_search_algorithm"
class="uri">https://en.wikipedia.org/wiki/A*_search_algorithm</a><a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a
href="https://en.wikipedia.org/wiki/Iterative_deepening_A*"
class="uri">https://en.wikipedia.org/wiki/Iterative_deepening_A*</a><a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 3 笔记</title>
    <url>/posts/5b80795d/</url>
    <content><![CDATA[<p>OT：请调研教材中未介绍过的至少2种哈密尔顿路或哈密尔顿圈的存在性的必要条件或充分条件，讨论条件的适用场景，并阐述证明过程。</p>
<span id="more"></span>
<p><a href="3.pdf">slide</a></p>
<h1 id="哈密尔顿图的充分且或必要条件">哈密尔顿图的充分且/或必要条件</h1>
<h2 id="一哈密尔顿图与独立集">一、哈密尔顿图与独立集</h2>
<p>在 Anatoly D.Plotnikov 的一篇论文<a href="#fn1" class="footnote-ref"
id="fnref1"
role="doc-noteref"><sup>1</sup></a>中给出了判断一个图是否是哈密尔顿图的一个充要条件。他提出了利用图的独立集的性质来判断哈密尔顿图。</p>
<p><strong>Def 1.(<span
class="math inline">\(k\)</span>-连通图)</strong> 对于 <span
class="math inline">\(G=\langle V, E\rangle\)</span>，若 <span
class="math inline">\(|V|\ge k+1\)</span> 且对任意 <span
class="math inline">\(V&#39;\subseteq V\)</span> 且 <span
class="math inline">\(|V&#39;|\le k-1\)</span>，<span
class="math inline">\(G-V&#39;\)</span> 仍连通，则称 <span
class="math inline">\(G\)</span> 是 <span
class="math inline">\(k\)</span>-连通图。</p>
<ul>
<li><span
class="math inline">\(1\)</span>-连通图：即非平凡的连通图。</li>
<li><span
class="math inline">\(2\)</span>-连通图：不含割点的连通图。</li>
</ul>
<p><strong>Theorem 1.</strong> 图 <span class="math inline">\(G\)</span>
是哈密尔顿图的必要条件是 <span class="math inline">\(G\)</span> 是 <span
class="math inline">\(2\)</span>-连通图。</p>
<p>但这不是充要条件，比如 <span class="math inline">\(\Theta\)</span>
图。（<span class="math inline">\(\Theta\)</span> 图：两个度数至少为
<span class="math inline">\(3\)</span>
的点，之间通过至少三条路径相连，每条路径长度至少为 <span
class="math inline">\(2\)</span>。若每条路径长度恰为 <span
class="math inline">\(2\)</span>，则称为简化 <span
class="math inline">\(\Theta\)</span> 图）。</p>
<p><img src="1.png" /></p>
<p><strong>Theorem 2.</strong> 一个 <span
class="math inline">\(2\)</span>-连通图是非哈密尔顿图的必要条件是有
<span class="math inline">\(\Theta\)</span> 图作为它的子图。</p>
<blockquote>
<p>证明：设 <span class="math inline">\(G\)</span> 是一个 <span
class="math inline">\(2\)</span>-连通图且不是哈密尔顿图，则 <span
class="math inline">\(G\)</span> 中最长圈 <span
class="math inline">\(L\)</span> 的长度小于 <span
class="math inline">\(\upsilon(G)\)</span>，由于 <span
class="math inline">\(G\)</span> 连通，故存在 <span
class="math inline">\((u, v)\in E\)</span> 满足 <span
class="math inline">\(u\in L\)</span> 且 <span
class="math inline">\(v\in L\)</span>。设 <span
class="math inline">\(u&#39;\)</span> 和 <span
class="math inline">\(u&#39;&#39;\)</span> 是 <span
class="math inline">\(L\)</span> 上与 <span
class="math inline">\(u\)</span> 相邻的两点，容易知道 <span
class="math inline">\(u&#39;\)</span> 和 <span
class="math inline">\(u&#39;&#39;\)</span> 与 <span
class="math inline">\(v\)</span> 之间均没有边相邻（否则可以把 <span
class="math inline">\(v\)</span> 放进去获得一个更大的圈）。由于 <span
class="math inline">\(G\)</span> 双连通，删去 <span
class="math inline">\(G\)</span> 后 <span
class="math inline">\(v\)</span> 也应该与 <span
class="math inline">\(L\)</span> 上其他点连通，故存在 <span
class="math inline">\(w\in L\)</span> 是 <span
class="math inline">\(v\)</span> 到 <span
class="math inline">\(L\)</span> 上某一条路径的第一个在 <span
class="math inline">\(L\)</span> 上的点，则如图，已然形成 <span
class="math inline">\(\Theta\)</span> 图。</p>
</blockquote>
<p><img src="2.png" /></p>
<p><strong>Theorem 3.</strong> 任何是 <span
class="math inline">\(2\)</span>-连通图的非哈密尔顿图都可以收缩成 <span
class="math inline">\(\Theta\)</span> 图（进一步可以收缩为简化 <span
class="math inline">\(\Theta\)</span> 图）<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>证明略，见原论文。</p>
<p><strong>Def 2.</strong> 图 <span class="math inline">\(G\)</span>
的独立集是点集 <span class="math inline">\(X\subseteq V\)</span> 满足
<span class="math inline">\(G[X]\)</span> 是空图。称点集 <span
class="math inline">\(\mathcal S(X)\subseteq V\)</span> 是独立集 <span
class="math inline">\(X\)</span> 的一个分割（seperating <span
class="math inline">\(X\)</span>），当且仅当 <span
class="math inline">\(\mathcal S(X)\cap X=\varnothing\)</span> 且在
<span class="math inline">\(G-\mathcal S(X)\)</span> 中 <span
class="math inline">\(X\)</span> 中任意两点不连通。</p>
<p><img src="3.png" /></p>
<p><strong>Theorem 4.</strong> 图 <span class="math inline">\(G\)</span>
是哈密尔顿图的充要条件是对于 <span class="math inline">\(G\)</span>
任意的独立集 <span class="math inline">\(X\)</span>，对其任何一个分割
<span class="math inline">\(\mathcal S(X)\)</span> 都有 <span
class="math inline">\(|X|\le | \mathcal S(X)|\)</span>。</p>
<blockquote>
<p>证明：</p>
<p><strong>必要性</strong>，任取一个 <span
class="math inline">\(G\)</span> 的独立集 <span
class="math inline">\(X\)</span>，设它的<strong>最小</strong>分割是
<span class="math inline">\(\hat{\mathcal S}(X)\)</span>。用反证法，设
<span class="math inline">\(|X|&gt; |\mathcal
S(X)|\)</span>。在哈密尔顿圈中看这些点：</p>
</blockquote>
<p><img src="4.png" /></p>
<blockquote>
<p>由于每个点都在圈上，故 <span class="math inline">\(X\)</span>
均在圈上。为了把圈上相邻的 <span class="math inline">\(X\)</span>
点分开，在每两个 <span class="math inline">\(X\)</span>
点之间必须插入至少一个 <span class="math inline">\(\mathcal
S(X)\)</span> 点，故 <span class="math inline">\(|\mathcal
S(X)|\)</span> 至少需要 <span class="math inline">\(\ge
|X|\)</span>，与假设矛盾。必要性成立。</p>
<p><strong>充分性</strong>，若对 <span class="math inline">\(G\)</span>
的任意独立集 <span class="math inline">\(X\)</span> 及其任何一个分割
<span class="math inline">\(\mathcal S(X)\)</span> 都有 <span
class="math inline">\(|X|\le |\mathcal S(X)|\)</span>，假设 <span
class="math inline">\(G\)</span> 不是哈密尔顿图。分以下三种情况：</p>
<ol type="1">
<li>若 <span class="math inline">\(X\)</span>
不连通，则在两个连通分支中选择两个 <span
class="math inline">\(X\)</span>，而 <span
class="math inline">\(\mathcal S(X)\)</span> 可以为空，则 <span
class="math inline">\(2=|X|\le |\mathcal
S(X)|=0\)</span>，不满足前提条件。</li>
<li>若 <span class="math inline">\(X\)</span> 连通但有割点 <span
class="math inline">\(v\)</span>，则在 <span
class="math inline">\(G-v\)</span> 的两个连通分支中选择两个 <span
class="math inline">\(X\)</span>，选择 <span
class="math inline">\(\mathcal S(X)=\lbrace v\rbrace\)</span>，则 <span
class="math inline">\(2=|X|\le |\mathcal
S(X)|=1\)</span>，不满足前提条件。</li>
<li>则 <span class="math inline">\(X\)</span> 是 <span
class="math inline">\(2\)</span>-连通图且不是哈密尔顿图，则 <span
class="math inline">\(X\)</span> 必然可以归约到 <span
class="math inline">\(\Theta\)</span> 图（进而可以归约到简化 <span
class="math inline">\(\Theta\)</span> 图），而在简化 <span
class="math inline">\(\Theta\)</span> 图中可以如图选择 <span
class="math inline">\(|X|=3\)</span> 但 <span
class="math inline">\(|\mathcal
S(X)|=2\)</span>，同样可以对应到到原图中，与假设矛盾。</li>
</ol>
</blockquote>
<p><img src="3.png" /></p>
<blockquote>
<p>综上，充分性成立。</p>
</blockquote>
<h2 id="二哈密尔顿图的一个充分条件">二、哈密尔顿图的一个充分条件</h2>
<p>在 M.Sohel Rahman 和 M.Kaykobad 的一篇论文<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>中，提到了如下结论：</p>
<p>用 <span class="math inline">\(d_G(u)\)</span> 表示在图 <span
class="math inline">\(G\)</span> 中 <span
class="math inline">\(u\)</span> 的度数。</p>
<p><strong>Theorem 5.</strong> 若 <span class="math inline">\(G=\langle
V, E\rangle\)</span> 是一个 <span class="math inline">\(n\)</span>
阶连通图，<span class="math inline">\(P\)</span> 是图中的最长路，长度为
<span class="math inline">\(k\)</span>，端点为 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span>。用 <span
class="math inline">\(\delta(u, v)\)</span> 表示 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 之间的距离。则：</p>
<ol type="1">
<li>若 <span class="math inline">\(\delta(u, v)=1\)</span>，则 <span
class="math inline">\(P\)</span> 是一条在哈密尔顿圈中的哈密尔顿路；</li>
<li>若 <span class="math inline">\(\delta(u, v)\ge 3\)</span>，则 <span
class="math inline">\(d_P(u)+d_P(v)\le k-\delta(u, v)+2\)</span>；</li>
<li>若 <span class="math inline">\(\delta(u, v)=2\)</span>，则要么 <span
class="math inline">\(d_P(u)+d_P(v)\le k\)</span>，要么 <span
class="math inline">\(P\)</span> 是一条在哈密尔顿圈中的哈密尔顿路。</li>
</ol>
<p>接下来来证明 <strong>Theorem 5.</strong>。先证明一个引理，以下指代
<span class="math inline">\(G\)</span> 和 <span
class="math inline">\(P\)</span> 都是在 <strong>Theorem 5.</strong>
的基础上。</p>
<p><strong>Lemma 1.</strong> 若 <span class="math inline">\(P\)</span>
被包含在某个圈 <span class="math inline">\(C\)</span> 内，则 <span
class="math inline">\(P\)</span> 是一条哈密尔顿路，<span
class="math inline">\(G\)</span> 是哈密尔顿图。</p>
<blockquote>
<p>证明：首先，易知 <span class="math inline">\(V[P]=V[C]\)</span>，否则
<span class="math inline">\(P\)</span> 显然可以变得更长。设 <span
class="math inline">\(P=\langle u=u_0, u_1, u_2, \cdots,
u_k=v\rangle\)</span>，则 <span class="math inline">\(C=\langle u=u_0,
u_1, u_2, \cdots, u_k, u_0=u\rangle\)</span>，假设 <span
class="math inline">\(P\)</span> 不为哈密尔顿路，则 <span
class="math inline">\(k&lt;n-1\)</span>，由于 <span
class="math inline">\(G\)</span> 是连通图，存在 <span
class="math inline">\((x, y)\in E\)</span> 满足 <span
class="math inline">\(x\in V[P]\)</span> 且 <span
class="math inline">\(y\in V[G-P]\)</span>，设 <span
class="math inline">\(x=u_i\)</span>，则有一条长度为 <span
class="math inline">\(k+1\)</span> 的路径 <span
class="math inline">\(P&#39;=\langle y, x=u_i, u_{i+1}, \cdots, u_k,
u_0, \cdots, u_{i-1}\rangle\)</span>，矛盾。故 <span
class="math inline">\(P\)</span> 是哈密尔顿路，<span
class="math inline">\(C\)</span> 是哈密尔顿圈，<span
class="math inline">\(G\)</span> 是哈密尔顿图。</p>
</blockquote>
<p><strong>Theorem 5.</strong></p>
<blockquote>
<p>证明：</p>
<ol type="1">
<li>当 <span class="math inline">\(\delta(u, v)=1\)</span>，则 <span
class="math inline">\(C=P+(u, v)\)</span> 是一个包含 <span
class="math inline">\(P\)</span> 的圈，由 <strong>Lemma
1.</strong>得证。</li>
<li>当 <span class="math inline">\(\delta(u, v)\ge 3\)</span> 时，设与
<span class="math inline">\(u\)</span> 相邻的顶点集为 <span
class="math inline">\(N_P(u)\)</span>，与 <span
class="math inline">\(v\)</span> 相邻的顶点集为 <span
class="math inline">\(N_P(v)\)</span>，可知 <span
class="math inline">\(\forall x\in N_P(u), y\in N_P(v)\)</span>，满足
<span class="math inline">\(\delta(x, y)\ge \delta(u,
v)-2\)</span>。容易知道 <span
class="math inline">\(|N_P(u)|+|N_P(v)|+\delta(x, y)\le k\)</span>，故
<span class="math inline">\(d_P(u)+d_P(v)\le k-\delta(u,
v)+2\)</span>。</li>
</ol>
</blockquote>
<p><img src="5.png" /></p>
<blockquote>
<ol start="3" type="1">
<li>若 <span class="math inline">\(\delta(u, v)=2\)</span>，且 <span
class="math inline">\(d_P(u)+d_P(v)\ge k+1=|V[P]|\)</span>，把 <span
class="math inline">\(P\)</span> 写成 <span
class="math inline">\(P=\langle v=w_1, w_2, \cdots, w_{|V[P]|-1},
w_{|V[P]|}=u \rangle\)</span>。我们尝试找出两条相交的边 <span
class="math inline">\((v, w_{i+1})\)</span> 和 <span
class="math inline">\((w_i, u)\)</span>，这样可以构造出一个环 <span
class="math inline">\(C=\langle w_1, w_{i+1}, w_{i+2}, \cdots,
w_{|V[P]-1|}, w_{|V[P]|}, w_i, w_{i-1}, \cdots, w_2,
w_1\rangle\)</span>，于是由引理 1 得证。是否存在这样的 <span
class="math inline">\(i\)</span> 呢？设 <span
class="math inline">\(S=\lbrace i: (v, w_{i+1})\in E\rbrace, T=\lbrace
i: (w_i, u)\in E\rbrace\)</span>，可知 <span
class="math inline">\(|S|=d_P(u), |T|=d_P(v), |S\cup T|\le
|V[P]|-1\)</span>，故 <span class="math display">\[
\begin{aligned}
|S\cap T|=&amp;|S|+|T|-|S\cup T|\\
\ge &amp;d_P(u)+d_P(v)-(|V[P]|-1)\\
\ge &amp;|V[P]|-(|V[P]|-1)\\
=&amp;1
\end{aligned}
\]</span></li>
</ol>
</blockquote>
<p><strong>Theorem 6.</strong> 若 <span class="math inline">\(G=\langle
V, E\rangle\)</span> 是一个 <span class="math inline">\(n\)</span>
阶连通图，且对于所有不相邻的两点 <span class="math inline">\(u, v\in
V\)</span>，有 <span class="math inline">\(d(u)+d(v)+\delta(u, v)\ge
n+1\)</span>，则 <span class="math inline">\(G\)</span>
有哈密尔顿路。</p>
<p>证明略。</p>
<!--@article{article,
author = {Plotnikov, Anatoly},
year = {1998},
month = {01},
pages = {199-202},
title = {One criterion of existence of a Hamiltonian cycle},
journal = {Reliable Computing}
}-->
<!--@article{hoede1978characterization,
  title={On characterization of hamiltonian graphs},
  author={Hoede, Cornelis and Veldman, Henk Jan},
  journal={Journal of Combinatorial Theory, Series B},
  volume={25},
  number={1},
  pages={47--53},
  year={1978},
  publisher={Academic Press}
}-->
<!--@article{rahman2005hamiltonian,
  title={On Hamiltonian cycles and Hamiltonian paths},
  author={Rahman, M Sohel and Kaykobad, Mohammad},
  journal={Information Processing Letters},
  volume={94},
  number={1},
  pages={37--41},
  year={2005},
  publisher={Elsevier}
}-->
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Plotnikov, Anatoly. (1998). One criterion of existence
of a Hamiltonian cycle. Reliable Computing. 199-202.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Hoede, C., &amp; Veldman, H. J. (1978). On
characterization of hamiltonian graphs. Journal of Combinatorial Theory,
Series B, 25(1), 47-53.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Rahman, M. S., &amp; Kaykobad, M. (2005). On Hamiltonian
cycles and Hamiltonian paths. Information Processing Letters, 94(1),
37-41.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 4 笔记</title>
    <url>/posts/51457044/</url>
    <content><![CDATA[<p>OT：请调研并阐述面向点连通度或边连通度的门格尔定理的至少2种证明方法。</p>
<span id="more"></span>
<p><a href="4.pdf">Slide</a>.</p>
<h1 id="门格尔定理">门格尔定理</h1>
<p><strong>门格尔定理(顶点版本)</strong> 对于图 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 和两个不相邻的顶点
<span class="math inline">\(u, v\in V\)</span>，使 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 不连通至少需要从 <span
class="math inline">\(G\)</span> 中删除的顶点数量（<span
class="math inline">\(u\)</span>-<span class="math inline">\(v\)</span>
最小点割集大小）等于 <span class="math inline">\(G\)</span>
中两两无公共内顶点的 <span class="math inline">\(u\)</span>-<span
class="math inline">\(v\)</span> 路的数量。</p>
<p><strong>门格尔定理(边版本)</strong> 对于图 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 和两个顶点 <span
class="math inline">\(u, v\in V\)</span>，使 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 不连通至少需要从 <span
class="math inline">\(G\)</span> 中删除的边数量（<span
class="math inline">\(u\)</span>-<span class="math inline">\(v\)</span>
最小边割集大小）等于 <span class="math inline">\(G\)</span>
中两两无公共边的 <span class="math inline">\(u\)</span>-<span
class="math inline">\(v\)</span> 路的数量。</p>
<h1
id="利用归纳证明门格尔定理点版本1">利用归纳证明门格尔定理（点版本）<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></h1>
<p>对 <span class="math inline">\(m=\epsilon(G)\)</span>
进行归纳。假设图 <span class="math inline">\(G\)</span> 有大小为 <span
class="math inline">\(k\)</span> 的最小点割集 <span
class="math inline">\(S\)</span>，显然有 <span
class="math inline">\(u\)</span>-<span class="math inline">\(v\)</span>
不交路的数量 <span class="math inline">\(\le k\)</span>。只需证明其等于
<span class="math inline">\(k\)</span>。</p>
<ul>
<li>当 <span class="math inline">\(m=0\)</span>
时，对于空图显然成立。</li>
<li>如果对于 <span class="math inline">\(\epsilon(G)\le m-1\)</span>
的图都成立，则对于 <span class="math inline">\(G\)</span> 满足 <span
class="math inline">\(\epsilon(G)=m\)</span> 的图，我门证明上述命题。当
<span class="math inline">\(k\le 1\)</span>，结论显然成立，只考虑 <span
class="math inline">\(k\ge 2\)</span>。分为以下几种情况：</li>
</ul>
<ol type="1">
<li>若存在 <span class="math inline">\(S\)</span> 且存在 <span
class="math inline">\(x\in S\)</span> 使得 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 均相邻，那么图 <span
class="math inline">\(G- x\)</span> 有大小为 <span
class="math inline">\(k-1\)</span> 的点割集 <span
class="math inline">\(S\setminus \lbrace x\rbrace\)</span>，且 <span
class="math inline">\(\epsilon(G-x)&lt;m\)</span>。由归纳假设，<span
class="math inline">\(G-x\)</span> 有 <span
class="math inline">\(k-1\)</span> 条 <span
class="math inline">\(u\)</span>-<span class="math inline">\(v\)</span>
不交路，则在 <span class="math inline">\(G\)</span> 中，加上 <span
class="math inline">\(\langle u, x, v\rangle\)</span>，有 <span
class="math inline">\(k\)</span> 条 <span
class="math inline">\(u\)</span>-<span class="math inline">\(v\)</span>
不交路。</li>
</ol>
<p><img src="2.png" /> 2. 若存在 <span
class="math inline">\(S\)</span>，满足 <span
class="math inline">\(S\)</span> 中既存在和 <span
class="math inline">\(u\)</span> 不相邻的顶点 <span
class="math inline">\(v&#39;\)</span>，也存在和 <span
class="math inline">\(v\)</span> 不相邻的顶点 <span
class="math inline">\(u\)</span>，那么如图，可以简单地拆成两个图并运用归纳假设。</p>
<p><img src="1.png" /></p>
<p>（图片来源<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>）</p>
<ol start="3" type="1">
<li>则剩下的情况是，对于<strong>所有</strong>的 <span
class="math inline">\(S\)</span>，要么全部顶点只和 <span
class="math inline">\(u\)</span> 相邻不和 <span
class="math inline">\(v\)</span> 相邻，要么全部顶点只和 <span
class="math inline">\(v\)</span> 相邻不和 <span
class="math inline">\(u\)</span> 相邻。不妨设是第一种。设 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的最短路径是 <span
class="math inline">\(\langle u, x, y, \cdots, v\rangle\)</span>，记
<span class="math inline">\(e=(x, y)\)</span>。设 <span
class="math inline">\(G&#39;=G-e\)</span> 的最小点割集 <span
class="math inline">\(Z\)</span>，显然 <span
class="math inline">\(k-1\le |Z|\le k\)</span>。只需证明 <span
class="math inline">\(|Z|=k\)</span> 并利用归纳假设（因为 <span
class="math inline">\(\epsilon(G&#39;)&lt;m\)</span>）即可。用反证法，假设
<span class="math inline">\(|Z|=k-1\)</span>，则 <span
class="math inline">\(Z\cup\lbrace x\rbrace\)</span> 和 <span
class="math inline">\(Z\cup\lbrace y\rbrace\)</span> 均是 <span
class="math inline">\(G\)</span> 的两个最小分割集，于是均与 <span
class="math inline">\(u\)</span> 相邻，与最短路矛盾。故 <span
class="math inline">\(|Z|=k\)</span>，利用归纳假设，<span
class="math inline">\(G-e\)</span> 有 <span
class="math inline">\(k\)</span> 条 <span
class="math inline">\(u\)</span>-<span class="math inline">\(v\)</span>
不交路，从而 <span class="math inline">\(G\)</span> 也有 <span
class="math inline">\(k\)</span> 条，证毕。</li>
</ol>
<p><img src="3.png" /></p>
<h1 id="用最大流最小割定理直接证明">用最大流最小割定理直接证明</h1>
<h2 id="证明边版本">证明边版本</h2>
<p>如何建模？</p>
<ul>
<li><span class="math inline">\(u\)</span> 作为源点，<span
class="math inline">\(v\)</span>
作为汇点，把所有无向边当作两条方向相反的弧，容量为 1。</li>
<li>一条 <span class="math inline">\(u\)</span>-<span
class="math inline">\(v\)</span> 路对应 <span
class="math inline">\(1\)</span> 流量，因为边的容量为 <span
class="math inline">\(1\)</span>，保证了边不重复。</li>
<li>最小割是显然的。</li>
</ul>
<h2 id="证明点版本">证明点版本</h2>
<p>如何建模？</p>
<ul>
<li><span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 仍然作为源汇点，把其他每个点 <span
class="math inline">\(x\)</span> 拆成入点 <span
class="math inline">\(x_{in}\)</span> 和出点 <span
class="math inline">\(x_{out}\)</span> 两个点。对于原图的有向边 <span
class="math inline">\((x, y)\)</span>,在 <span
class="math inline">\(x_{out}\)</span> 和 <span
class="math inline">\(y_{in}\)</span> 间连有向边，容量为 <span
class="math inline">\(\infty\)</span>；在 <span
class="math inline">\(x_{in}\)</span> 和 <span
class="math inline">\(x_{out}\)</span> 之间连容量为 <span
class="math inline">\(1\)</span> 的边。<span
class="math inline">\(u\)</span> 则作为 <span
class="math inline">\(u_{out}\)</span>、<span
class="math inline">\(v\)</span> 作为 <span
class="math inline">\(v_{in}\)</span> 建图。</li>
<li>一条 <span class="math inline">\(u\)</span>-<span
class="math inline">\(v\)</span> 路对应 <span
class="math inline">\(1\)</span> 流量，因为点内部的边容量为 <span
class="math inline">\(1\)</span>，保证了点不重复。</li>
<li>最小割：只能在点的入点和出点之间割开，相当于把点割去。</li>
</ul>
<p><img src="4.png" /></p>
<p>（图片来源<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>）</p>
<!-- @book{chartrand2013first,
  title={A first course in graph theory},
  author={Chartrand, Gary and Zhang, Ping},
  year={2013},
  publisher={Courier Corporation}
} -->
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Chartrand, G., &amp; Zhang, P. (2013). A first course in
graph theory. Courier Corporation.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Chartrand, G., &amp; Zhang, P. (2013). A first course in
graph theory. Courier Corporation.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>https://www.cs.princeton.edu/~wayne/cs423/lectures/max-flow-applications<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>ICS PA memory leak issue due to lib readline bug</title>
    <url>/posts/972c44eb/</url>
    <content><![CDATA[<p>A memory leak issue which might be confusing for students struggling
with ICS Project (aka, <a
href="https://nju-projectn.github.io/ics-pa-gitbook/">PA</a>) of Nanjing
University.</p>
<span id="more"></span>
<h1 id="notification">Notification</h1>
<p>The issue mentioned in this article has been discovered by the
developer community for a while(And probabily been fixed so far). But
for freshmen in this field, such as students taking NJU ICS course, this
is not well-known and may cause serious confusion. <a
href="https://github.com/top-mind"><strong>Geng
Tiancheng(top-mind)</strong></a> discovered this during his implementing
of PA(<a href="https://github.com/NJU-ProjectN/nemu/issues/77">GitHub
issue page</a>). And he delegated me, <a
href="https://github.com/rijuyuezhu"><strong>Wenrui
Huang(rijuyuezhu)</strong></a>, to write a blog recording the issue, in
order to help students who meet the same situation.</p>
<h1 id="bug-summary">Bug Summary</h1>
<h2 id="the-environment">The environment</h2>
<p>All the tests are based on the environment listed below.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux &lt;hostname&gt; 6.2.0-34-generic #34~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Sep  7 13:12:03 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">$ gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=/usr/bin/gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=&#x27;Ubuntu 11.4.0-1ubuntu1~22.04&#x27; --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2</span><br><span class="line">Thread model: posix</span><br><span class="line">Supported LTO compression algorithms: zlib zstd</span><br><span class="line">gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04)</span><br><span class="line"></span><br><span class="line">$ apt show libreadline8</span><br><span class="line">Package: libreadline8</span><br><span class="line">Version: 8.1.2-1</span><br><span class="line">Priority: important</span><br><span class="line">Section: libs</span><br><span class="line">Source: readline</span><br><span class="line">Origin: Ubuntu</span><br><span class="line">Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;</span><br><span class="line">Original-Maintainer: Matthias Klose &lt;doko@debian.org&gt;</span><br><span class="line">Bugs: https://bugs.launchpad.net/ubuntu/+filebug</span><br><span class="line">Installed-Size: 472 kB</span><br><span class="line">Depends: readline-common, libc6 (&gt;= 2.33), libtinfo6 (&gt;= 6)</span><br><span class="line">Task: minimal, server-minimal</span><br><span class="line">Download-Size: 153 kB</span><br><span class="line">APT-Manual-Installed: no</span><br><span class="line">APT-Sources: https://mirror.nju.edu.cn/ubuntu jammy/main amd64 Packages</span><br><span class="line">Description: GNU readline and history libraries, run-time libraries</span><br><span class="line"> The GNU readline library aids in the consistency of user interface</span><br><span class="line"> across discrete programs that need to provide a command line</span><br><span class="line"> interface.</span><br><span class="line"> .</span><br><span class="line"> The GNU history library provides a consistent user interface for</span><br><span class="line"> recalling lines of previously typed input.</span><br></pre></td></tr></table></figure>
<h2 id="overview">Overview</h2>
<p>When following the instruction of PA gitbook: <span
style="color: red">PA1 ~ 监视点 ~ sanitizer - 一种底层的assert</span>,
(<a
href="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/1.6.html#调试工具与原理">find
the page in ICS2023</a>), students turn on the functionality of address
sanitizer. This tools help to provide basic examinations of array access
out of bounds as well as memory leaks.</p>
<p>However, though this tool helps a lot dealing with memory leak issues
caused by the students(for example, non-matching <code>malloc</code> and
<code>free</code>), some of the students will meet strange memory leak
fault that <strong>indicating there is an issue in the lib
readline</strong>, like the message below:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==2277358==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 32 byte(s) in 1 object(s) allocated from:</span><br><span class="line">    #0 0x7f9b452b4887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #1 0x7f9b45c5dbac in xmalloc (/lib/x86_64-linux-gnu/libreadline.so.8+0x39bac)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 32 byte(s) leaked in 1 allocation(s).</span><br><span class="line">make: *** [/&lt;path&gt;/ics2023/nemu/scripts/native.mk:38: run] Error 1</span><br></pre></td></tr></table></figure>
<p>So what happened? In fact, <strong>there is indeed a bug in lib GNU
readline</strong>.</p>
<h2 id="reproduce-the-bug">Reproduce the bug</h2>
<p>Compile your nemu, then <code>make run</code>, and input a
meaningless string, like: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(nemu) abc&lt;CR&gt;</span><br><span class="line">Unknown command &#x27;abc&#x27;.</span><br></pre></td></tr></table></figure> where &lt;CR&gt; means the enter
key.</p>
<p>After that, input another meaningless and <strong>do not press
&lt;CR&gt;</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(nemu) abc&lt;CR&gt;</span><br><span class="line">Unknown command &#x27;abc&#x27;.</span><br><span class="line">(nemu) xyz</span><br></pre></td></tr></table></figure>
<p>And press <strong>up arrow</strong> instead. This recovers the last
history and the string that show now becomes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(nemu) abc&lt;CR&gt;</span><br><span class="line">Unknown command &#x27;abc&#x27;.</span><br><span class="line">(nemu) abc</span><br></pre></td></tr></table></figure>
<p>Simply enter &lt;CR&gt;, then input <code>q</code> and enter
&lt;CR&gt; again: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(nemu) abc</span><br><span class="line">Unknown command &#x27;abc&#x27;.</span><br><span class="line">(nemu) abc</span><br><span class="line">Unknown command &#x27;abc&#x27;.</span><br><span class="line">(nemu) q</span><br><span class="line">=================================================================</span><br><span class="line">==2286531==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 32 byte(s) in 1 object(s) allocated from:</span><br><span class="line">    #0 0x7f73104b4887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #1 0x7f7310f5fbac in xmalloc (/lib/x86_64-linux-gnu/libreadline.so.8+0x39bac)</span><br><span class="line"></span><br><span class="line">Indirect leak of 402 byte(s) in 21 object(s) allocated from:</span><br><span class="line">    #0 0x7f73104b4887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #1 0x7f7310f5fbac in xmalloc (/lib/x86_64-linux-gnu/libreadline.so.8+0x39bac)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 434 byte(s) leaked in 22 allocation(s).</span><br><span class="line">make: *** [/&lt;path&gt;/ics2023/nemu/scripts/native.mk:38: run] Error 1</span><br></pre></td></tr></table></figure></p>
<p>We learn that this issue is related to the history functionality of
<code>readline</code> lib. However, because the shared library is not
compiled with flag <code>-g</code>, and gdb also cannot find the
position of memory leak, the debug process may be hard, even though we
know it is the library readline to blame.</p>
<h2 id="research-the-source-repo-of-lib-readline">Research the source
repo of lib readline</h2>
<p>It is great that readline is open-source, and we can easily obtain
the source code of the library. Links are as follows:</p>
<ul>
<li><a href="https://savannah.gnu.org/projects/readline/">The GNU
Readline library - Summary</a></li>
<li><a href="https://savannah.gnu.org/git/?group=readline">The GNU
Readline library - Git Repositories</a></li>
</ul>
<p>Clone the source code, and we enter the project folder to have a
look:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> readline</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">aclocal.m4     compat.c       display.c       history.h      m4           parens.c        readline.c      rlshell.h     shlib       undo.c</span><br><span class="line">ansi_stdlib.h  complete.c     doc             history.pc.in  macro.c      parse-colors.c  readline.h      rlstdc.h      signals.c   USAGE</span><br><span class="line">bind.c         config.h       emacs_keymap.c  histsearch.c   Makefile     parse-colors.h  readline.pc     rltty.c       stamp-h     util.c</span><br><span class="line">callback.c     config.h.in    examples        input.c        Makefile.<span class="keyword">in</span>  patchlevel      readline.pc.in  rltty.h       support     vi_keymap.c</span><br><span class="line">CHANGELOG      config.log     funmap.c        INSTALL        MANIFEST     posixdir.h      README          rltypedefs.h  tcap.h      vi_mode.c</span><br><span class="line">CHANGES        config.status  histexpand.c    isearch.c      mbutil.c     posixjmp.h      rlconf.h        rlwinsize.h   terminal.c  xfree.c</span><br><span class="line">chardefs.h     configure      histfile.c      keymaps.c      misc.c       posixselect.h   rldefs.h        savestring.c  text.c      xmalloc.c</span><br><span class="line">colors.c       configure.ac   histlib.h       keymaps.h      NEWS         posixstat.h     rlmbutil.h      search.c      tilde.c     xmalloc.h</span><br><span class="line">colors.h       COPYING        history.c       kill.c         nls.c        posixtime.h     rlprivate.h     shell.c       tilde.h</span><br></pre></td></tr></table></figure>
<p>and we can see git log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --graph</span><br><span class="line">* 7274faa (HEAD -&gt; master, origin/master, origin/HEAD) Readline-8.2 patch 1: fix crash when readline is started with an invalid locale specification</span><br><span class="line">* f7a382f (tag: readline-8.2) readline-8.2 distribution sources and documentation</span><br><span class="line">* 5263c0d Readline-8.1 patch 2: fix redisplay of some characters &gt; 128 in certain single-byte encodings</span><br><span class="line">* 9ba3434 Readline-8.1 patch 1: fix version comparisons in startup files</span><br><span class="line">* cf3c762 (tag: readline-8.1) Readline-8.1 distribution sources and documentation</span><br><span class="line">* c5ad6be problems restoring the history file are not signaled correctly to the calling application</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Some developer reports that the bug is fixed in the version
<code>readline-8.2</code>, and let us verify that. Switch to the
<code>readline-8.2</code> tag and compile the lib (according to
<code>README</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout readline-8.2</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>The readline lib provides some examples, and we can use that for our
bug reproduction.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> examples</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>We can use, for example, <code>rltest</code> for test. But to detect
memory leak, we need some tools. <a
href="https://valgrind.org/">Valgrind</a> is a very powerful tool for
such a need. Run <code>rltest</code> with valgrind:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ valgrind ./rltest</span><br><span class="line">==2341346== Memcheck, a memory error detector</span><br><span class="line">==2341346== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==2341346== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==2341346== Command: ./rltest</span><br><span class="line">==2341346==</span><br><span class="line">readline$</span><br></pre></td></tr></table></figure>
<p>Remember what to do to reproduce the bug? First input random string
and enter &lt;CR&gt;, then input random string and enter up arrow, and
finally enter &lt;CR&gt; and quit the program(We can use Ctrl-C
here):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ valgrind ./rltest</span><br><span class="line">==2341346== Memcheck, a memory error detector</span><br><span class="line">==2341346== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==2341346== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==2341346== Command: ./rltest</span><br><span class="line">==2341346==</span><br><span class="line">readline$ abc</span><br><span class="line">abc</span><br><span class="line">readline$ abc</span><br><span class="line">abc  # Note: this string is initially not abc, but turns to abc after entering up arrow</span><br><span class="line">^C</span><br><span class="line">==2341346==</span><br><span class="line">==2341346== &lt;Some other info&gt;</span><br><span class="line">==2341346==</span><br><span class="line">==2341346== LEAK SUMMARY:</span><br><span class="line">==2341346==    definitely lost: 0 bytes in 0 blocks</span><br><span class="line">==2341346==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==2341346==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==2341346==    still reachable: 222,888 bytes in 271 blocks</span><br><span class="line">==2341346==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==2341346== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">==2341346==</span><br><span class="line">==2341346== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==2341346== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>
<p>We find that the memory lost is zero, so the bug is fixed in
<code>readline-8.2</code>.</p>
<p>And we checkout the former version:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout HEAD~</span><br><span class="line">Previous HEAD position was f7a382f readline-8.2 distribution sources and documentation</span><br><span class="line">HEAD is now at 5263c0d Readline-8.1 patch 2: fix redisplay of some characters &gt; 128 in certain single-byte encodings</span><br></pre></td></tr></table></figure>
<p>And do the same test as above, we get info like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==2355120== LEAK SUMMARY:</span><br><span class="line">==2355120==    definitely lost: 32 bytes in 1 blocks</span><br><span class="line">==2355120==    indirectly lost: 66 bytes in 3 blocks</span><br><span class="line">==2355120==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==2355120==    still reachable: 198,179 bytes in 249 blocks</span><br><span class="line">==2355120==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==2355120== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">==2355120==</span><br><span class="line">==2355120== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==2355120== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>
<p>We find that in this version, there exists memory leak issues.</p>
<h2 id="find-the-bugbonus">Find the bug(Bonus)</h2>
<p>Why does this problem happen? Use powerful <code>git diff</code> and
gdb(you can add flags you want in the project <code>Makefile</code>) to
find the bug!</p>
<p>You can follow the instruction of README to install the latest
version of <code>readline</code> to eliminate the bug, or do not fix it
and avoid such a usage. I prefer the latter to keep the stablity of
package dependencies.</p>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>Thanks <a href="https://github.com/top-mind"><strong>Geng
Tiancheng(top-mind)</strong></a> for discovering the bug and telling it
to me at the first time, as well as delegating me to complete such a
blog.</p>
<p>Thanks <a href="https://github.com/sashimi-yzh"><strong>Zihao
Yu(sashimi-yzh)</strong></a> for providing the awesome PA
experiment.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 6 笔记</title>
    <url>/posts/13607739/</url>
    <content><![CDATA[<p>OT：单源最短路问题有很多并行算法，例如 <a
href="https://linkinghub.elsevier.com/retrieve/pii/S0196677403000762">Δ-stepping</a>
算法、<a href="https://dl.acm.org/doi/10.1145/2935764.2935765">Radius
Stepping</a> 算法等，请调研至少 2 种算法（其中至多 1
种来自上述例子），结合例子介绍算法的设计与分析，比较异同并分析优劣。</p>
<span id="more"></span>
<p><a href="slide/slide.html">Slides</a></p>
<h1 id="基于-goldberg-算法的-sssp-并行算法">基于 Goldberg 算法的 SSSP
并行算法</h1>
<p>本文先介绍一种可以处理非负权图的 <span
class="math inline">\(L\)</span>-<strong>限定距离
SSSP</strong>的并行算法，work 为 <span class="math inline">\(\tilde O
(m)\)</span>，span 为 <span
class="math inline">\(n^{1/2+o(1)}L^{1/2}\)</span> WHP。</p>
<blockquote>
<p><span class="math inline">\(L\)</span>-限定距离 SSSP: 只计算途中
<span class="math inline">\(dist(s, v)\le L\)</span> 的 <span
class="math inline">\(v\)</span> 的最短距离 <span
class="math inline">\(v.d=dist(s, v)\)</span>，而将 <span
class="math inline">\(dist(s, v)&gt;L\)</span> 的 <span
class="math inline">\(v\)</span> 求得的 <span
class="math inline">\(v.d=\infty\)</span>。</p>
<p>WHP: With high probability，有 neglible 的概率失败。</p>
</blockquote>
<p>然后在此基础上再介绍基于 Goldberg's algorithm 的整数权的 SSSP
并行算法。设图中所有权的边权均 <span class="math inline">\(\ge
-L\)</span>，则 work 为 <span class="math inline">\(\tilde O(m\sqrt
n\log N)\)</span>，span 为 <span
class="math inline">\(n^{5/4+o(1)}\)</span> WHP。<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<h2 id="l-限定距离-sssp"><span class="math inline">\(L\)</span>-限定距离
SSSP</h2>
<h3 id="两个黑盒结果">两个黑盒结果</h3>
<p>“单（多）点连通性判断问题”：给定图 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 和起点集合 <span
class="math inline">\(S\subseteq V\)</span>，判定图中哪些点可以从 <span
class="math inline">\(S\)</span> 中某个点可达。在该文<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>中给出了 <span
class="math inline">\(\tilde O(m)\)</span> work 和 <span
class="math inline">\(n^{1/2+o(1)}\)</span> span WHP 的结果。</p>
<p>“逼近 SSSP 问题（ASSSP）”：给定图 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 和起点 <span
class="math inline">\(s\)</span>，要求求得“过估距离” <span
class="math inline">\(d&#39;(v)\)</span> 满足 <span
class="math inline">\(dist(s, v)\le d&#39;(v)\le (1+\epsilon)dist(s,
v)\)</span>。对于固定的 <span
class="math inline">\(\epsilon\)</span>，该文<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>给出了 <span
class="math inline">\(\tilde O(m)\)</span> work 和 <span
class="math inline">\(n^{1/2+o(1)}\)</span> span WHP 的结果。</p>
<h3 id="l-限定距离-sssp-主过程"><span
class="math inline">\(L\)</span>-限定距离 SSSP 主过程</h3>
<p>设 <span class="math inline">\(D\)</span> 是大于 <span
class="math inline">\(L\)</span> 的最小的 <span
class="math inline">\(2\)</span> 的幂次。该算法先运行一次 ASSSP with
<span class="math inline">\(\epsilon=1\)</span>。对于 <span
class="math inline">\(d&#39;(v)\ge 2D\)</span> 可知 <span
class="math inline">\(dist(v) \ge D&gt;L\)</span>，这些点一定不用在
<span class="math inline">\(L\)</span>-限定距离 SSSP 中考虑，直接设为
<span class="math inline">\(v.d=\infty\)</span>。剩下的点的 <span
class="math inline">\(dist(v)\)</span> 一定落在 <span
class="math inline">\([0, D)\)</span> 区间。对于 <span
class="math inline">\(d&#39;(v)=0\)</span> 的，可知 <span
class="math inline">\(dist(v)=0\)</span>。</p>
<p>该算法正是依赖于“逐渐减小范围”的方法来求出 <span
class="math inline">\(dist(s, \cdot)=d\)</span>
的所有顶点：假设已经找到了 <span class="math inline">\(dist(s,
\cdot)&lt;d\)</span>
的所有顶点，并不再考虑。那么，剩下的顶点可以另构图，使得整体的 <span
class="math inline">\(dist&#39;(s&#39;, \cdot)\)</span> 都减小 <span
class="math inline">\(d\)</span>：对于图中所有的边 <span
class="math inline">\((u, v)\)</span> 满足 <span
class="math inline">\(dist(s, u)&lt;d\)</span>，<span
class="math inline">\(dist(s, v)\ge d\)</span>，相应地建边 <span
class="math inline">\((s&#39;, v)\)</span> 且</p>
<p><span class="math display">\[
    w&#39;(s&#39;, v)=w(s, v)+dist(s, u)-d.
\]</span></p>
<p><img src="1.png" /></p>
<p><img src="2.png" /></p>
<p>假设当前考虑 <span class="math inline">\(v\)</span> 的 <span
class="math inline">\(dist(s, v)\)</span> 范围是 <span
class="math inline">\([d,
d+2^i)\)</span>，则在作这个变换后，可以知道对于这些 <span
class="math inline">\(v\)</span> 有 <span
class="math inline">\(dist&#39;(s&#39;, v)\in [0, 2^i)\)</span>。使用
<span class="math inline">\(\epsilon&lt;1/4\)</span> 的 ASSSP
后，可以根据得到的 <span class="math inline">\(d&#39;\)</span>
分为三类（注意上界为 <span class="math inline">\(5/4\cdot
2^i\)</span>）：</p>
<ul>
<li><span class="math inline">\(0\le d&#39;&lt;2\cdot
2^{i-2}\)</span>，则 <span class="math inline">\(0\le dist&#39;(s&#39;,
v)&lt;2\cdot 2^{i-2}\)</span>，进而 <span class="math inline">\(d\le
dist(s, v)&lt; d+2\cdot 2^{i-2}\)</span>。</li>
<li><span class="math inline">\(2\cdot 2^{i-2}\le d&#39;&lt;3\cdot
2^{i-2}\)</span>，则 <span class="math inline">\(2^{i-2}\le
dist&#39;(s&#39;, v)&lt; 3\cdot 2^{i-2}\)</span>，进而 <span
class="math inline">\(d+2^{i-2}\le dist(u, v)&lt;d+3\cdot
2^{i-2}\)</span>。</li>
<li><span class="math inline">\(3\cdot 2^{i-2}\le
d&#39;&lt;5\cdot2^{i-2}\)</span>，则 <span class="math inline">\(2\cdot
2^{i-2}\le dist&#39;(s, v)&lt;4\cdot 2^{i-2}\)</span>，进而 <span
class="math inline">\(d+2\cdot 2^{i-2}\le dist(u, v)&lt;d+4\cdot
2^{i-2}\)</span>。</li>
</ul>
<p>于是划分成了 <span class="math inline">\(2^{i-1}\)</span>
长度的三小段。在 <span class="math inline">\(\log L\)</span>
次后即可计算完成 <span class="math inline">\(dist(s, v)=d\)</span>
的顶点。</p>
<p>简要分析可知，该算法有 <span class="math inline">\(\tilde
O(m)\)</span> work 和 <span class="math inline">\(n^{1/2+o(1)}L\)</span>
span 的结果。在加上一定的随机赋优先级后，有着期望 <span
class="math inline">\(\tilde O(m)\)</span> work 和 <span
class="math inline">\(n^{1/2+o(1)}\sqrt L\)</span> span WHP 的结果。</p>
<h1 id="基于-goldberg-算法的-sssp">基于 Goldberg 算法的 SSSP</h1>
<p>Goldberg 可以解决的问题：解决整数权（可以有负权）的 SSSP
问题。设图中所有边权 <span class="math inline">\(\ge -N\)</span>，则
Goldberg 算法的时间复杂度为 <span class="math inline">\(O(m\sqrt n\log
N)\)</span>。</p>
<p>该文<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>对其并行化后，得到了 <span
class="math inline">\(\tilde O(m\sqrt n\log N)\)</span> work，<span
class="math inline">\(n^{5/4+o(1)}\)</span> span WHP 算法，并行率至少为
<span class="math inline">\(m^{1/4-o(1)}\)</span>。</p>
<h2 id="goldberg-简述">Goldberg 简述</h2>
<p>Goldberg 的核心思想是构造一个“价值函数” <span
class="math inline">\(p\)</span> 满足</p>
<p><span class="math display">\[
    \forall (u, v)\in E, p(v)\le p(u)+w(u, v).
\]</span></p>
<p>构造新图 <span class="math inline">\(G&#39;=\langle V, E,
w&#39;\rangle\)</span>，在 <span class="math inline">\(G&#39;\)</span>
中</p>
<p><span class="math display">\[
    \forall (u, v)\in E, w&#39;(u, v)=w(u, v)+p(u)-p(v).
\]</span></p>
<p>可知 <span class="math inline">\(w&#39;(u, v)\ge 0\)</span>。</p>
<p>而对于原图中的一条路径 <span class="math inline">\(p=\langle e_1,
e_2, \cdots, e_m\rangle\)</span>，可知</p>
<p><span class="math display">\[
\begin{aligned}
    w&#39;(p)&amp;=\sum_{i=1}^{m-1}w&#39;(e_i)
    \\
    &amp;=\sum_{i=1}^{m-1}[w(e_i)+p(u_i)-p(v_i)]
    \\
    &amp;=w(p)+p(s)-p(t).
\end{aligned}
\]</span> 其中 <span class="math inline">\(s, t\)</span> 分别是 <span
class="math inline">\(p\)</span> 的起点和终点。故 <span
class="math inline">\(G&#39;\)</span> 中 <span
class="math inline">\(s,v\)</span> 最短路对应于 <span
class="math inline">\(G\)</span> 中的最短路。由于 <span
class="math inline">\(G&#39;\)</span> 是非负权图，故可以使用 Dijkstra
算法求解。问题转化为了求出满足条件 <span
class="math inline">\(p\)</span>。</p>
<p>Goldberg 算法对图中的最小边权做递推。最终要求的是满足 <span
class="math inline">\(\forall (u, v), w(u, v)&gt; -N\)</span> 的 <span
class="math inline">\(p\)</span>，记作 <span
class="math inline">\(p_{N}(G)\)</span>。方便起见，设 <span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(2\)</span> 的幂次。递归方案如下：</p>
<ol type="1">
<li>对任意图，<span class="math inline">\(p_1(G)\)</span>
是好构造的：此时 <span class="math inline">\(w(u, v)&gt;-1\)</span>
即非负，取 <span class="math inline">\(p\equiv 0\)</span>
即满足条件。</li>
<li>若要求符合条件的 <span class="math inline">\(p_{2m}(G)\)</span>，
<ol type="1">
<li>若 <span class="math inline">\(w\)</span> 全为偶数，则构造新图 <span
class="math inline">\(G&#39;=\langle V, E, w/2\rangle\)</span>，在 <span
class="math inline">\(G&#39;\)</span> 中得到 <span
class="math inline">\(p_{m}(G&#39;)\)</span>，则可令 <span
class="math inline">\(p_{2m}(G)=2p_m(G&#39;)\)</span>。</li>
<li>若 <span class="math inline">\(w\)</span> 并非全为偶数，构造新图
<span class="math inline">\(G&#39;=\langle V, E, \lceil
w/2\rfloor\rceil\)</span>，在 <span
class="math inline">\(G&#39;\)</span> 中得到 <span
class="math inline">\(p_m(G&#39;)\)</span>，令 <span
class="math inline">\(p_{2m}(G)=2p_m(G&#39;)\)</span>，此时仍有一些边不满足条件：它们比预期差了
<span class="math inline">\(1\)</span>。于是，会得到一个边权 <span
class="math inline">\(\ge -1\)</span> 的图。</li>
</ol></li>
</ol>
<p>下面只需要对该边权 <span class="math inline">\(\ge -1\)</span> 的图
<span class="math inline">\(G_p\)</span> 调整 <span
class="math inline">\(p\)</span> 的值即可。</p>
<p>先求其强连通分量并缩点，得到一个 DAG <span
class="math inline">\(G&#39;_p\)</span>。若某个 SCC
中含有负边，则图中显然存在负环。记 <span
class="math inline">\(G&#39;_p\)</span> 中有入边为 <span
class="math inline">\(-1\)</span> 的点称为“负点”，其集合记为 <span
class="math inline">\(V_n\)</span>，可以按以下方法逐渐缩小 <span
class="math inline">\(V_n\)</span> 最终致其为空集：</p>
<blockquote>
<p>取 <span class="math inline">\(x\in V_n\)</span>，记 <span
class="math inline">\(x\)</span> 可达的所有点为 <span
class="math inline">\(S_x\)</span>，将 <span
class="math inline">\(S_x\)</span> 的所有点 <span
class="math inline">\(p\)</span> 值降低 <span
class="math inline">\(1\)</span>。这样以后 <span
class="math inline">\(x\)</span> 就不再是负点了。</p>
</blockquote>
<p>由于每次都需要重新求 SCC，时间复杂度为 <span
class="math inline">\(O(mn\log N)\)</span>。</p>
<p>注意到最长反链长等于最小链覆盖：DAG 中最长链和最长反链至少有一个超过
<span class="math inline">\(O(\sqrt k)\)</span>，其中 <span
class="math inline">\(k\)</span> 是 <span
class="math inline">\(V_n\)</span>
的大小。如果我们提出一个一次性消除链的算法，一个一次性消除反链的算法，就可以解决了。</p>
<ul>
<li>一次性消除反链：直接求出反链上的所有点可达的点，一起让 <span
class="math inline">\(p\)</span> 值减 <span
class="math inline">\(1\)</span> 即可。</li>
<li>一次性消除链：较为复杂，但也可以线性得到，略。</li>
</ul>
<p>寻找最长链/最长反链是容易的：构造超级源点 <span
class="math inline">\(s\)</span> 并运行一次 DAG 上的 SSSP(时间 <span
class="math inline">\(O(m)\)</span>)，设距离为 <span
class="math inline">\(-d\)</span> 的点集为 <span
class="math inline">\(V_d\)</span>，得到 <span
class="math inline">\(V_0, V_1, \cdots, V_\tau\)</span>。若 <span
class="math inline">\(\tau\ge \sqrt k\)</span>，则找到了一条长度 <span
class="math inline">\(\ge \sqrt k\)</span>
的链；否则由鸽巢原理，必然存在 <span class="math inline">\(|V_i|\ge
\sqrt k\)</span>，这是一条反链。</p>
<p>于是，每次都会使得问题规模 <span class="math inline">\(k&#39;\gets
(1-\frac{1}{\sqrt k})\cdot k\)</span>，可以知道在 <span
class="math inline">\(O(\sqrt k)\)</span> 轮后 <span
class="math inline">\(V_n\)</span> 变为空集，每轮复杂度 <span
class="math inline">\(O(m)\)</span>，一共要进行 <span
class="math inline">\(O(\log N)\)</span> 次递推。最后还需进行一次 <span
class="math inline">\(O(n\log m)\)</span> 的 Dijkstra。</p>
<p>Goldberg 算法复杂度故为 <span class="math inline">\(O(m\sqrt n\log
N)\)</span>。</p>
<h2 id="goldberg-算法的并行化">Goldberg 算法的并行化</h2>
<p>外面的 <span class="math inline">\(O(\log N)\)</span>
次递推，以及中间的 <span class="math inline">\(\sqrt n\)</span> 次 <span
class="math inline">\(V_d\)</span>
迭代仍然保持顺序执行，如此，若内部的每次迭代可以做到 span <span
class="math inline">\(f\)</span> WHP，并保持 work <span
class="math inline">\(\tilde O(m)\)</span>，则最后可以得到 <span
class="math inline">\(\tilde O(m\sqrt n\log N)\)</span> work 和 <span
class="math inline">\(f\cdot n^{1/2}\log N\)</span> span WHP
的算法。在此处，我们使用得到 <span
class="math inline">\(f=n^{3/4+o(1)}\)</span> WHP
的算法。只需要注意到</p>
<ol type="1">
<li>求 SCC 可以归约到单点连通性<a href="#fn5" class="footnote-ref"
id="fnref5"
role="doc-noteref"><sup>5</sup></a>，进而用“单（多）点连通性判断问题”在
<span class="math inline">\(\tilde O(m)\)</span> work 和 <span
class="math inline">\(n^{1/2}+o(1)\)</span> span WHP 内完成。</li>
<li>寻找最长链/最长反链运行的 SSSP 需要运行带负权边 <span
class="math inline">\(-1\)</span> 的 <span class="math inline">\(\sqrt
k\)</span>-限定距离 SSSP，在原文中给出了一个 <span
class="math inline">\(\tilde O(m)\)</span> work，<span
class="math inline">\(n^{1/2+o(1)}\sqrt L\)</span> WHP
的算法（在此略去），取 <span class="math inline">\(L=\sqrt k\)</span>
满足条件。</li>
<li>一次性消除反链：对于给定的反链需要求出可达点，这也就是"单（多）连通性判断问题"，同
1.</li>
<li>一次性消除链：使用一个 <span class="math inline">\(\sqrt
n\)</span>-限定距离 SSSP，用了前一个算法，<span
class="math inline">\(\tilde O(m)\)</span> work，<span
class="math inline">\(n^{1/2+o(1)}\sqrt L\)</span> WHP，符合条件。</li>
</ol>
<p>综上，最终我们得到了一个 <span class="math inline">\(O(m\sqrt n\log
N)\)</span> work，<span class="math inline">\(n^{5/4+o(1)}\log
N\)</span> span 的基于 Goldberg 算法的并行算法。</p>
<!-- @inproceedings{10.1145/3490148.3538583, -->
<!-- author = {Cao, Nairen and Fineman, Jeremy T. and Russell, Katina}, -->
<!-- title = {Parallel Shortest Paths with Negative Edge Weights}, -->
<!-- year = {2022}, -->
<!-- isbn = {9781450391467}, -->
<!-- publisher = {Association for Computing Machinery}, -->
<!-- address = {New York, NY, USA}, -->
<!-- url = {https://doi.org/10.1145/3490148.3538583}, -->
<!-- doi = {10.1145/3490148.3538583}, -->
<!-- abstract = {This paper presents a parallel version of Goldberg's algorithm for the problem of single-source shortest paths with integer (including negatives) edge weights. Given an input graph with n vertices, m edges, and integer weights ≥-N, our algorithms solves the problem with \~{O}(m √n log N) work and n5/4+o(1) log N span, both with high probability. Our algorithm thus has work similar to Goldberg's algorithm while also achieving at least m1/4-o(1) parallelism. To generate our parallel version of Goldberg's algorithm, we solve two specific distance-limited shortest-path problems, both with work \~{O}(m) and span √L · n1/2+o(1), where L is the distance limit.}, -->
<!-- booktitle = {Proceedings of the 34th ACM Symposium on Parallelism in Algorithms and Architectures}, -->
<!-- pages = {177–190}, -->
<!-- numpages = {14}, -->
<!-- keywords = {parallel algorithm, shortest paths}, -->
<!-- location = {Philadelphia, PA, USA}, -->
<!-- series = {SPAA '22} -->
<!-- } -->
<!-- @inproceedings{jambulapati2019parallel, -->
<!--   title={Parallel reachability in almost linear work and square root depth}, -->
<!--   author={Jambulapati, Arun and Liu, Yang P and Sidford, Aaron}, -->
<!--   booktitle={2019 IEEE 60th Annual Symposium on Foundations of Computer Science (FOCS)}, -->
<!--   pages={1664--1686}, -->
<!--   year={2019}, -->
<!--   organization={IEEE} -->
<!-- } -->
<!-- @inproceedings{cao2020efficient, -->
<!--   title={Efficient construction of directed hopsets and parallel approximate shortest paths}, -->
<!--   author={Cao, Nairen and Fineman, Jeremy T and Russell, Katina}, -->
<!--   booktitle={Proceedings of the 52nd Annual ACM SIGACT Symposium on Theory of Computing}, -->
<!--   pages={336--349}, -->
<!--   year={2020} -->
<!-- } -->
<!-- @article{blelloch2020parallelism, -->
<!--   title={Parallelism in randomized incremental algorithms}, -->
<!--   author={Blelloch, Guy E and Gu, Yan and Shun, Julian and Sun, Yihan}, -->
<!--   journal={Journal of the ACM (JACM)}, -->
<!--   volume={67}, -->
<!--   number={5}, -->
<!--   pages={1--27}, -->
<!--   year={2020}, -->
<!--   publisher={ACM New York, NY, USA} -->
<!-- } -->
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>https://dl.acm.org/doi/abs/10.1145/3490148.3538583<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>https://doi.org/10.48550/arXiv.1905.08841<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>https://dl.acm.org/doi/abs/10.1145/3357713.3384270<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>https://dl.acm.org/doi/abs/10.1145/3490148.3538583<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>https://arxiv.org/abs/1810.05303<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 7 笔记</title>
    <url>/posts/dfca77a7/</url>
    <content><![CDATA[<p>OT：<a href="https://doi.org/10.1145/2530531">距离索引</a>（Distance
Oracle）是一种用于查询精确或近似距离的数据结构，请调研至少1种精确距离索引和1种近似距离索引，讨论适用场景，结合例子介绍索引构造算法和距离查询算法的设计与分析。</p>
<span id="more"></span>
<p><a href="slide/slide.html">Slide</a></p>
<h1 id="distance-oracle空间与时间的权衡">Distance
Oracle——空间与时间的权衡</h1>
<h2 id="简介">简介</h2>
<p>未加说明的定义见 [1] (Sommer, 2014)。</p>
<p>Distance oracle 是一种距离 stretch，空间 space 和单次查询时间 query
time 的权衡的艺术。</p>
<h1
id="适用于一般无向非负权图的-stretch-2-的-do">适用于一般无向非负权图的
stretch &lt; 2 的 DO</h1>
<h2 id="do-的历史发现">DO 的历史发现</h2>
<p><img src="1.png" /></p>
<h2 id="论文贡献">论文贡献</h2>
<p>[2] (Agarwal, 2014) 提供了三种满足 stretch <span
class="math inline">\(\alpha\in(1, 2]\)</span> 的 DO。</p>
<p><img src="2.png" /></p>
<p>我们主要讨论第一个成果：</p>
<p><em>Result:</em> 对于平均度为 <span
class="math inline">\(\mu=2m/n\)</span> 的图，对任意 <span
class="math inline">\(1\le \alpha \le n\)</span>，存在 stretch 为 <span
class="math inline">\(O(1+1/k)\)</span>，询问时间 <span
class="math inline">\(T=O((\alpha \mu)^k)\)</span>，空间为 <span
class="math inline">\(S=O(m+n^2/\alpha)\)</span> 的 DO。</p>
<p>约束方程：</p>
<p><span class="math display">\[
    S\times T^{1/k}=O(n^2)
\]</span></p>
<h2 id="主要思想">主要思想</h2>
<ul>
<li><p>经典的 landmark 法：选一个 landmark 集 <span
class="math inline">\(L\)</span>，对所有点存储到它们的距离。</p></li>
<li><p>合理地选择多级 landmark，使得<strong>估计距离</strong> <span
class="math inline">\(\delta(s, t)\)</span>
和实际距离的误差尽量小。</p></li>
<li><p>和 Agarwal
的之前的成果相比：创新性地使用了<strong>双向</strong>方法来处理询问。</p>
<p>正是由于双向的优化，在不影响 space 和 construction time
的前提下，query time 得到了大幅优化：</p></li>
</ul>
<p><img src="3.png" /></p>
<h2 id="图的结构性预处理---degree-bounded">图的结构性预处理 - degree
bounded</h2>
<p><em>Theorem:</em> 任何 <span class="math inline">\(n\)</span> 点
<span class="math inline">\(m\)</span> 边的图都可以转化为不超过 <span
class="math inline">\(2n\)</span> 点，所有点度数不超过 <span
class="math inline">\(\lceil \mu + 2\rceil\)</span> 的图。（<span
class="math inline">\(\mu\)</span> 是原图的平均度数，为 <span
class="math inline">\(2m/n\)</span>）。</p>
<p><em>Construction:</em> 在新图 <span
class="math inline">\(G&#39;\)</span> 中，将所有点 <span
class="math inline">\(u\)</span> 转化为 <span
class="math inline">\(t_u=\lceil \deg(u)/\mu\rceil\)</span> 个点 <span
class="math inline">\(u_1, u_2, \cdots, u_{t_u}\)</span>。将原图中 <span
class="math inline">\(u\)</span> 的邻点分成 <span
class="math inline">\(t_u\)</span> 组，每组不超过 <span
class="math inline">\(\mu\)</span> 个，在新图中连到这 <span
class="math inline">\(t_u\)</span> 个点上。最后将这 <span
class="math inline">\(t_u\)</span> 个点在新图中用零边连成链。</p>
<p><img src="4.png" /></p>
<p><img src="5.png" /></p>
<h2 id="基础定义">基础定义</h2>
<p>若选定了 landmark 集 <span
class="math inline">\(L\)</span>，则对于任意一点 <span
class="math inline">\(v\in V\)</span>：</p>
<p><span class="math inline">\(l(v)\)</span>：距离 <span
class="math inline">\(v\)</span> 最近的 <span
class="math inline">\(L\)</span> 中顶点；<span
class="math inline">\(r_v\)</span>：<span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(l(v)\)</span> 之间的距离。</p>
<p><img src="6.png" /></p>
<p><span class="math inline">\(B(v)\)</span>：所有到 <span
class="math inline">\(v\)</span> 距离<strong>小于</strong> <span
class="math inline">\(r(v)\)</span> 的点的集合。</p>
<p><img src="7.png" /></p>
<p><span class="math inline">\(B^*(v)\)</span>：在 <span
class="math inline">\(B(v)\)</span> 中或与 <span
class="math inline">\(B(v)\)</span> 中顶点相邻的点的集合。</p>
<p><img src="8.png" /></p>
<p>迭代定义：</p>
<p><span class="math display">\[
    \Gamma_i^*(v)=\bigcup_{w\in \Gamma^*_{i-1}(v)} B^*(w);\quad
\Gamma_i(v)=\bigcup_{w\in \Gamma^*_{i-1}(v)} B(w)
\]</span> 且 <span class="math inline">\(\Gamma_0^*(v)=v,
\Gamma_0(v)=\varnothing\)</span>.</p>
<h2 id="landmark-集-l-选取">landmark 集 <span
class="math inline">\(L\)</span> 选取</h2>
<p><em>Theorem:</em> 对于最大度 <span
class="math inline">\(\Delta(G)=\mu\)</span> 的图 <span
class="math inline">\(G\)</span>，对任意 <span
class="math inline">\(1\le \alpha\le n\)</span>，存在 landmark 集 <span
class="math inline">\(L\)</span> 大小为 <span
class="math inline">\(\tilde O(n/\alpha)\)</span>，满足对任意 <span
class="math inline">\(v\in V\)</span>，<span
class="math inline">\(|B(v)|=O(\alpha)\)</span> 从而 <span
class="math inline">\(|B^*(v)|=O(\alpha\mu)\)</span>, WHP。</p>
<p>证明：[4] (Alon &amp; Spencer, 2016).</p>
<h2 id="算法预处理">算法预处理</h2>
<p>对每个点 <span
class="math inline">\(v\)</span>，使用一个哈希表存储到所有 <span
class="math inline">\(|L|=\tilde O(n/\alpha)\)</span> 个 landmark
的距离，以及 <span class="math inline">\(l(v)\)</span> 和 <span
class="math inline">\(r_v\)</span>。</p>
<p>每个点使用 Perfect hashing，空间为 <span class="math inline">\(\tilde
O(n/\alpha)\)</span>。故算法总空间 <span class="math inline">\(\tilde
O(m+n^2/\alpha)\)</span>。</p>
<h2 id="算法主过程">算法主过程</h2>
<p>对于 <span class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 的查询，分为三部分。(Candidate distance
意为，只从 e.g. <span class="math inline">\(\Gamma_k^*(s)\)</span>
内部更新的距离)</p>
<p><img src="9.png" /></p>
<h2 id="s-到-t-的最短路"><span class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的最短路</h2>
<p>在 <span class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的最短路中，我们考虑 <span
class="math inline">\(\Gamma^*_i\)</span> 的递归表现：</p>
<p><img src="10.png" /></p>
<p><img src="11.png" /></p>
<p><img src="12.png" /></p>
<p><img src="13.png" /></p>
<p>以下性质对于 <span class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 是对称的，故只证 <span
class="math inline">\(s\)</span>.</p>
<p><em>Property 1.</em> 在 Query 的 1.2. 行后，可以得出所有 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(w_j^s(0\le j\le k)\)</span> 的距离，也就是求得的
Candidate distance。</p>
<p><em>Property 2.</em> 设 <span class="math inline">\(r^s\)</span> 是
<span class="math inline">\(\min_{0\le j&lt;k}r_{w^s_j}\)</span>，则
<span class="math inline">\(d(s, w_i^s)\ge i\cdot r^s\)</span>。</p>
<p><img src="14.png" /></p>
<p><em>Property 3.</em> 若 <span class="math inline">\(w_k^t\notin
\Gamma^*_k(s)\)</span>（即两向的迭代不交），则 <span
class="math inline">\(d(s, t)\ge 2k\min\lbrace r^s,
r^t\rbrace\)</span>.</p>
<p><em>Property 4.</em> query 算法得到的估计距离 <span
class="math inline">\(\delta(s, t)\le d(s, t)+2\min\lbrace r^s,
r^t\rbrace\)</span>.</p>
<ul>
<li>这是因为第 5. 行使用更新的 <span
class="math inline">\(d&#39;_s(w)+d(w, l(w))+d(l(w), t)\le d(s,
t)+2r^s\)</span>，<span class="math inline">\(w\)</span> 选择使得 <span
class="math inline">\(r_{w^s_j}\)</span> 取得 <span
class="math inline">\(r^s\)</span> 的 <span
class="math inline">\(w^s_j\)</span>：</li>
</ul>
<p><img src="15.png" /></p>
<h2 id="stretch-分析">stretch 分析</h2>
<ol type="1">
<li>当 <span class="math inline">\(w_k^t\in \Gamma_k^*(s)\)</span>
时，可以得到 <span class="math inline">\(\delta(s, t)=d(s,
t)\)</span>，此时得到准确值。</li>
<li>当 <span class="math inline">\(w_k^t\notin \Gamma_k^*(s)\)</span>
时，由 <em>Property 3.</em> 有 <span class="math inline">\(d(s, t)\ge
2k\min\lbrace r^s, r^t\rbrace\)</span>；由 <em>Property 4.</em> 有 <span
class="math inline">\(\delta(s, t)\le d(s, t)+2\min\lbrace r^s,
r^t\rbrace\)</span>。从而</li>
</ol>
<p><span class="math display">\[
    \delta(s, t)\le d(s, t)+2\min\lbrace r^s, r^t\rbrace \le d(s,
t)+2\cdot d(s, t)/(2k).
\]</span></p>
<p>进而</p>
<p><span class="math display">\[
\dfrac{\delta(s, t)}{d(s, t)}\le 1+1/k.
\]</span></p>
<p>即 stretch 为 <span class="math inline">\(1+1/k\)</span>.</p>
<p>由上知，该算法空间为 <span class="math inline">\(\tilde
O(m+n^2/\alpha)\)</span>。由于每次 query 要进行 <span
class="math inline">\(O(|\Gamma^*_k|)\)</span> 范围的计算 Cadidate
distance 和枚举，而每个点 <span class="math inline">\(v\)</span> 的
<span
class="math inline">\(|B^*(v)|=O(\alpha\mu)\)</span>，故最终单次询问复杂度为
<span class="math inline">\(O((\alpha\mu)^k)\)</span>.</p>
<h1 id="平面图的一种-exact-do">平面图的一种 Exact DO</h1>
<h2 id="概述">概述</h2>
<p>[3] (Djidjev, 1996) 给出了平面图（确切地说，<span
class="math inline">\(O(\sqrt n)\)</span> 分离图）上的一种 construction
time <span class="math inline">\(O(S)\)</span>, space <span
class="math inline">\(S=O(S)\)</span>, query time <span
class="math inline">\(T=O(n^2/S)\)</span> 的 DO。</p>
<p>满足约束</p>
<p><span class="math display">\[
    S\times T=O(n^2).
\]</span></p>
<p>以下只展示 <span class="math inline">\(S=O(n\sqrt n)\)</span>，<span
class="math inline">\(T=O(\sqrt n)\)</span>
的构建方法，其余范围是它的推论。</p>
<p><img src="16.png" /></p>
<h2 id="fn-分离性"><span class="math inline">\(f(n)\)</span> 分离性</h2>
<p>称一类图 <span class="math inline">\(\mathcal G_{f(n)}\)</span> 具有
<span class="math inline">\(f(n)\)</span> 分离性，即对 <span
class="math inline">\(G\in \mathcal G_{f(n)}\)</span>，存在大小为 <span
class="math inline">\(O(f(n))\)</span> 的 <span
class="math inline">\(C\)</span>，使得 <span
class="math inline">\(G-C\)</span> 的每个连通分支的大小均不超过 <span
class="math inline">\(\alpha n\)</span>，其中 <span
class="math inline">\(\alpha&lt;1\)</span> 为常数。</p>
<p><em>Theorem(平面分离定理):</em> 平面图 <span
class="math inline">\(\subseteq \mathcal G_{\sqrt n}\)</span>。</p>
<h2 id="预处理">预处理</h2>
<p>通过递归构造 <span class="math inline">\(O(\sqrt n)\)</span>
seperator，形成一棵 <span class="math inline">\(O(\log n)\)</span>
深度的树。</p>
<p><img src="17.png" /></p>
<p><img src="18.png" /></p>
<p><img src="19.png" /></p>
<p>转化为树，树中的每个顶点代表原图中一个 <span
class="math inline">\(O(\sqrt n)\)</span> seperator，即为：</p>
<p><img src="20.png" /></p>
<p>再预处理：树中每个顶点（即一个 <span class="math inline">\(O(\sqrt
n)\)</span> seperator <span
class="math inline">\(C(G_x)\)</span>）代表的原图中每个顶点计算到 <span
class="math inline">\(G_x\)</span> 中的每个顶点的距离）。</p>
<ul>
<li>使用 [5] (Henzinger et.al, 1997) 的方法可以在平面图中 <span
class="math inline">\(O(|G|)\)</span> 进行 SSSP。</li>
<li>计算一个大小为 <span class="math inline">\(n_x\)</span> 的<span
class="math inline">\(C(G_x)\)</span> 的信息需要 <span
class="math inline">\(O(n_x\sqrt {n_x})\)</span>
的预处理时间和算法总空间。</li>
</ul>
<p>预处理时间/算法总空间共计</p>
<p><span class="math display">\[
f(n)=\sum_{i}f(n_i)+O(n\sqrt {n}), \text{where } \sum_{i}n_i=n, n_i\le
\alpha n.
\]</span></p>
<p>解得 <span class="math inline">\(f(n)=O(n\sqrt
n)\)</span>。故预处理时间，空间均为 <span class="math inline">\(O(n\sqrt
n)\)</span>。</p>
<h2 id="询问">询问</h2>
<p>对于 <span class="math inline">\(u,
v\)</span>，找到在树中它们所在的顶点，设它们的 LCA 为 <span
class="math inline">\(C(G_l)\)</span>。输出答案为</p>
<p><span class="math display">\[
d(u, v)=\min_{x\in C(G_l)} \lbrace d(u, x) + d(x, v)\rbrace.
\]</span></p>
<p>这是因为 <span class="math inline">\(C(G_l)\)</span> 中一定有顶点在
<span class="math inline">\(u, v\)</span>
的最短路上（它是割集）。单次询问时间 <span class="math inline">\(O(\sqrt
n)\)</span>。</p>
<h2 id="总结">总结</h2>
<p>于是，我们得到了平面图（或一般地，<span
class="math inline">\(\mathcal G_{\sqrt n}\)</span>）预处理和空间均为
<span class="math inline">\(O(n\sqrt n)\)</span>，单次询问时间为 <span
class="math inline">\(O(\sqrt n)\)</span> 的 DO。</p>
<h1 id="参考文献">参考文献</h1>
<p>[1] Sommer, C. (2014). Shortest-path queries in static networks. ACM
Computing Surveys (CSUR), 46(4), 1-31.</p>
<p>[2] Agarwal, R. (2014). The space-stretch-time tradeoff in distance
oracles. In Algorithms-ESA 2014: 22th Annual European Symposium,
Wroclaw, Poland, September 8-10, 2014. Proceedings 21 (pp. 49-60).
Springer Berlin Heidelberg.</p>
<p>[3] Djidjev, H. N. (1996, June). Efficient algorithms for shortest
path queries in planar digraphs. In International Workshop on
Graph-Theoretic Concepts in Computer Science (pp. 151-165). Berlin,
Heidelberg: Springer Berlin Heidelberg.</p>
<p>[4] Alon, N., &amp; Spencer, J. H. (2016). The probabilistic method.
John Wiley &amp; Sons.</p>
<p>[5] Henzinger, M. R., Klein, P., Rao, S., &amp; Subramanian, S.
(1997). Faster shortest-path algorithms for planar graphs. journal of
computer and system sciences, 55(1), 3-23.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 8 笔记</title>
    <url>/posts/6ea650b/</url>
    <content><![CDATA[<p>OT：最小生成树问题有很多<a
href="https://en.wikipedia.org/wiki/Minimum_spanning_tree#Related_problems">相关问题</a>，例如
<a href="https://en.wikipedia.org/wiki/Steiner_tree_problem">Steiner
tree</a>、<a
href="https://en.wikipedia.org/wiki/K-minimum_spanning_tree">k-MST</a>、<a
href="https://en.wikipedia.org/wiki/Minimum_bottleneck_spanning_tree">MBST</a>
等，请调研至少 2 种问题（其中至多 1 种来自上述例子，<a
href="https://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree">欧氏最小生成树问题</a>等仅限制原始问题输入的问题不在调研范围内），讨论适用场景，形式化描述问题并概述现有解决方案。</p>
<span id="more"></span>
<p><a href="slide/slide.html">Slide</a></p>
<h1
id="最小直径生成树和最小标签生成树">最小直径生成树和最小标签生成树</h1>
<h2 id="概述">概述</h2>
<p>主要介绍最小直径生成树(Mininum diameter spanning tree,
MDST)以及最小标签生成树(Mininum labeling spanning tree,
MLST)的相关算法。</p>
<p>MDST 主要参考了文献 [1] (Hassin &amp; Tamir, 1995) 和 [2] (Hakimi,
1964)；MLST 主要参考了 [3] (Chang &amp; Shing-Jiuan, 1997)。</p>
<h1 id="mdst">MDST</h1>
<h2 id="最小直径生成树---定义">最小直径生成树 - 定义</h2>
<p><em>Def.</em> 最小直径生成树(MDST)问题：对于非负权无向图 <span
class="math inline">\(G=\langle V, E\rangle\)</span>，寻找它的一棵生成树
<span class="math inline">\(T^*\)</span>，使得对任意 <span
class="math inline">\(G\)</span> 的生成树 <span
class="math inline">\(T\)</span>，有</p>
<p><span class="math display">\[
    diam(T^*)\le diam (T)
\]</span></p>
<p>其中 <span class="math inline">\(diam(G&#39;)\)</span> 是树 <span
class="math inline">\(G&#39;\)</span> 的直径，定义为</p>
<p><span class="math display">\[
\max_{u\in G&#39;}\max_{v\in G&#39;}dist(u, v).
\]</span></p>
<h2 id="应用场景">应用场景</h2>
<p>适用于各种要最小化<strong>单次</strong>最大传输距离（即最小化直径）的场景，区别于建设费用对应的
MST 问题。</p>
<h2
id="绝对中心问题absolute-1-center-problem-a1cp">绝对中心问题(Absolute 1
center problem, A1CP)</h2>
<ul>
<li><p>图的中心：离心率 <span class="math inline">\(ecc(u)\)</span>
最小的点 <span
class="math inline">\(u\)</span>。中心的离心率定义为图的半径 <span
class="math inline">\(rad(G)\)</span>。</p>
<p>离心率 <span class="math inline">\(ecc(u)\)</span> 定义为 <span
class="math inline">\(u\)</span> 到离它最远点的距离，即 <span
class="math display">\[
  ecc(u)=\max_{v\in V}dist(u, v).
\]</span></p></li>
<li><p>但是直径不一定是半径的两倍！</p></li>
</ul>
<div data-align="center">
<p><img width="80%" src="1.png" /></p>
</div>
<ul>
<li>图的绝对中心：允许<strong>把边拆开</strong>，每条边可以认为有无数细分的点。把细分后的图记为
<span class="math inline">\(G_A=\langle V_A, E\rangle\)</span>。定义图
<span class="math inline">\(G\)</span> 的<strong>绝对中心</strong>即为
<span class="math inline">\(G_A\)</span> 的中心，<span
class="math inline">\(G\)</span> 的<strong>绝对半径</strong>即为 <span
class="math inline">\(G_A\)</span> 的半径。容易发现：
<ul>
<li><span class="math inline">\(diam(G_A)=diam(G)\)</span>；</li>
<li><span class="math inline">\(G\)</span> 的直径是绝对半径的两倍</li>
</ul></li>
</ul>
<div data-align="center">
<p><img width="80%" src="2.png" /></p>
</div>
<h2 id="mdst-和-a1cp-等价">MDST 和 A1CP 等价</h2>
<p><em>Theorem.(MDST 和 A1CP 的等价性)</em> 图 <span
class="math inline">\(G\)</span> 的<strong>绝对中心</strong> <span
class="math inline">\(G^*\)</span> 的一棵<strong>最短路径树</strong>
<span class="math inline">\(T^*\)</span> 是 <span
class="math inline">\(G\)</span> 的 MDST。</p>
<p><em>Proof.</em> 给定 <span class="math inline">\(G\)</span>
的任意一棵生成树 <span class="math inline">\(T\)</span>，只需证明 <span
class="math inline">\(diam(T^*)\le diam(T)\)</span>。设 <span
class="math inline">\(T\)</span> 的绝对中心是 <span
class="math inline">\(T^*\)</span>。</p>
<p><span class="math display">\[
\begin{align*}
    diam(T^*)=&amp;2 ecc_{T^*}(G^*) &amp; (直径是绝对半径两倍)\\
             =&amp;2 ecc_{G_A}(G^*) &amp; (最短路径树)\\
             \le &amp;2 ecc_{G_A}(T^*) &amp; (G^* 是 G 的绝对中心)\\
             \le &amp;2 ecc_{T}(T^*) &amp; (T 是 G 的子图)\\
             =&amp; diam(T) &amp; (T 中直径是绝对半径的两倍)
\end{align*}
\]</span></p>
<p>最短路径树可以在 <span class="math inline">\(O(m+n\log n)\)</span>
时间内求出。问题转化为寻找图的绝对中心。</p>
<h2 id="寻找图的绝对中心">寻找图的绝对中心</h2>
<p>[2] (Hakimi, 1964) 给出了求图的绝对中心的方法。</p>
<p>绝对中心即 <span class="math inline">\(G_A\)</span> 上离心率最小的点
<span class="math inline">\(u\in V_A\)</span>，而这样的 <span
class="math inline">\(u\)</span> 一定在某条边上。</p>
<p>故可以<strong>分别考虑每条边上离心率最小的点</strong> <span
class="math inline">\(G^*(e)\)</span>，称为 <span
class="math inline">\(e\)</span>-边绝对中心。最后 <span
class="math inline">\(G^*\)</span> 就是 <span class="math inline">\(\arg
\min_{G^*(e)}ecc(G^*(e))\)</span>。</p>
<h2 id="寻找-e-边绝对中心">寻找 <span
class="math inline">\(e\)</span>-边绝对中心</h2>
<p>对边 <span class="math inline">\(e=(u, v)\)</span>，考虑离 <span
class="math inline">\(u\)</span> 距离为 <span
class="math inline">\(x\)</span> 的内点 <span
class="math inline">\(p\)</span>，它离 <span
class="math inline">\(V\)</span> 中每个顶点 <span
class="math inline">\(w\)</span> 的最小距离为</p>
<p><span class="math inline">\(dist(p, w)=\min(x+dist(u, w),
-x+d_e+dist(v, w))\)</span>。</p>
<div data-align="center">
<p><img width="80%" src="3.png" /></p>
</div>
<p>以 <span class="math inline">\(dist(p, w)\)</span> 和 <span
class="math inline">\(x\)</span> 为坐标系，描述了一个函数关系。</p>
<div data-align="center">
<p><img width="80%" src="4.png" /></p>
</div>
<p>把全部的 <span class="math inline">\(w\)</span>
遍历一遍，可以得到若干的线，取最大值。</p>
<div data-align="center">
<p><img width="80%" src="5.png" /></p>
</div>
<p>容易线性 <span class="math inline">\(O(n)\)</span>
得到全局最小值，从而得到 <span
class="math inline">\(e\)</span>-边绝对中心</p>
<p>对每条边考虑，得到 <span class="math inline">\(G\)</span>
的绝对中心，时间复杂度 <span class="math inline">\(O(nm)\)</span>。</p>
<p>算法瓶颈在于计算 ASAP。总时间复杂度为 <span
class="math inline">\(O(nm+n^2\log n)\)</span>。</p>
<h2 id="总结">总结</h2>
<p>我们可以在 <span class="math inline">\(O(nm+n^2\log n)\)</span>
时间内计算 A1CP，然后用 <span class="math inline">\(O(m+n\log
n)\)</span>
时间内求出绝对中心的最短路径树，即最小直径生成树。总时间复杂度为 <span
class="math inline">\(O(nm+n^2\log n)\)</span>。</p>
<h1 id="mlst">MLST</h1>
<h2 id="最小标签生成树---定义">最小标签生成树 - 定义</h2>
<p><em>Def.</em> 最小标签生成树(MLST)问题：给定图 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 和标签函数 <span
class="math inline">\(L: e\to S_L\)</span>，寻找 <span
class="math inline">\(G\)</span> 的一棵生成树 <span
class="math inline">\(T\)</span>，最小化 <span
class="math inline">\(|L(E(T))|\)</span>，即最小化 <span
class="math inline">\(T\)</span> 使用了的标签数量。</p>
<div data-align="center">
<p><img width="80%" src="6.png" /></p>
</div>
<h2 id="应用场景-1">应用场景</h2>
<p>比如，在信息传递中，边代表传播介质（有光纤、电磁波、电话线、电缆等）。建设成本定义为使用的介质种类，这时最小化成本就是寻找
MLST。</p>
<h2 id="mlst-is-np-hard">MLST is NP-hard</h2>
<p>通过将<strong>最小覆盖问题</strong>归约到 MLST 的判定版本 BLST，得到
BLST 是 NP-Complete，从而 MLST 是 NP-hard。</p>
<p><em>Def.</em> 限制标签生成树(BLST)问题：给定图 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 和 上界 <span
class="math inline">\(W\)</span>，是否存在 <span
class="math inline">\(|L(E(T))| \le W\)</span> 的生成树 <span
class="math inline">\(T\)</span>。</p>
<p>显然 BLST 是 NP 的，只需证明它是 NP-hard，从而是 NP-Complete 的。</p>
<p><em>Def.</em> 最小覆盖问题：给定集合 <span
class="math inline">\(S=\lbrace a_1, a_2, \cdots, a_n\rbrace\)</span> 与
<span class="math inline">\(W\)</span>，和 <span
class="math inline">\(m\)</span> 个 <span
class="math inline">\(S\)</span> 的子集 <span class="math inline">\(C_1,
C_2, \cdots, C_m\subseteq S\)</span>，是否存在 <span
class="math inline">\(\le W\)</span> 个 <span
class="math inline">\(C_i\)</span> 能够覆盖 <span
class="math inline">\(S\)</span>。</p>
<h2 id="归约">归约</h2>
<p>对于给定的最小覆盖问题 <span class="math inline">\(\langle S, W, C_1,
C_2, \cdots, C_m\rangle\)</span>，建图如下：</p>
<div data-align="center">
<p><img width="60%" src="7.png" /></p>
</div>
<p align="center">
图片来源：[3] (Chang &amp; Shing-Jiuan, 1997)
</p>
<p>若存在该图存在 <span class="math inline">\(W+1\)</span>
BLST，则原问题存在 W 最小覆盖。该归约显然是 poly 的。因为最小覆盖是
NP-Complete 的，故 BLST 也是 NP-Complete 的。从而 MLST 是 NP-hard
的。</p>
<p>接下来介绍两种启发式算法和一种基于 A* 的精确算法。</p>
<h2 id="启发式算法---1.-edge-replacement-algorithm">启发式算法 - 1. Edge
Replacement Algorithm</h2>
<p>算法流程：</p>
<ul>
<li>任选一棵生成树 <span class="math inline">\(T\)</span>。</li>
<li>尝试每条非树边，判断将这条边替代合法树边得到 <span
class="math inline">\(T&#39;\)</span>
后使用的标签数能否减小，若可以减小则替代。</li>
</ul>
<p>时间复杂度为 <span class="math inline">\(O(mn)\)</span>。</p>
<h2 id="启发式算法---2.-maximum-vertex-covering-algorithm">启发式算法 -
2. Maximum Vertex Covering Algorithm</h2>
<p>当图不连通时，在还未选过的标签中，选取加入后连通分支数目减少最多的标签，依次反复，直到图连通。</p>
<p>时间复杂度为 <span class="math inline">\(O(lmn)\)</span>，<span
class="math inline">\(l\)</span> 为标签总数。</p>
<h2 id="精确算法---a">精确算法 - A*</h2>
<p>将“每次搜索一个新的标签”的搜索算法改造成 A*。</p>
<p><span class="math display">\[
f(x)=g(x)+h(x)
\]</span></p>
<ul>
<li><span class="math inline">\(g(x)\)</span>
是已经使用了的标签数量；</li>
<li><span class="math inline">\(h(x)\)</span> 计算方法是：
<ul>
<li>首先得到由已选定的标签构成的连通块个数 <span
class="math inline">\(t\)</span>。则还需要 <span
class="math inline">\(need=t-1\)</span> 条边；</li>
<li>然后设<strong>还未选过的标签</strong>对应的边数由高到低为 <span
class="math inline">\(e_1, e_2, \cdots, e_{l&#39;}\)</span>；</li>
<li>设置 <span class="math inline">\(h(x)\)</span> 为最小的 <span
class="math inline">\(j\)</span> 使得 <span
class="math inline">\(\sum_{i=1}^je_i\ge need\)</span>.</li>
</ul></li>
</ul>
<p>可以知道 <span class="math inline">\(h(x)\)</span> 一定 <span
class="math inline">\(\le\)</span> 真实值 <span
class="math inline">\(h^*(x)\)</span>。</p>
<h1 id="参考文献">参考文献</h1>
<p>[1] Hassin, R., &amp; Tamir, A. (1995). On the minimum diameter
spanning tree problem. Information processing letters, 53(2),
109-111.</p>
<p>[2] Hakimi, S. L. (1964). Optimum locations of switching centers and
the absolute centers and medians of a graph. Operations research, 12(3),
450-459.</p>
<p>[3] Chang, R. S., &amp; Shing-Jiuan, L. (1997). The minimum labeling
spanning trees. Information Processing Letters, 63(5), 277-282.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 9 笔记</title>
    <url>/posts/ca406595/</url>
    <content><![CDATA[<p>OT：请调研教材中未介绍过的至少2种判定问题和2种优化问题（不能是相互对应版本，也不能是教材中介绍过的问题的对应版本），讨论适用场景，用教材中的方法形式化描述问题。</p>
<span id="more"></span>
<p><a href="slide/slide.html">Slide</a></p>
<h1 id="字符集编码和问题的形式化描述">字符集编码和问题的形式化描述</h1>
<h2 id="字符集-sigma-的编码能力">字符集 <span
class="math inline">\(\Sigma\)</span> 的编码能力</h2>
<h3 id="引入">引入</h3>
<ul>
<li>字符集 <span class="math inline">\(\Sigma_{bool}\)</span>，<span
class="math inline">\(\Sigma_{latin}\)</span>，<span
class="math inline">\(\lbrace 0, 1, \#\rbrace\)</span>
等有什么本质不同？</li>
</ul>
<blockquote>
<p>e.g. 使用 <span class="math inline">\(\lbrace 0, 1,
\#\rbrace\)</span> 表达带权图？使用 <span class="math inline">\(\lbrace
0, 1\rbrace\)</span> 表达带权图？</p>
</blockquote>
<ol type="1">
<li><p>字符集 <span class="math inline">\(\Sigma\)</span>
的编码能力只和其元素个数 <span class="math inline">\(|\Sigma|\)</span>
有关，和其种类无关(因为存在双射)。</p>
<p>（e.g. <span class="math inline">\(\lbrace 0, 1\rbrace\)</span> 和
<span class="math inline">\(\lbrace a, b\rbrace\)</span>）</p></li>
<li><p>所有基数大于等于 <span
class="math inline">\(2\)</span>(有限)的字符集 <span
class="math inline">\(\Sigma=\lbrace x_0, x_1, \cdots,
x_{|\Sigma|}\rbrace\)</span>
的编码能力相同（编码长度仅差距多项式倍），都和 <span
class="math inline">\(\Sigma_{bool}\)</span> 等价。</p></li>
</ol>
<ul>
<li>若 <span class="math inline">\(w\in
\Sigma_{bool}^*\)</span>，可以使用 <span class="math inline">\(\lbrace
x_0, x_1\rbrace\)</span> 在 <span class="math inline">\(\Sigma\)</span>
上表达 <span class="math inline">\(w\)</span>。</li>
<li>若 <span class="math inline">\(w\in \Sigma^*\)</span>，将 <span
class="math inline">\(\Sigma\)</span> 中的字符用 <span
class="math inline">\(\Sigma_{bool}\)</span> 赋予 <strong><span
class="math inline">\(0/1\)</span> 上的唯一编码</strong>后即可在 <span
class="math inline">\(\Sigma_{bool}\)</span> 上表达 <span
class="math inline">\(w\)</span>。</li>
</ul>
<h3 id="如何赋予唯一编码">如何赋予唯一编码？</h3>
<p><em>(<span class="math inline">\(0/1\)</span> 上的唯一编码)</em> 给定
<span class="math inline">\(\Sigma=\lbrace x_0, x_1, \cdots,
x_{|\Sigma|-1}\rbrace\)</span>，需要输出一个转化函数 <span
class="math inline">\(f: \Sigma\to
\Sigma_{bool}^*\)</span>。约束为：根据 <span
class="math inline">\(f\)</span> 可以确定性地构造函数 <span
class="math inline">\(g_f:\Sigma^*\to \Sigma_{bool}^*\)</span> 为，若
<span class="math inline">\(w=c_1c_2\cdots c_{|w|}, c_i\in
\Sigma\)</span>，则 <span
class="math inline">\(g_f(w)=f(c_1)f(c_2)\cdots
f(c_{|w|})\)</span>，要求 <span class="math inline">\(g_f\)</span>
是<strong>单射</strong>，且 <span
class="math inline">\(|g_f(w)|\)</span> 是 <span
class="math inline">\(|w|\)</span> 的 poly-bounded 倍。</p>
<ul>
<li>形象化理解，需要给 <span class="math inline">\(\Sigma\)</span>
的每个字符用 <span class="math inline">\(0/1\)</span> 编码，并保证对任意
<span class="math inline">\(\Sigma\)</span> 上的词语，改为用 <span
class="math inline">\(0/1\)</span>
表达后不会发生<strong>误读</strong>。</li>
</ul>
<p>e.g. <span class="math inline">\(\lbrace 0, 1, \#\rbrace\)</span>
上的字符串 <span class="math inline">\(11\#01\)</span>
代表了一个有向无权图。定义 <span
class="math inline">\(f(0)=00\)</span>，<span
class="math inline">\(f(1)=01\)</span>，<span
class="math inline">\(f(\#)=10\)</span>，原字符串改写为 <span
class="math inline">\(0101100001\)</span>，两位一读，不会发生误读。</p>
<h3 id="满足条件的-f">满足条件的 <span
class="math inline">\(f\)</span></h3>
<p>从上例可知，一种最简单的编码：对于大小为 <span
class="math inline">\(n=|\Sigma|\)</span> 的字符集 <span
class="math inline">\(\Sigma\)</span>，对每个 <span
class="math inline">\(x_i\in\Sigma\)</span> 固定使用长度为 <span
class="math inline">\(\lceil \lg n\rceil\)</span> 的 <span
class="math inline">\(\Sigma_{bool}\)</span> 词 <span
class="math inline">\(w_i\)</span> 表示（前补零），且 <span
class="math inline">\(Number(w_i)=i\)</span>。</p>
<p>更本质地，什么样的 <span class="math inline">\(f\)</span>
是合法的？</p>
<ul>
<li>只需对任意 <span class="math inline">\(x, y\in \Sigma\)</span> 且
<span class="math inline">\(x\ne y\)</span>，满足 <span
class="math inline">\(f(x)\)</span> 不是 <span
class="math inline">\(f(y)\)</span> 的前缀即可。（在 0/1 trie
树上不同时选择祖先-子孙对）。</li>
</ul>
<blockquote>
<p>思考题：若已知 <span class="math inline">\(w\in
\Sigma^*\)</span>，如何输出合适的 <span
class="math inline">\(f\)</span>，使得 <span
class="math inline">\(g_f(w)\)</span> 尽量短？</p>
</blockquote>
<p>由于字符集 <span class="math inline">\(\Sigma\)</span>
的选取对问题的本质无影响（但编码内容有影响），故以下问题只给出最易于表达的
<span class="math inline">\(\Sigma\)</span>。</p>
<h2 id="some-decision-problems">Some Decision Problems</h2>
<h3 id="有向无环图的判定问题">有向无环图的判定问题</h3>
<p><em>有向无环图的判定问题</em>：给定图 <span
class="math inline">\(G\)</span>，判断其中是否不存在有向环。</p>
<p>形式化地，<em>有向无环图的判定问题</em>是 Decision Problem <span
class="math inline">\((\text{isDAG}, \lbrace 0, 1, \#
\rbrace)\)</span>，其中</p>
<p><span class="math display">\[
    \text{isDAG} = \lbrace w\in \lbrace 0, 1, \#\rbrace^* | \text{$w$
表示一个有向图且无环}\rbrace
\]</span></p>
<ul>
<li>有向(无权)图的表示可以为：对于 <span
class="math inline">\(n\)</span> 阶图，设邻接矩阵为 <span
class="math inline">\(G=(a_{ij})_{n\times n}, a_{ij}\in \lbrace 0,
1\rbrace\)</span>，表示为</li>
</ul>
<p><span class="math display">\[
w_{G}=a_{11}a_{12}\cdots a_{1n}\#a_{21}a_{22}\cdots a_{2n}\#\cdots\#
a_{n1}a_{n2}\cdots a_{nn}
\]</span></p>
<h3 id="停机问题">停机问题</h3>
<p><em>停机问题</em>：给定程序 <span class="math inline">\(P\)</span>
和输入集合 <span class="math inline">\(S\)</span>，判断 <span
class="math inline">\(P\)</span> 是否可以在以任意 <span
class="math inline">\(s\in S\)</span>
作为输入的前提下在有限时间内结束。</p>
<p>如果把 <span class="math inline">\(P\)</span> 使用的字符集记为 <span
class="math inline">\(\Sigma_P\)</span>，即 <span
class="math inline">\(P\in \Sigma_P^*\)</span>，把 <span
class="math inline">\(P\)</span> 的输入使用的字符集记为 <span
class="math inline">\(\Sigma_{in}\)</span>，即 <span
class="math inline">\(S\subseteq \Sigma_{in}^*\)</span>，且定义 <span
class="math inline">\(\perp\)</span> 是在 <span
class="math inline">\(\Sigma_P\cup \Sigma_{in}\)</span>
中未出现的一种字符。则</p>
<p>形式化地，<em>停机问题</em>是 Decision Problem <span
class="math inline">\((\text{Halt}, \Sigma)\)</span>，其中</p>
<p><span class="math display">\[
\Sigma = \Sigma_{P}\cup\Sigma_{in}\cup\lbrace \perp\rbrace
\]</span></p>
<p>且</p>
<p><span class="math display">\[
\text{Halt}=\lbrace w\in\Sigma^*| \text{$w$ 表示程序 $P$ 和
$S$，且满足对任意 $s\in S$ 作为输入 $P$ 可停机}\rbrace
\]</span></p>
<p><span class="math inline">\(w\)</span> 的编码方式可以为</p>
<p><span class="math display">\[
    w=P\perp s_1\perp s_2\perp \cdots \perp s_{|S|}\perp\perp
\]</span></p>
<p>其中 <span class="math inline">\(P\in \Sigma_P^*\)</span> 编码程序
<span class="math inline">\(P\)</span>，<span
class="math inline">\(s_i\in \Sigma_{in}^*\)</span> 编码 <span
class="math inline">\(P\)</span> 的输入 <span
class="math inline">\(s_i\)</span>.</p>
<h2 id="some-optimization-problems">Some optimization problems</h2>
<h3 id="排序问题">排序问题</h3>
<p><em>排序问题</em>：输入 <span class="math inline">\(n\)</span> 和序列
<span class="math inline">\(\langle a_1, a_2, \cdots,
a_n\rangle\)</span>，输出序列的一个重排 <span
class="math inline">\(\langle b_1, b_2, \cdots, b_n\rangle\)</span> 且
<span class="math inline">\(b_1\le b_2\le \cdots \le b_n\)</span>。</p>
<ul>
<li>只需要求解可行解，在可行解之间没有优劣之分。</li>
</ul>
<p>形式化地，<em>排序问题</em>定义为:</p>
<ul>
<li>Input: 正整数 <span class="math inline">\(n\ge 1\)</span>
和正整数序列 <span class="math inline">\(a_1, a_2, \cdots,
a_n\)</span>.</li>
<li>Constraints: 对任意输入实例 <span class="math inline">\((n, a_1,
a_2, \cdots, a_n)\)</span>，<span class="math inline">\(\mathcal M(n,
a_1, a_2, \cdots, a_n)=(b_1, b_2,\cdots, b_n)\)</span>，满足多重集 <span
class="math inline">\(\lbrace a_1, a_2, \cdots, a_n\rbrace=\lbrace b_1,
b_2, \cdots, b_n\rbrace\)</span>，且 <span class="math inline">\(b_1\le
b_2\le \cdots\le b_n\)</span>.</li>
<li>Costs: 对 <span class="math inline">\((b_1, b_2, \cdots, b_n)\in
\mathcal M(n, a_1, a_2, \cdots, a_n)\)</span>，<span
class="math inline">\(cost((b_1, b_2, \cdots, b_n), (n, a_1, a_2,
\cdots, a_n))=0\)</span>.</li>
<li>Goal: 最小化。</li>
</ul>
<h3 id="最小化唯一编码问题">最小化唯一编码问题</h3>
<p><em>(最小化唯一编码问题)</em> 输入 <span
class="math inline">\(\Sigma=\lbrace x_0, x_1, \cdots,
x_{|\Sigma|-1}\rbrace\)</span> 和 <span class="math inline">\(w\in
\Sigma^*\)</span>，需要输出一个转化函数 <span class="math inline">\(f:
\Sigma\to \Sigma_{bool}^*\)</span>。约束为：根据 <span
class="math inline">\(f\)</span> 可以确定性地构造函数 <span
class="math inline">\(g_f:\Sigma^*\to \Sigma_{bool}^*\)</span> 为，若
<span class="math inline">\(w&#39;=c_1c_2\cdots c_{|w|}, c_i\in
\Sigma\)</span>，则 <span
class="math inline">\(g_f(w&#39;)=f(c_1)f(c_2)\cdots
f(c_{|w&#39;|})\)</span>，要求 <span class="math inline">\(g_f\)</span>
是<strong>单射</strong>，且 <span
class="math inline">\(|g_f(w&#39;)|\)</span> 是 <span
class="math inline">\(|w&#39;|\)</span> 的 poly-bounded 倍。最小化 <span
class="math inline">\(g_f(w)\)</span>.</p>
<p>形式化地，<em>最小化唯一编码问题</em>定义为：</p>
<ul>
<li>Input: <span class="math inline">\(\Sigma=\lbrace x_0, x_1, \cdots,
x_{|\Sigma|-1}\rbrace\)</span> 和 <span
class="math inline">\(w=c_1c_2\cdots c_{|w|},
c_i\in\Sigma\)</span>.</li>
<li>Constraints: 对任意输入实例 <span class="math inline">\((x_0, x_1,
\cdots, x_{|\Sigma|-1}, w)\)</span>，<span
class="math inline">\(\mathcal M(x_0, x_1, \cdots, x_{|\Sigma|-1},
w)=(f(x_0), f(x_1), \cdots,
f(x_{|\Sigma|-1}))\)</span>，满足上述约束。</li>
<li>Costs: 对 <span class="math inline">\((f(x_0), f(x_1), \cdots,
f(x_{|\Sigma|-1}))\in\mathcal M(x_0, x_1, \cdots, x_{|\Sigma|-1},
w)\)</span>，<span class="math inline">\(cost((f(x_0), f(x_1), \cdots,
f(x_{|\Sigma|-1})),(x_0, x_1, \cdots, x_{|\Sigma|-1},
w))=\sum_{i=1}^{|w|}|f(c_i)|\)</span>.</li>
<li>Goal: 最小化。</li>
</ul>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 10 笔记</title>
    <url>/posts/226491f8/</url>
    <content><![CDATA[<p>OT：请调研并介绍图灵机及其至少 2 种<a
href="https://en.wikipedia.org/wiki/Turing_machine_equivalents">等价模型</a>，讨论图灵机、P、NP之间的关系。</p>
<span id="more"></span>
<p><a href="slide/slide.html">Slide</a></p>
<h1 id="图灵机及图灵完备性">图灵机及图灵完备性</h1>
<h2
id="确定性图灵机与非确定性图灵机1">确定性图灵机与非确定性图灵机[1]</h2>
<p><em>确定性图灵机(DTM)</em>：六元组 <span
class="math inline">\(M=\langle Q, \Sigma, \iota, \sqcup, A,
\delta\rangle\)</span></p>
<ul>
<li><span class="math inline">\(Q\)</span> 是读写头的状态集合。</li>
<li><span class="math inline">\(\Sigma\)</span> 是纸带字符集。</li>
<li><span class="math inline">\(\iota\in Q\)</span>
是读写头初始状态。</li>
<li><span class="math inline">\(\sqcup \in \Sigma\)</span>
表示空符号。</li>
<li><span class="math inline">\(A\subseteq Q\)</span> 是结束状态。</li>
<li><span class="math inline">\(\delta: (Q\setminus A \times \Sigma)\to
(Q\times \Sigma \times \lbrace L, S, R\rbrace)\)</span>
为<strong>状态转移函数</strong>。</li>
</ul>
<p>使用形式语言的范畴，可以认为 DTM
是一个有存储结构(纸带)的有限状态自动机。</p>
<p><em>非确定性图灵机(NTM)</em>：六元组 <span
class="math inline">\(M=\langle Q, \Sigma, \iota, \sqcup, A,
\delta\rangle\)</span></p>
<ul>
<li><span class="math inline">\(Q\)</span> 是读写头的状态集合。</li>
<li><span class="math inline">\(\Sigma\)</span> 是纸带字符集。</li>
<li><span class="math inline">\(\iota\in Q\)</span>
是读写头初始状态。</li>
<li><span class="math inline">\(\sqcup \in \Sigma\)</span>
表示空符号。</li>
<li><span class="math inline">\(A\subseteq Q\)</span> 是结束状态。</li>
<li><span class="math inline">\(\delta\subseteq(Q\setminus A \times
\Sigma)\times (Q\times \Sigma \times \lbrace L, S, R\rbrace)\)</span>
为<strong>状态转移关系</strong>。</li>
</ul>
<p>可以发现 DTM 和 NTM 的区别仅在于 <span
class="math inline">\(\delta\)</span> 是函数还是关系。</p>
<h2 id="图灵完备性">图灵完备性</h2>
<p>如果一个计算模型/指令系统具有<strong>模拟</strong>一台图灵机的能力，则称它具有图灵完备性。</p>
<p>以下给出两种具有图灵完备性的计算模型。</p>
<h2 id="lambda-演算2">Lambda 演算[2]</h2>
<p>Lambda 演算由 Alonzo Church (Alan Turing
的博导)提出，被证明具有图灵完备性。</p>
<p>现在很多语言都支持函数式编程，Lambda 演算是其中的重要一环。</p>
<h3 id="lambda-演算的基本规则">Lambda 演算的基本规则</h3>
<p>Lambda 演算主要内容是“函数抽象”和“函数应用”</p>
<ul>
<li>变量：如 <span class="math inline">\(x\)</span>, <span
class="math inline">\(y\)</span> 等，用来表示函数参数。</li>
<li>函数抽象：或是函数定义，如 <code>(lambda x. (* x x))</code>
是一个单个参数的函数，返回参数的平方。</li>
<li>函数应用：或是函数调用，如 <code>((lambda x. (* x x)) 233)</code> 将
233 带入左边函数的参数 <span class="math inline">\(x\)</span>，得到
<span class="math inline">\(233^2\)</span>.</li>
</ul>
<h3 id="lambda-演算---多元函数3">Lambda 演算 - 多元函数[3]</h3>
<p>Lambda
演算基础版本中只提供一元函数，但是多元函数可以使用“返回函数的函数”来完成。如计算加法的二元函数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(lambda x y. (+ x y))</span><br></pre></td></tr></table></figure>
<p>可以用“函数的函数”来完成：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(lambda x. (lambda y. (+ x y)))</span><br></pre></td></tr></table></figure>
<p>在应用时，可以方便地后接两个参数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(((lambda x. (lambda y. (+ x y))), 2) 3)</span><br><span class="line">or</span><br><span class="line">((lambda x. (lambda y. (+ x y))), 2 3)</span><br></pre></td></tr></table></figure>
<h3 id="lambda-与编程语言3">Lambda 与编程语言[3]</h3>
<p>可以使用函数来编码编程语言中的基本概念，如 Boolean 和条件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">true = lambda x. lambda y. x</span><br><span class="line">false = lambda x. lambda y. y</span><br><span class="line">if E1 then E2 else E3 (一个三元函数) = E1 E2 E3</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if false then a else b</span><br><span class="line">-&gt; false a b</span><br><span class="line">-&gt; (lambda x. lambda y. y) a b</span><br><span class="line">-&gt; (lambda y.y) b</span><br><span class="line">-&gt; b</span><br></pre></td></tr></table></figure>
<h3 id="使用-lambda-演算">使用 Lambda 演算</h3>
<p>C++, Python 等许多现代编程语言均提供 Lambda
演算，更不用说一些专门的函数式语言。</p>
<p>相信许多同学这样写过（充当匿名函数）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a + n, [] (<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span> &#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br></pre></td></tr></table></figure>
<p>python 中写得更顺畅一点，如加法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="brainfk">Brainf**k</h2>
<p>Brainf**k 由 Urban Müller 创立，仅使用 8
种符号创立的及其简单的语言。</p>
<p>该机器由内存 <code>M</code> 和字节指针 <code>p</code>
构成，初始化内存全为 0。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>&gt;</code></td>
<td style="text-align: center;"><code>++p</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&lt;</code></td>
<td style="text-align: center;"><code>--p</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"><code>++(*p)</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;"><code>--(*p)</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>.</code></td>
<td style="text-align: center;">输出 <code>*p</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>,</code></td>
<td style="text-align: center;">输入 <code>*p</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[</code></td>
<td style="text-align: center;">下详</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>]</code></td>
<td style="text-align: center;">下详</td>
</tr>
</tbody>
</table>
<p>其中 Brainf**k 提供循环格式为</p>
<p><code>A[B]C</code> 表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A;</span><br><span class="line"><span class="keyword">while</span> (*p) &#123; <span class="comment">// here meets [</span></span><br><span class="line">    B;</span><br><span class="line">&#125; <span class="comment">// here meets ]</span></span><br><span class="line">C;</span><br></pre></td></tr></table></figure>
<p>它是图灵完备的。比如使用 Brainf**k 来写 <code>Hello world</code> 为
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="literal">++++++++</span>               <span class="comment">Set Cell #0 to 8</span></span><br><span class="line"><span class="title">[</span></span><br><span class="line">    &gt;<span class="literal">++++</span>               <span class="comment">Add 4 to Cell #1; this will always set Cell #1 to 4</span></span><br><span class="line">    <span class="title">[</span>                   <span class="comment">as the cell will be cleared by the loop</span></span><br><span class="line">        &gt;<span class="literal">++</span>             <span class="comment">Add 2 to Cell #2</span></span><br><span class="line">        &gt;<span class="literal">+++</span>            <span class="comment">Add 3 to Cell #3</span></span><br><span class="line">        &gt;<span class="literal">+++</span>            <span class="comment">Add 3 to Cell #4</span></span><br><span class="line">        &gt;<span class="literal">+</span>              <span class="comment">Add 1 to Cell #5</span></span><br><span class="line">        &lt;&lt;&lt;&lt;<span class="literal">-</span>           <span class="comment">Decrement the loop counter in Cell #1</span></span><br><span class="line">    <span class="title">]</span>                   <span class="comment">Loop until Cell #1 is zero; number of iterations is 4</span></span><br><span class="line">    &gt;<span class="literal">+</span>                  <span class="comment">Add 1 to Cell #2</span></span><br><span class="line">    &gt;<span class="literal">+</span>                  <span class="comment">Add 1 to Cell #3</span></span><br><span class="line">    &gt;<span class="literal">-</span>                  <span class="comment">Subtract 1 from Cell #4</span></span><br><span class="line">    &gt;&gt;<span class="literal">+</span>                 <span class="comment">Add 1 to Cell #6</span></span><br><span class="line">    <span class="title">[</span>&lt;<span class="title">]</span>                 <span class="comment">Move back to the first zero cell you find; this will</span></span><br><span class="line">                        <span class="comment">be Cell #1 which was cleared by the previous loop</span></span><br><span class="line">    &lt;<span class="literal">-</span>                  <span class="comment">Decrement the loop Counter in Cell #0</span></span><br><span class="line"><span class="title">]</span>                       <span class="comment">Loop until Cell #0 is zero; number of iterations is 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">The result of this is:</span></span><br><span class="line"><span class="comment">Cell no :   0   1   2   3   4   5   6</span></span><br><span class="line"><span class="comment">Contents:   0   0  72 104  88  32   8</span></span><br><span class="line"><span class="comment">Pointer :   ^</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">.</span>                     <span class="comment">Cell #2 has value 72 which is &#x27;H&#x27;</span></span><br><span class="line">&gt;<span class="literal">---</span><span class="string">.</span>                   <span class="comment">Subtract 3 from Cell #3 to get 101 which is &#x27;e&#x27;</span></span><br><span class="line"><span class="literal">+++++++</span><span class="string">.</span><span class="string">.</span><span class="literal">+++</span><span class="string">.</span>           <span class="comment">Likewise for &#x27;llo&#x27; from Cell #3</span></span><br><span class="line">&gt;&gt;<span class="string">.</span>                     <span class="comment">Cell #5 is 32 for the space</span></span><br><span class="line">&lt;<span class="literal">-</span><span class="string">.</span>                     <span class="comment">Subtract 1 from Cell #4 for 87 to give a &#x27;W&#x27;</span></span><br><span class="line">&lt;<span class="string">.</span>                      <span class="comment">Cell #3 was set to &#x27;o&#x27; from the end of &#x27;Hello&#x27;</span></span><br><span class="line"><span class="literal">+++</span><span class="string">.</span><span class="literal">------</span><span class="string">.</span><span class="literal">--------</span><span class="string">.</span>    <span class="comment">Cell #3 for &#x27;rl&#x27; and &#x27;d&#x27;</span></span><br><span class="line">&gt;&gt;<span class="literal">+</span><span class="string">.</span>                    <span class="comment">Add 1 to Cell #5 gives us an exclamation point</span></span><br><span class="line">&gt;<span class="literal">++</span><span class="string">.</span>                    <span class="comment">And finally a newline from Cell #6</span></span><br></pre></td></tr></table></figure></p>
<h2 id="图灵机与-p-和-np">图灵机与 P 和 NP</h2>
<ul>
<li>P: 在确定性图灵机上可以在多项式步内判定的语言。</li>
<li>NP: 在非确定性图灵机上可以在多项式步内判定的语言。</li>
</ul>
<p>此处，非确定性图灵机可以认为是能够“神奇地选择最易方式”，或是“在遇到分支形成副本”，从而也就和
TC 中 NP 定义中的 certificate 不谋而合。存在的 certificate
指引确定性图灵机模拟一台非确定性图灵机走正确道路的那条分支的结果。</p>
<h1 id="参考文献">参考文献</h1>
<p>[1] https://en.wikipedia.org/wiki/Turing_machine</p>
<p>[2] https://en.wikipedia.org/wiki/Lambda_calculus</p>
<p>[3]
https://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 11 笔记</title>
    <url>/posts/eece9166/</url>
    <content><![CDATA[<p>OT：除福特-法尔克森算法外，最大流问题还有很多其它算法，例如
Edmonds-Karp 算法、Dinitz 算法、Push-Relabel
算法等，请调研至少2种算法（其中至多1种来自上述例子），结合例子介绍算法的设计与分析，与福特-法尔克森算法比较异同并分析优劣。</p>
<span id="more"></span>
<p><a href="slide/slide.html">slide</a></p>
<h1 id="任意图上-onm-的网络最大流算法">任意图上 <span
class="math inline">\(O(nm)\)</span> 的网络最大流算法</h1>
<h2 id="引言">引言</h2>
<p>[1] (Orlin, 2013) 给出了一种在任意图上 <span
class="math inline">\(O(nm)\)</span> 的网络最大流算法。</p>
<h2 id="前置结果和本文贡献">前置结果和本文贡献</h2>
<p>[1] 中的若干证明用到了一些前置结果：</p>
<ul>
<li>[2] (King et al., 1994) 给出了强多项式 <span
class="math inline">\(O(nm\log_{m/(n\log n)})\)</span> 的算法。对于任意
<span
class="math inline">\(m=\Omega(n^{1+\epsilon})\)</span>，该算法都是
<span class="math inline">\(O(nm)\)</span> 的。</li>
<li>[3] (Goldberg &amp; Rao, 1998) 给出了弱多项式的算法，每轮将 <span
class="math inline">\(\Delta\)</span> bounded 的最大流问题转化为 <span
class="math inline">\(\Delta/2\)</span> bounded 的最大流问题，每轮时间为
<span class="math inline">\(O(\min\lbrace n^{2/3}, m^{1/2}\rbrace\cdot
m\log (n^2/m))\)</span>。</li>
</ul>
<p>可以发现，需要攻克的仅在于 <span class="math inline">\(m\)</span>
不超过多项式地渐进大于 <span class="math inline">\(n\)</span> 时。</p>
<p>本文提出 <span class="math inline">\(O(nm+m^{31/16}\log^2n)\)</span>
的算法。当 <span
class="math inline">\(m=O(n^{(16/15)-\epsilon})\)</span> 时，该结果是
<span class="math inline">\(O(nm)\)</span> 的。</p>
<p>和上文第一个结果相结合，得到了对任意图 <span
class="math inline">\(O(nm)\)</span> 的网络最大流算法。</p>
<h2 id="主要思路">主要思路</h2>
<p>主要利用某种方法套用了 Goldberg 的结果：若最大流为 <span
class="math inline">\(U\)</span>，则时间为 <span class="math display">\[
T(n)=\tilde O(\min\lbrace n^{2/3}, m^{1/2}\rbrace\cdot m\log U).
\]</span></p>
<ul>
<li>若 <span class="math inline">\(\log U\le
m^{7/16}\)</span>，则有</li>
</ul>
<p><span class="math display">\[
    T(n)=\tilde O(m^{1/2}\cdot m\cdot m^{7/16})=\tilde O(m^{31/16}),
\]</span></p>
<p>已然满足条件。</p>
<ul>
<li>若 <span class="math inline">\(\log U\le
m^{7/16}\)</span>，则在每轮前，把原图<strong>压缩</strong>成 <span
class="math inline">\(C\)</span> 顶点、<span
class="math inline">\(O(C^2)\)</span> 边的图。平均 <span
class="math inline">\(C=O(m/\log U)\)</span>，则单轮中 <span
class="math inline">\(n&#39;=C,
m&#39;=O(C^2)\)</span>，带入有单轮时间为</li>
</ul>
<p><span class="math display">\[
    \tilde O(C^{2/3}\cdot C^2)=\tilde O(C^{8/3}).
\]</span></p>
<p>于是 <span class="math inline">\(O(\log U)\)</span> 轮总时间为</p>
<p><span class="math display">\[
    T(n)=\tilde O(C^{8/3}\log U)=\tilde O(m^{8/3}\log^{-5/3}U)=\tilde
O(m^{8/3}\cdot (m^{7/16})^{-5/3})=\tilde O(m^{16/31}).
\]</span></p>
<p>故问题的核心在于：要寻求一种<strong>压缩方式</strong>使得平均 <span
class="math inline">\(C=O(m/\log U)\)</span>，且对于流的影响较小。</p>
<h2 id="基本方法">基本方法</h2>
<p>[1] 提出的算法同样由 <span class="math inline">\(O(\log U)\)</span>
构成，每轮的步骤是：</p>
<ol type="1">
<li><p>收缩(comtraction)。</p></li>
<li><p><strong>压缩</strong>（算法的核心）。</p></li>
<li><p>运行 Goldberg。</p></li>
<li><p>恢复对应到原图。</p></li>
</ol>
<h2 id="abundant-arc">Abundant Arc</h2>
<p>每轮算法的输入和输出都表示为 <span class="math inline">\((r, S,
T)\)</span>，其中 <span class="math inline">\(r\)</span>
是残余网络，<span class="math inline">\(C_{S, T}\)</span>
是一组源汇割。可知在残余网络中至多还可以增长 <span
class="math inline">\(c(S, T)\)</span> 的流，记作<strong>流上限</strong>
<span class="math inline">\(\Delta=c(S, T)\)</span>（和 Goldberg 中的
<span class="math inline">\(\Delta\)</span> 同义）。</p>
<p><strong>Abundant Arc</strong>: 若有一边 <span
class="math inline">\(r(e)\ge 2\Delta\)</span>，则称其为 <span
class="math inline">\(\Delta\)</span>-Abundant Arc.</p>
<p><em>Theorem</em>: 若在某轮算法中，输入为 <span
class="math inline">\((r, S, T): \Delta\)</span>，输出为 <span
class="math inline">\((r&#39;, S&#39;, T&#39;):
\Delta&#39;\)</span>，且若 <span class="math inline">\(r(e)\ge
2\Delta\)</span> 是 <span class="math inline">\(\Delta\)</span>-Abundant
Arc，则在结束后，<span class="math inline">\(r&#39;(e)\ge
2\Delta&#39;\)</span> 是 <span
class="math inline">\(\Delta&#39;\)</span>-Abundant Arc.</p>
<p><em>Proof</em>: 设 <span class="math inline">\(e\)</span> 增广了
<span class="math inline">\(x\)</span>，即 <span
class="math inline">\(r(e)-r&#39;(e)=x\)</span>，则有 <span
class="math inline">\(\Delta&#39;\le \Delta-x\)</span>。故而</p>
<p><span class="math display">\[
\begin{align*}
    r&#39;(e)&amp;=r(e)-x\\
        &amp;\ge 2\Delta-x\\
        &amp;\ge 2(\Delta&#39;+x)-x\\
        &amp;\ge 2\Delta&#39;
\end{align*}
\]</span></p>
<p>故而 Abundant Arc 集合只会增加，不会减少。</p>
<h2 id="收缩">收缩</h2>
<p>对输入 <span class="math inline">\((r, S, T)\)</span>，可以先将
<strong>Abundant Arc
环</strong>收缩：在收缩后的图上的流，必然可以满足收缩前的图的流。</p>
<p>对于算法的 3. 运行 Goldberg，为了证明的方便，假设结束后的流 <span
class="math inline">\(\Delta&#39;\le
\Delta/(8m)\)</span>。可以发现复杂度只影响对数倍。</p>
<h2 id="四类弧">四类弧</h2>
<p>把图中所有弧分为四类：</p>
<ul>
<li>Little Arc(<span class="math inline">\(L\)</span>)：弧 <span
class="math inline">\(\langle i, j\rangle\)</span> 满足 <span
class="math inline">\(c(\langle i, j\rangle) + c(\langle j,
i\rangle)&lt; \Delta/(64m^3)\)</span>.</li>
<li>Medium Arc(<span class="math inline">\(M\)</span>): 弧 <span
class="math inline">\(\langle i, j\rangle\)</span> 满足上式 <span
class="math inline">\(\ge \Delta/(64m^3)\)</span>，但正、反向弧都不是
Abundant Edge。</li>
<li>Abundant Arc(<span class="math inline">\(A\)</span>)。</li>
<li>Anti Abundant Arc(<span
class="math inline">\(A&#39;\)</span>)：反向弧在 <span
class="math inline">\(A\)</span> 中的弧。</li>
</ul>
<p>注意到因为收缩后的图无 Abundant Arc 环，故一条边不能既在 <span
class="math inline">\(A\)</span> 中又在 <span
class="math inline">\(A&#39;\)</span> 中。<span class="math inline">\(L,
M, A, A&#39;\)</span> 构成了弧集的一个划分。</p>
<h2 id="压缩---压缩掉一些顶点">压缩 - 压缩掉一些顶点</h2>
<p>如果一个顶点<strong>同时</strong>满足以下两个条件，则它可以被压缩（Compatible）：</p>
<ul>
<li>与它相邻的边没有 Medium Arc；</li>
<li>进入它的 Anti Abundant Arc 的残余容量和与离开它的相差不超过 <span
class="math inline">\(\Delta/(16m^2)\)</span>。</li>
</ul>
<p>换言之：一个顶点保留（是
Criticle）的条件是，满足以下条件<strong>之一</strong>：</p>
<ul>
<li>与它相邻的边有 Medium Arc；</li>
<li>进入它的 Anti Abundant Arc 的残余容量和与离开它的相差超过 <span
class="math inline">\(\Delta/(16m^2)\)</span>。</li>
</ul>
<p>直观理解，当一个顶点旁边的与 Abundant Arc
无关的边都是微不足道的时候，且 Anti Abundant Arc
流入和流出量基本相抵时，它是不重要的。</p>
<h2 id="压缩---忽略掉一些路径">压缩 - 忽略掉一些路径</h2>
<p>如果一条路径 <span class="math inline">\(P\)</span> 中，存在某条
Little Arc： 则它可以增流的量至多为 <span
class="math inline">\(\Delta/(64m^3)\)</span>，可以忽略。故只需考虑
<span class="math inline">\(P\)</span> 经过 Medium Arc、Abundant Arc 和
Anti Abundant Arc。</p>
<p><em>Claim</em>: <span class="math inline">\(P\)</span> 中若存在 Anti
Abundant Subpath 是以 Compatible 顶点为端点，则也可以忽略。</p>
<p>因此，只需考虑的路径是：仅包含 Medium Arc、Abundant Arc、Auti
Abundant Path（以 Criticle 顶点为端点）的路径。</p>
<p>于是<strong>只需在 Criticle 顶点和以下三种边中运行 Goldberg
最大流算法</strong>: 当 <span class="math inline">\(i, j\)</span> 都是
Criticle 时</p>
<ul>
<li>Medium 边；</li>
<li>伪 Abundant 弧：若在原图中存在 <span
class="math inline">\(i\Rightarrow j\)</span> 的
<strong>Abundant</strong> Path，则有容量为 <span
class="math inline">\(2\Delta\)</span> 的 <span
class="math inline">\(\langle i, j\rangle\)</span> 弧；</li>
<li>伪 Anti Abundant 弧：若在原图中存在 <span
class="math inline">\(i\Rightarrow j\)</span> 的 Anti Abundant
Path，则有容量为所有这样的路径的残余容量和的弧 <span
class="math inline">\(\langle i, j\rangle\)</span>。</li>
</ul>
<h2 id="复杂度证明">复杂度证明</h2>
<p><em>Theorem</em>: Criticle 顶点在<strong>全部</strong> <span
class="math inline">\(O(\log U)\)</span> 轮算法中共 <span
class="math inline">\(O(m)\)</span> 个，故每轮平均 <span
class="math inline">\(O(m/\log U)\)</span>，故开头的复杂度分析正确。</p>
<p><em>Proof</em>: 注意到对于原图中的弧:</p>
<ul>
<li>对于 <em>Medium Arc</em>，在 <span class="math inline">\(3\)</span>
次操作后一定会变成 Abundant Arc；</li>
<li>对于所有相邻弧都不是 <em>Medium Arc</em>，但是因为"进入它的 Anti
Abundant Arc 的残余容量和与离开它的相差超过 <span
class="math inline">\(\Delta/(16m^2)\)</span>"而不能被压缩的 Criticle
顶点，在 <span class="math inline">\(4\)</span> 轮后一定会有一条 Anti
Abundant Arc 变为 Abundant Arc，进而形成 Abundant Cycle 被收缩。</li>
</ul>
<h1 id="dinic-算法">Dinic 算法</h1>
<p>(尽管正确的名字可能是 Dinitz，但就这么叫了)</p>
<h2 id="主要思想">主要思想</h2>
<p>每次对于残余网络 <span class="math inline">\(r\)</span>，进行一次
BFS，按照从 <span class="math inline">\(s\)</span>
的距离得到<strong>分层图</strong> <span
class="math inline">\(r_d\)</span>。</p>
<p>对于 <span class="math inline">\(r_d\)</span>
进行<strong>若干次</strong> DFS，找出在 <span
class="math inline">\(r_d\)</span> 上 <strong>阻塞流</strong>，即无法从
<span class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 得到更多的流(不考虑退流)。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Dinic</span>(<span class="params">r, s, t</span>):</span><br><span class="line">    maxflow = <span class="number">0</span></span><br><span class="line">    flow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> bfs() gets a connective graph <span class="keyword">from</span> s to t:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            flow = dfs(s, INF)</span><br><span class="line">            maxflow += flow</span><br><span class="line">            <span class="keyword">if</span> (flow == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> maxflow</span><br></pre></td></tr></table></figure>
<p>可以看到 Dinic 算法是 Ford-Fulkerson 增广的一种变种，正确性证明和 FF
算法相同，以下主要考虑其复杂度。</p>
<h2 id="算法复杂度">算法复杂度</h2>
<p><em>Theorem 1</em>：对于单轮的分层图，DFS 求出阻塞流的复杂度为 <span
class="math inline">\(O(nm)\)</span>。</p>
<p><em>Theorem 2</em>: Dinic 算法至多考虑 <span
class="math inline">\(O(n)\)</span> 次分层图。</p>
<p><em>Theorem 3</em>: 从上述两个定理可知，Dinic 算法的总复杂度为 <span
class="math inline">\(O(n^2m)\)</span>，但对于平均情况（以及特殊网络）有更好的复杂度。</p>
<h2 id="特殊图上的复杂度">特殊图上的复杂度</h2>
<ul>
<li><p>若网络中全部弧的容量均为 <span
class="math inline">\(1\)</span>，则 Dinic 算法的复杂度为 <span
class="math inline">\(O(m\cdot \min\lbrace n^{2/3},
m^{1/2}\rbrace)\)</span>。</p></li>
<li><p>若网络中全部弧的容量均为 <span
class="math inline">\(1\)</span>，且除源点和汇点外的每个点均满足 <span
class="math inline">\(d^-(u)=1\)</span> 或 <span
class="math inline">\(d^+(u)=1\)</span>，则 Dinic 算法的复杂度为 <span
class="math inline">\(O(m\sqrt n)\)</span>。</p></li>
</ul>
<p>对于二分图最大匹配，注意到该复杂度与 Hopcroft-Karp
算法相同。实质上，两个算法的本质是相同的。</p>
<h1 id="参考资料">参考资料</h1>
<p>[1] James B. Orlin. 2013. Max flows in O(nm) time, or better. In
Proceedings of the forty-fifth annual ACM symposium on Theory of
Computing (STOC '13). Association for Computing Machinery, New York, NY,
USA, 765–774. https://doi.org/10.1145/2488608.2488705</p>
<p>[2] V. King, S. Rao, and R. Tarjan. A faster deterministic maximum
flow algorithm. J. Algorithms, 23:447–474, 1994.</p>
<p>[3] A. V. Goldberg and S. Rao. Beyond the flow decomposition barrier.
Journal of the ACM, 45:783–797, 1998.</p>
<p>[4] https://oi-wiki.org/graph/flow/max-flow/</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 12 笔记</title>
    <url>/posts/60419685/</url>
    <content><![CDATA[<p>OT：除MAX-SAT和TSP外，分支定界和局部搜索算法还可用于解决其它问题，请为每种算法调研至少1种可以解决的问题，结合例子介绍算法的设计与分析。</p>
<span id="more"></span>
<p><a href="slide/slide.html">slide</a></p>
<h1 id="分支定界和局部搜索算法">分支定界和局部搜索算法</h1>
<h2 id="分支定界算法的应用">分支定界算法的应用</h2>
<h3 id="问题引出小木棍">问题引出——小木棍</h3>
<p>有一些同样长的小木棍，他把这些木棍随意砍成几段。现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。
给出每段小木棍的长度，求原始木棍的最小可能长度。</p>
<h3 id="问题分析形式化描述">问题分析——形式化描述</h3>
<ul>
<li>输入：<span class="math inline">\(\langle n, a_1, a_2, \cdots,
a_n\rangle\)</span>。</li>
<li>约束 <span class="math inline">\(\mathcal M(x)=\)</span> <span
class="math display">\[
  \left\lbrace \langle m,\lbrace S_1, S_2, \cdots, S_m\rbrace \rangle:
\sum_{S_1}=\sum_{S_2}=\cdots=\sum_{S_m} \text{且 $\lbrace S_i\rbrace$
构成 $\lbrace a_1, a_2, \cdots, a_n\rbrace$ 的一个划分}\right\rbrace.
\]</span></li>
<li>代价：<span class="math inline">\(m\)</span>。</li>
<li>目标：最大化。（即最小化 <span
class="math inline">\(sum/m\)</span>）</li>
</ul>
<h3 id="问题分析性质">问题分析——性质</h3>
<ol type="1">
<li>显然 <span class="math inline">\(m\mid \sum a_i\)</span>。</li>
<li>可知 <span class="math inline">\(m\le n\)</span>，可以多项式时间枚举
<span class="math inline">\(m\)</span>，故 <span
class="math inline">\(A=\sum a_i/m\)</span>
每组的和得以确定。则只需解决一个判定问题</li>
</ol>
<h3 id="问题分析回溯算法">问题分析——回溯算法</h3>
<p>可以分组确定：先确定第一组的组成，再是第二组的组成。使用回溯算法，用
<span class="math inline">\(S(S_1, S_2, \cdots, S_{i-1}, \lbrace b_1,
b_2, \cdots, b_t\rbrace)\)</span>，表示已经确定了前 <span
class="math inline">\(i-1\)</span> 组，第 <span
class="math inline">\(i\)</span> 组已经选定了 <span
class="math inline">\(\lbrace b_1, b_2, \cdots, b_{t}\rbrace\subseteq
S_i\)</span> 这些元素。则状态转移可以决定下一个 <span
class="math inline">\(b_{t+1}\in S_i\)</span> 使得总和 <span
class="math inline">\(\le A\)</span>。</p>
<h3 id="问题分析分支定界">问题分析——分支定界</h3>
<p>观察，可以 pre-compute 进行对搜索树的裁剪：</p>
<ol type="1">
<li>对于 <span
class="math inline">\(b_1\)</span>，一定选择第一个当前未取过的，因为它一定要包含在某组内（该步不进行分支）。且在替代时从前往后尝试。</li>
<li>将 <span class="math inline">\(a_i\)</span>
从大到小排序，在某次失败时跳过之后连续几个相同的 <span
class="math inline">\(a_i\)</span>。</li>
</ol>
<h2 id="局部搜索算法最大团问题">局部搜索算法——最大团问题</h2>
<p>最大团问题：求图中的最大团的阶。</p>
<p>是很经典的 NP Complete。考虑使用局部搜索尝试获得 Local Optima</p>
<h3 id="neibourhood">Neibourhood</h3>
<p>每个可行解是一个团 <span class="math inline">\(V\subseteq
G\)</span>。考虑在 <span class="math inline">\(V\)</span> 中加入一个顶点
<span class="math inline">\(x\)</span> 作为其非平凡邻居。</p>
<ul>
<li>但是 <span class="math inline">\(V\cup\lbrace x\rbrace\)</span>
不一定是团：<span class="math inline">\(x\)</span> 不一定和 <span
class="math inline">\(V\)</span> 中所有点都有边。</li>
<li>设 <span class="math inline">\(x\)</span> 的邻点是 <span
class="math inline">\(N(x)\)</span>，则 <span
class="math inline">\(V&#39;=(V\cap N(x))\cup\lbrace x\rbrace\)</span>
是团。定义为 <span class="math inline">\(V\)</span> 的邻居。</li>
</ul>
<h3 id="证明-neibourhood">证明 Neibourhood</h3>
<ul>
<li>自反性：定义为平凡邻居</li>
<li>对称性：容易发现该定义是不对称的，但若将其视作有向图，则它是强连通的。</li>
<li>可达性：每次加入目标团的一个顶点，显然可达。</li>
</ul>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 13 笔记</title>
    <url>/posts/aceb961b/</url>
    <content><![CDATA[<p>OT：除IP外，广义的“松弛-修正”思想还可用于解决其它问题，例如<a
href="https://link.springer.com/article/10.1007/s43069-021-00101-z">TSP的松弛修正算法</a>、<a
href="https://dl.acm.org/doi/10.1145/179812.179818">最短超串问题的松弛修正算法</a>等，请调研至少2种算法（其中至多1种来自上述例子），结合例子介绍算法的设计与分析，重点阐述其中的“松弛-修正”思想。</p>
<span id="more"></span>
<p><a href="slide/slide.html">slide</a></p>
<h1 id="欧拉图在松弛修正算法中的应用">欧拉图在松弛修正算法中的应用</h1>
<h2 id="introduction">Introduction</h2>
<p>在某些松弛修正算法的分析中，欧拉图经常出现。本次报告选择了以下两个主题：</p>
<ul>
<li>在线斯坦纳树的贪心算法</li>
<li>Metric TSP 的启发式算法。包括 MST Heuristic 算法和改进的
Christofides 算法。</li>
</ul>
<h2 id="在线斯坦纳树">在线斯坦纳树</h2>
<h3 id="description">Description</h3>
<ul>
<li><strong>提前给定</strong>：连通无向图 <span
class="math inline">\(G=\langle V, E\rangle\)</span>，非负权。</li>
<li><strong>在线回答</strong>：依次给定 <span class="math inline">\(t_1,
t_2, \cdots, t_k\)</span>，在给定 <span class="math inline">\(t_i(1\le
i\le k)\)</span> 后将其增量连接到 <span
class="math inline">\(i-1\)</span> 时构造的子图。要求使得在 <span
class="math inline">\(k\)</span> 次迭代后的子图边权和尽量小。</li>
</ul>
<p>容易发现是最小斯坦纳树问题的在线版本。</p>
<h3 id="assumptions">Assumptions</h3>
<p>不失一般性地假设：</p>
<ol type="1">
<li>图 <span class="math inline">\(G=\langle V, E\rangle\)</span>
是完全图。</li>
<li>图 <span class="math inline">\(G\)</span>
中边权满足三角不等式(metric)。</li>
</ol>
<p>其中假设 1. 不失一般性，因为非完全图可补充无穷大的边；</p>
<p>假设 2. 不失一般性，是由算法决定的。</p>
<h3 id="a-greedy-method">A greedy method</h3>
<ol type="1">
<li>一开始选择空树 <span class="math inline">\(T_0\)</span>。</li>
<li>对于 <span class="math inline">\(t_1\)</span>，令 <span
class="math inline">\(T_1=T_0\)</span> 也为空树。</li>
<li>对于 <span class="math inline">\(t_j(2\le j\le
k)\)</span>，选择最小的边 <span class="math inline">\(( t_i, t_j),
i&lt;j\)</span> 加入 <span class="math inline">\(T_{j-1}\)</span> 中得到
<span class="math inline">\(T_j\)</span>。</li>
<li><span class="math inline">\(T=T_k\)</span> 即为最终解，<span
class="math inline">\(cost(\text{GREEDY})=cost(T_k)\)</span>。</li>
</ol>
<p><img src="1.png" width="80%"/></p>
<p>(picture from [1])</p>
<p>直观地理解：每次将 <span class="math inline">\(t_i\)</span>
以最小代价“贴”到现存的树上去。</p>
<h3 id="instances">Instances</h3>
<div data-align="center" style="display: flex">
<div style="flex: 1">
<p><img src="2.png" width="100%" /></p>
</div>
<div style="flex: 1.7">
<p><img src="3.png" width="100%" /></p>
</div>
</div>
<p>其中对于样例右，最优解为 <span
class="math inline">\(4\)</span>，但贪心算法求得的解为 <span
class="math inline">\(8\)</span>。</p>
<p><em>Theorem</em>: 该贪心算法最坏 performance ratio 为 <span
class="math inline">\(\Omega(\log k)\)</span>。</p>
<p><em>Theorem</em>:
对<strong>任何</strong>在线斯坦纳树的算法，最坏情况下的 performance
ratio 都是 <span class="math inline">\(\Omega(\log k)\)</span>。</p>
<h3 id="algorithm-analysis">Algorithm analysis</h3>
<p><em>Theorem</em>: 该贪心算法的 performance ratio <span
class="math inline">\(&lt; 2\ln k\)</span>，从而该贪心算法渐进最优。</p>
<p><em>Proof</em>: 要证该定理，只需证明</p>
<blockquote>
<p><em>Lemma</em>: 对任意 <span class="math inline">\(p=1, 2, \cdots,
k-1\)</span>，该贪心算法选择的 <span class="math inline">\(T\)</span>
中第 <span class="math inline">\(p\)</span> 大的边权不超过 <span
class="math inline">\(2OPT/p\)</span>，其中 <span
class="math inline">\(OPT\)</span> 是全局最优解。</p>
</blockquote>
<p>若该引理成立，则设 <span class="math inline">\(T\)</span>
中所有边按边权从大到小排为 <span class="math inline">\(e_1, e_2, \cdots,
e_{k-1}\)</span>，有</p>
<p><span class="math display">\[
e_p\le \frac{2OPT}{p}, p=1, 2, \cdots, k-1.
\]</span></p>
<p>故而</p>
<p><span class="math display">\[
cost(\text{GREEDY})=\sum_{p=1}^{k-1} e_p\le
\sum_{p=1}^{k-1}\frac{2OPT}{p}&lt;2OPT\ln k.
\]</span></p>
<p>从而</p>
<p><span class="math display">\[
\alpha=\frac{cost(\text{GREEDY})}{OPT}&lt;2\ln k.
\]</span></p>
<h3 id="proof-of-the-lemma">Proof of the Lemma</h3>
<p><em>Lemma</em>: 对任意 <span class="math inline">\(p=1, 2, \cdots,
k-1\)</span>，该贪心算法选择的 <span class="math inline">\(T\)</span>
中第 <span class="math inline">\(p\)</span> 大的边权不超过 <span
class="math inline">\(2OPT/p\)</span>，其中 <span
class="math inline">\(OPT\)</span> 是全局最优解。</p>
<p><em>Proof</em>:</p>
<ol type="1">
<li>设 <span class="math inline">\(T^*\)</span>
是全局最优解对应的斯坦纳树，<span
class="math inline">\(OPT=cost(T^*)\)</span>。</li>
<li>将 <span class="math inline">\(T^*\)</span>
所有边都复制一份，可以得到一个所有顶点都为偶点的图 <span
class="math inline">\(H\)</span>，故其具有欧拉回路 <span
class="math inline">\(C\)</span>，且 <span
class="math inline">\(cost(C)=2OPT\)</span>。</li>
<li>对给定的 <span class="math inline">\(p\in \lbrace 1, 2, \cdots,
k-1\rbrace\)</span>。定义一个点 <span
class="math inline">\(t_j(j&gt;1)\)</span> 的连通代价为在 GREEDY 中将
<span class="math inline">\(t_j\)</span> 与 <span
class="math inline">\(T_{j-1}\)</span> 合并得到 <span
class="math inline">\(T_{j}\)</span> 的新增代价（即权值最小的 <span
class="math inline">\((t_i, t_j), i&lt;j\)</span> 边）。设连通代价最高的
<span class="math inline">\(p\)</span> 个依次为 <span
class="math inline">\(s_1, s_2, \cdots, s_{p}\subseteq \lbrace t_2, t_3,
\cdots, t_k\rbrace\)</span>。不妨设连通代价 <span
class="math inline">\(w(s_j)\)</span> 依次递减，则该命题只需证明：<span
class="math inline">\(w(t_k)\le 2OPT/i\)</span>。</li>
<li>由于 <span class="math inline">\(C\)</span> 经过 <span
class="math inline">\(t_1, t_2, \cdots, t_k\)</span>
中的每个点，故也经过 <span class="math inline">\(s_1, s_2, \cdots,
s_p\)</span>。可以将欧拉回路 <span class="math inline">\(C\)</span>
进行“裁剪”得到一个 <span class="math inline">\(s_1, s_2, \cdots,
s_p\)</span> 的哈密尔顿圈 <span
class="math inline">\(C&#39;\)</span>：由于图满足三角不等式，可将路径用其端点关联的边直接替代，且
<span class="math inline">\(cost(C&#39;)\le cost(C)=2OPT\)</span>。</li>
<li><span class="math inline">\(C&#39;\)</span> 中含有 <span
class="math inline">\(p\)</span> 条边，故其最小边 <span
class="math inline">\((s_i, s_j)\)</span> 满足 <span
class="math inline">\(w((s_i, s_j))\le cost(C&#39;)/p\le
2OPT/p\)</span>.</li>
<li>不妨设 <span class="math inline">\(i&lt;j\)</span>，则 <span
class="math inline">\(s_j\)</span> 的连通代价不超过 <span
class="math inline">\((s_i,s_j)\le 2OPT/p\)</span>，从而命题得证。</li>
</ol>
<div data-align="center" style="display: flex">
<div style="flex: 1">
<p><img src="4.png" width="95%" /></p>
</div>
<div style="flex: 1.2">
<p><img src="5.png" width="95%" /></p>
</div>
</div>
<h3 id="heuristic">Heuristic</h3>
<p>可以发现采用的是“构造偶点图 <span class="math inline">\(\to\)</span>
得到欧拉回路 <span class="math inline">\(\to\)</span>
得到哈密尔顿圈”的分析方法。在 TSP
的近似算法中，可以再次发现这种想法的应用。</p>
<h3 id="reason-of-the-2nd.-assumption">Reason of the 2nd.
assumption</h3>
<p>若某图不满足三角不等式，可现在其最短路径闭包上使用上述算法，并映射回原图。</p>
<h2 id="metric-tsp">Metric TSP</h2>
<h3 id="description-1">Description</h3>
<p><em>Definition(Metric TSP)</em>: 给定非负权无向连通图 <span
class="math inline">\(G=\langle V,
E\rangle\)</span>，<strong>满足三角不等式</strong>，求最小化 <span
class="math inline">\(cost(H)\)</span> 的哈密尔顿圈 <span
class="math inline">\(H\)</span>。</p>
<h3 id="continue-the-same-heuristic">Continue the same heuristic</h3>
<p>在在线斯坦纳树的算法分析中直接出现了哈密尔顿圈！</p>
<p>是否同样可以用欧拉回路来得到一个不错的 bound 呢？</p>
<p><em>MST Heuristic</em>: 注意到，对于 <span
class="math inline">\(G=\langle V, E\rangle\)</span> 的最小生成树 <span
class="math inline">\(T\)</span>，有</p>
<p><span class="math display">\[
cost(T)\le cost(H).
\]</span></p>
<p>其中 <span class="math inline">\(H\)</span> 为图 <span
class="math inline">\(T\)</span> 任意哈密尔顿圈。</p>
<h3 id="mst-heuristic">MST Heuristic</h3>
<p>算法流程：</p>
<ol type="1">
<li>求出 <span class="math inline">\(G\)</span> 的一棵最小生成树，可知
<span class="math inline">\(cost(T)\le cost(H)=OPT\)</span>，<span
class="math inline">\(OPT\)</span> 为问题最优解。</li>
<li>将 <span class="math inline">\(T\)</span>
中每条边复制一遍，得到全是偶点的图，可得经过所有点的欧拉回路 <span
class="math inline">\(C\)</span>，有 <span
class="math inline">\(cost(C)=2cost(T)\le 2OPT\)</span>。</li>
<li>裁剪 <span class="math inline">\(C\)</span> 得到哈密尔顿圈 <span
class="math inline">\(H&#39;\)</span>，有 <span
class="math inline">\(cost(H&#39;)\le cost(C)\le 2OPT\)</span>。</li>
</ol>
<p>显然得到了近似率</p>
<p><span class="math display">\[
\alpha=\frac{cost(C)}{OPT}\le 2
\]</span></p>
<p>的算法。容易在 <span class="math inline">\(O(n^2)\)</span>
内实现。</p>
<h3 id="christofidess-algorithm">Christofides's Algorithm</h3>
<p>在最小生成树 <span class="math inline">\(T\)</span>
的基础上，无需将其所有边都复制一遍来得到欧拉回路。Christofides
使用了更好的松弛：</p>
<p>算法流程：</p>
<ol type="1">
<li>仍求得一棵最小生成树 <span class="math inline">\(T\)</span>，<span
class="math inline">\(cost(T)\le OPT\)</span>。</li>
<li>子图 <span class="math inline">\(T\)</span> 中 <span
class="math inline">\(\deg_T(u)\)</span> 为奇数的点构成集合 <span
class="math inline">\(V_{odd}\)</span>，有 <span
class="math inline">\(|V_{odd}|\)</span> 为偶数。</li>
<li>因为 <span class="math inline">\(V_{odd}\)</span>
的导出子图为完全图，故其存在完美匹配，记其最小权的为 <span
class="math inline">\(M\)</span>。</li>
<li><span class="math inline">\(\langle V, E[T]\cup
E[M]\rangle\)</span>（允许重边）全为偶点，存在欧拉回路 <span
class="math inline">\(C\)</span>。</li>
<li>裁剪 <span class="math inline">\(C\)</span> 得到哈密尔顿圈 <span
class="math inline">\(H&#39;\)</span>。</li>
</ol>
<h3 id="christofidess-algorithm---analysis">Christofides's Algorithm -
Analysis</h3>
<p>对于图 <span class="math inline">\(\langle V, E[T]\cup
E[M]\rangle\)</span>，其 <span class="math inline">\(E[T]\)</span>
的部分显然有 <span class="math inline">\(cost(T)\le
OPT\)</span>。只需考虑 <span class="math inline">\(cost(M)\)</span> 和
<span class="math inline">\(OPT\)</span> 的大小关系。</p>
<p><em>Lemma</em>: 对于偶阶子图 <span
class="math inline">\(G&#39;\subseteq_{g} G\)</span>，其最小权完美匹配
<span class="math inline">\(M\)</span> 满足 <span
class="math inline">\(cost(M)\le OPT/2\)</span>。</p>
<p><em>Proof</em>:</p>
<ol type="1">
<li>可将 OPT 对应的哈密尔顿圈 <span class="math inline">\(H\)</span>
裁剪至 <span class="math inline">\(V[G&#39;]\)</span> 上得到 <span
class="math inline">\(H[G&#39;]\)</span>，由 metric 可知 <span
class="math inline">\(cost(H[G&#39;])\le OPT\)</span>。</li>
<li><span class="math inline">\(H[G‘]\)</span>
含有偶数条边，交替构成两个匹配 <span class="math inline">\(M_1,
M_2\)</span>，有 <span class="math inline">\(cost(M_1)+cost(M_2)\le
cost(H[H&#39;])\le OPT\)</span>。</li>
<li>不妨设较小的那个是 <span class="math inline">\(M_1\)</span>，有
<span class="math inline">\(M\le M_1\le OPT/2\)</span>。</li>
</ol>
<p>由 Lemma 可得，最后求得的 <span class="math inline">\(H&#39;\)</span>
满足</p>
<p><span class="math display">\[
cost(H&#39;)\le cost(C)=cost(T)+cost(M)\le OPT+OPT/2=3OPT/2
\]</span></p>
<p>故近似率 <span class="math inline">\(\alpha \le 3/2\)</span>。</p>
<p>算法瓶颈在于一般图最大权匹配，时间复杂度 <span
class="math inline">\(O(n^3)\)</span>。</p>
<h2 id="reference">Reference</h2>
<p>[1] CS 261: A Second Course in Algorithms, note: <a
href="https://timroughgarden.org/w16/w16.html"
class="uri">https://timroughgarden.org/w16/w16.html</a></p>
<p>[2] Christofides, N. (1976). Worst-case analysis of a new heuristic
for the travelling salesman problem.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>Install WeChat in Docker(DoChat) in Ubuntu</title>
    <url>/posts/524dba85/</url>
    <content><![CDATA[<p>WeChat is a useful software to communicate with others.
Unfortunately, <a href="https://weixin.qq.com/">WeChat Official</a> does
not provide Linux version. <a
href="https://github.com/huan/docker-wechat">DoChat</a> is a great
alternative.</p>
<span id="more"></span>
<h1 id="introduction">Introduction</h1>
<p>Some methods to use WeChat in Linux are here:</p>
<ul>
<li>Use windows virtual machine (See <a href="/posts/5113700a/" title="Install Windows 11 virtual machine on Ubuntu">Install Windows 11 virtual machine on Ubuntu</a>. This method is quite
heavy).</li>
<li>Use <a
href="https://www.ubuntukylin.com/applications/106-cn.html">WeChat for
Ubuntu Kylin</a>. (The UI is quite ugly and few functionalities are
supported)</li>
<li>Use docker + wine + wechat on windows.</li>
</ul>
<p>And the project <a
href="https://github.com/huan/docker-wechat">DoChat</a> provides the
third method with painless installation scripts.</p>
<h1 id="usage">Usage</h1>
<h2 id="install-docker">1. Install docker</h2>
<p>See <a href="https://www.runoob.com/docker/docker-tutorial.html">This
tutorial</a> to install docker engine. For my <strong>Ubuntu</strong>, I
can use</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line">$ <span class="built_in">sudo</span> sh test-docker.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: If you have installed docker desktop before, remember to
uninstall it. See <a
href="https://docs.docker.com/desktop/uninstall/">Docker offical doc</a>
to uninstall. Pay particular attention to the modification of
<code>$HOME/.docker/config.json</code>!</p>
</blockquote>
<h2 id="use-the-dochat">2. Use the DoChat</h2>
<p>Refer to <a href="https://github.com/huan/docker-wechat">DoChat git
repository</a>, use</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sL https://raw.githubusercontent.com/huan/docker-wechat/master/dochat.sh | bash</span><br></pre></td></tr></table></figure>
<p>to run the DoChat.</p>
<h2 id="some-improvement">3. Some improvement</h2>
<p>The output of the program is quite annoying. What I prefer is to
create a script for this, for example,
<code>~/Program/wechat</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">curl -sL https://raw.githubusercontent.com/huan/docker-wechat/master/dochat.sh | bash 2&gt;/dev/null &gt;/dev/null &amp;</span><br></pre></td></tr></table></figure>
<p>And after add <code>$HOME/Program</code> to <code>$PATH</code>,
simply using <code>wechat</code> command could open the wechat
clearly.</p>
<h2 id="transferring-files.">4. Transferring files.</h2>
<p>We can use <code>$HOME/DoChat/WeChat Files/</code> as a intermediary
of the host and the guest. Binding a soft link to
<code>$HOME/DoChat/WeChat Files/[WXID]/FileStorage/File/</code> is a
good idea.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker/Podman</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大权匹配（KM 算法） 学习笔记</title>
    <url>/posts/58a68c50/</url>
    <content><![CDATA[<p>移植自原博客 <a
href="https://blog.csdn.net/qq_41996523/article/details/113245137"
class="uri">https://blog.csdn.net/qq_41996523/article/details/113245137</a>。</p>
<span id="more"></span>
<h1 id="二分图最大权匹配km算法-学习笔记">二分图最大权匹配（KM算法）
学习笔记</h1>
<h2 id="学习资料">学习资料</h2>
<p><a
href="https://www.luogu.com.cn/blog/suxxsfe/xiong-ya-li-suan-fa">匈牙利与KM算法</a></p>
<p><a
href="https://oi-wiki.org/graph/graph-matching/bigraph-weight-match/">二分图最大权匹配——OI
Wiki</a></p>
<p><a
href="https://www.luogu.com.cn/blog/SingerCoder/solution-p6577">题解
P6577【模板】二分图最大权完美匹配</a></p>
<p><a href="https://www.cnblogs.com/zhltao/p/12549489.html"
class="uri">https://www.cnblogs.com/zhltao/p/12549489.html</a></p>
<h2 id="km-算法">KM 算法</h2>
<p><a href="https://www.luogu.com.cn/problem/P6577">P6577
【模板】二分图最大权完美匹配</a></p>
<p>KM算法用来求一类特殊二分图的最大权完美匹配。这个特殊指：</p>
<ol type="1">
<li><strong>每对</strong>左右部点间都有边。</li>
<li>左右部的节点数量相同。</li>
</ol>
<p>其实没有关系。我们只要这样做，就可以推至普适情况：</p>
<ol type="1">
<li>原来没有边的左右部点间连权值为 <span
class="math inline">\(0\)</span> / <span
class="math inline">\(-\infty\)</span>的边（通常直接用邻接矩阵实现。连
<span class="math inline">\(0\)</span> 还是连 <span
class="math inline">\(-\infty\)</span>
取决于是否要求一定要完美匹配）。</li>
<li>往少的那一部补一些点使之相等。</li>
</ol>
<p>所以我们说，KM算法适用于普遍的二分图的<strong>最大权匹配</strong>。</p>
<h2 id="定义">定义</h2>
<p><strong>顶标</strong></p>
<p>我们给每个节点设置一个 “顶标”。为了方便，左部节点的顶标叫做 <span
class="math inline">\(lx_i\)</span>，右部节点的顶标叫做 <span
class="math inline">\(ly_i\)</span>。</p>
<blockquote>
<p>顶标的性质：</p>
<p>任意时刻，对于图中任意一条边 <span
class="math inline">\((u,v,w)\)</span>，有 <span
class="math inline">\(lx_u+ly_v\ge w\)</span>。</p>
</blockquote>
<p><strong>相等子图</strong></p>
<p>相等子图
<strong>包括原二分图中的所有节点（即一个生成子图）</strong>，而边集却是原图中满足
<span class="math inline">\(lx_u+ly_v=w\)</span> 的边 <span
class="math inline">\((u,v,w)\)</span> 构成的。也就是把那些 <span
class="math inline">\(lx_u+ly_v=w\)</span>
的边搞出来的一个生成子图。</p>
<blockquote>
<p>相等子图的性质：</p>
<ol type="1">
<li>相等子图若存在完美匹配，则完美匹配的权和就是顶标和。</li>
<li>相等子图若存在完美匹配，则同时也是原图的最大权完美匹配。</li>
</ol>
</blockquote>
<p>于是我们只要增广一个相等子图，使之具有完美匹配即可。</p>
<h2 id="算法流程">算法流程</h2>
<ol type="1">
<li>赋予一个顶标初始值，比如 <span
class="math inline">\(lx_u=\max\{w|(u,v,w)\},ly_i=0\)</span>。</li>
<li>选一个未匹配点，从它那里开始在<strong>相等子图</strong>中增广。</li>
<li>调整顶标，给在交错树中的左部的节点减去一个值，给在交错树中的右部的节点加上一个值。这是为了让更多的节点加进相等子图。</li>
</ol>
<p>我们详细地说说“调整顶标”。</p>
<h3 id="调整顶标">调整顶标</h3>
<p>比如我们要进行调整的变化值为 <span
class="math inline">\(a\)</span>，即让所有在交错树中的点的 <span
class="math inline">\(lx_u\)</span> 减 <span
class="math inline">\(a\)</span>，<span
class="math inline">\(ly_v\)</span> 加 <span
class="math inline">\(a\)</span>。</p>
<p>于是：</p>
<p>若假设 <span class="math inline">\(u,v\)</span>
分别是交错树上任意的两个左、右部点，<span
class="math inline">\(u&#39;,v&#39;\)</span>
分别是交错树外任意的两个左、右节点。</p>
<ol type="1">
<li><span class="math inline">\((u, v)\)</span> 仍在交错树上。</li>
<li><span class="math inline">\((u&#39;,v&#39;)\)</span>
仍不在交错树上。</li>
<li><span class="math inline">\((u,v&#39;)\)</span>
由于顶标和减少，<strong>有可能</strong> 进入相等子图。</li>
<li><span class="math inline">\((u&#39;,v)\)</span>
顶标和增加，更不可能进入相等子图。</li>
</ol>
<p>所以我们要增广，关键看第3种情况。</p>
<p>为了维护顶标的性质，并且让第3种情况的边加入， <span
class="math inline">\(a\)</span> 值应选择为：</p>
<p><span
class="math inline">\(a=\min\{(lx_u+ly_{v&#39;}-w)|\forall(u,v&#39;,w)\}\)</span>。</p>
<p>于是，我们可以先写出个dfs版本的KM算法。可惜的是，它的时间复杂度可能卡到
<span class="math inline">\(O(n^4)\)</span>，无法通过模板题。</p>
<h2 id="代码dfs">代码(Dfs)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">char</span> In[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *ss = In, *tt = In;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar() (ss == tt &amp;&amp; (tt = (ss = In) + fread(In, 1, 1 &lt;&lt; 20, stdin), ss == tt) ? EOF : *ss++)</span></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + <span class="built_in">int</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, match[MAXN], vx[MAXN], vy[MAXN];</span><br><span class="line">ll e[MAXN][MAXN], slack[MAXN], lx[MAXN], ly[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	vx[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) <span class="keyword">if</span>(!vy[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(lx[u] + ly[v] == e[u][v]) &#123;</span><br><span class="line">			vy[v] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!match[v] || <span class="built_in">dfs</span>(match[v])) &#123;</span><br><span class="line">				match[v] = u;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> slack[v] = <span class="built_in">min</span>(slack[v], lx[u] + ly[v] - e[u][v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) lx[i] = -INF, ly[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) lx[i] = <span class="built_in">max</span>(lx[i], e[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) vx[j] = vy[j] = <span class="number">0</span>, slack[j] = INF;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) <span class="keyword">break</span>;</span><br><span class="line">			ll d = INF;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span>(!vy[j]) d = <span class="built_in">min</span>(d, slack[j]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vx[j]) lx[j] -= d;</span><br><span class="line">				<span class="keyword">if</span>(vy[j]) ly[j] += d;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) e[i][j] = -INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(); ll w = <span class="built_in">read</span>();</span><br><span class="line">		e[u][v] = <span class="built_in">max</span>(e[u][v], w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">KM</span>();</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += lx[i] + ly[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, match[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么怎么办呢？只要换用bfs写法就好啦。这样就不会每次从头增广。</p>
<p>时间复杂度 <span class="math inline">\(O(n^3)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">char</span> In[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *ss = In, *tt = In;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar() (ss == tt &amp;&amp; (tt = (ss = In) + fread(In, 1, 1 &lt;&lt; 20, stdin), ss == tt) ? EOF : *ss++)</span></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + <span class="built_in">int</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3fll</span>;</span><br><span class="line"><span class="type">int</span> n, m, vx[MAXN], vy[MAXN], px[MAXN], py[MAXN], pre[MAXN];</span><br><span class="line">ll e[MAXN][MAXN], lx[MAXN], ly[MAXN], slack[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aug</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(v) &#123;</span><br><span class="line">		<span class="type">int</span> t = px[pre[v]];</span><br><span class="line">		px[pre[v]] = v;</span><br><span class="line">		py[v] = pre[v];</span><br><span class="line">		v = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vx[i] = vy[i] = <span class="number">0</span>, slack[i] = INF;</span><br><span class="line">	que = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">	que.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">			vx[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) <span class="keyword">if</span>(!vy[v]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(lx[u] + ly[v] - e[u][v] &lt; slack[v]) &#123;</span><br><span class="line">					slack[v] = lx[u] + ly[v] - e[u][v];</span><br><span class="line">					pre[v] = u;</span><br><span class="line">					<span class="keyword">if</span>(slack[v] == <span class="number">0</span>) &#123;</span><br><span class="line">						vy[v] = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">if</span>(!py[v]) &#123;<span class="built_in">aug</span>(v); <span class="keyword">return</span> ;&#125;</span><br><span class="line">						<span class="keyword">else</span> que.<span class="built_in">push</span>(py[v]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll d = INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vy[i]) d = <span class="built_in">min</span>(d, slack[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vx[i]) lx[i] -= d;</span><br><span class="line">			<span class="keyword">if</span>(vy[i]) ly[i] += d;</span><br><span class="line">			<span class="keyword">else</span> slack[i] -= d;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!vy[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(slack[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				vy[i] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(!py[i]) &#123;<span class="built_in">aug</span>(i); <span class="keyword">return</span> ;&#125;</span><br><span class="line">				<span class="keyword">else</span> que.<span class="built_in">push</span>(py[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) lx[i] = -INF, ly[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) lx[i] = <span class="built_in">max</span>(lx[i], e[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">bfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) e[i][j] = -INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(); ll w = <span class="built_in">read</span>();</span><br><span class="line">		e[u][v] = <span class="built_in">max</span>(e[u][v], w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">KM</span>();</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += lx[i] + ly[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, py[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>XCPC</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 14 笔记</title>
    <url>/posts/a62e9f02/</url>
    <content><![CDATA[<p>OT：除MS和MAX-CUT外，近似算法还可用于解决其它问题，例如SCP（JH算法4.3.2.11）、SKP（JH算法4.3.4.1和4.3.4.2）等，请调研至少2种近似算法（其中至多1种来自上述例子，图上的优化问题不在调研范围内），结合例子介绍算法的设计与分析，重点阐述近似比的证明过程。</p>
<span id="more"></span>
<p><a href="slide/slide.html">slide</a></p>
<h1 id="近似算法的设计">近似算法的设计</h1>
<h2 id="看灯问题1">“看灯”问题[1]</h2>
<h3 id="简介">简介</h3>
<ul>
<li>给定 <span class="math inline">\(N\)</span> 盏灯，位置分别为 <span
class="math inline">\(x_1, x_2, \cdots, x_N\)</span>，满足 <span
class="math inline">\(1\le x_i\le V\)</span>。</li>
<li>再给定 <span class="math inline">\(Q\)</span> 个询问 <span
class="math inline">\(d_i, (1\le d_i\le
V)\)</span>，对每个询问求出最小的 <span
class="math inline">\(v\in\lbrace 1, 2, \cdots, n\rbrace\)</span> 使得在
<span class="math inline">\(x_v+d_i\)</span> 处存在另一盏灯。</li>
<li>设 <span class="math inline">\(N\)</span>，<span
class="math inline">\(Q\)</span>，<span class="math inline">\(V\)</span>
为同一量级。</li>
</ul>
<h3 id="分析">分析</h3>
<p>该问题并非是难问题，存在朴素的 <span
class="math inline">\(O(QN)\)</span>
的实现。但若对于编号的“最小”可以进行一定的宽松，可以获得复杂度更低的算法。</p>
<p>考虑近似率为 <span class="math inline">\(\alpha\)</span>
的算法，即允许输出的答案 <span class="math inline">\(v&#39;\)</span>
满足 <span class="math inline">\(v\le v&#39;\le \alpha
v\)</span>，此时可以使用“区间划分”的思想对问题进行简化。</p>
<h3 id="下界的确定">下界的确定</h3>
<ul>
<li>假若我们已确保对询问 <span
class="math inline">\(d_i\)</span>，对任意 <span
class="math inline">\(v&#39;&lt; k\)</span>，<span
class="math inline">\(v&#39;\)</span> 均不满足 <span
class="math inline">\(x_{v&#39;}+d_i\)</span> 处有灯，则最优解有下界
<span class="math inline">\(k\)</span>。</li>
<li>此时，若编号在 <span class="math inline">\(v\in [k,\lfloor \alpha
k\rfloor]\cap \mathbb Z\)</span> 区间内的点有满足条件的，则最优解满足
<span class="math inline">\(v\in [k, \lfloor \alpha
k\rfloor]\)</span>，从而 <span class="math inline">\(v&#39;=\lfloor
\alpha k\rfloor\)</span> 是原问题的一个满足近似率为 <span
class="math inline">\(\alpha\)</span> 的解。</li>
<li>否则，则证明了所有编号在 <span class="math inline">\([1,\lfloor
\alpha k\rfloor]\)</span>
中的点都不满足条件，最优解有<strong>新的下界</strong> <span
class="math inline">\(\lfloor \alpha k\rfloor+1\)</span>.</li>
</ul>
<p>若不考虑下取整，重复 <span class="math inline">\(t\)</span>
次上述步骤，下界序列为：</p>
<ul>
<li><span class="math inline">\(low_1=1\)</span>;</li>
<li><span class="math inline">\(low_2=\alpha + 1\)</span>;</li>
<li><span class="math inline">\(low_3=\alpha(\alpha + 1) +
1\)</span>;</li>
<li><span class="math inline">\(\cdots\)</span>;</li>
<li><span
class="math inline">\(low_t=\sum_{i=0}^{t-1}\alpha^i=\frac{\alpha^t-1}{\alpha-1}\)</span>.</li>
</ul>
<p>令 <span class="math inline">\(low_t\le n\)</span>，有 <span
class="math inline">\(t\le\log_\alpha(\alpha(n-1)+1)\)</span>，故 <span
class="math inline">\(t=\Theta(\log_\alpha n)\)</span>. 于是至多进行
<span class="math inline">\(\Theta(\log_\alpha n)\)</span>
次该操作。</p>
<h3 id="询问的整体处理">询问的整体处理</h3>
<p>于是，问题转化为了，对至多 <span
class="math inline">\(\Theta(\log_\alpha n)\)</span> 段形如 <span
class="math inline">\([L, R]\)</span> 的编号区间，对每个询问 <span
class="math inline">\(d_i(1\le i\le Q)\)</span>，判断是否存在 <span
class="math inline">\(v\in [L, R]\)</span> 使得 <span
class="math inline">\(x_v+d_i\)</span> 存在另一盏灯。</p>
<p>事实上，可以对所有 <span class="math inline">\(d_i\)</span>
一起处理：构造两个序列 <span class="math inline">\(X_i\)</span> 和 <span
class="math inline">\(Y_i\)</span>：</p>
<ul>
<li><span class="math inline">\(X_i=1\)</span> 当且仅当存在 <span
class="math inline">\(v\in [L, R]\)</span>, <span
class="math inline">\(x_v=i\)</span>；否则为 <span
class="math inline">\(0\)</span>。</li>
<li><span class="math inline">\(Y_i=1\)</span> 当且仅当存在 <span
class="math inline">\(v\in [1, N]\)</span>，<span
class="math inline">\(x_v=i\)</span>；否则为 <span
class="math inline">\(0\)</span>。</li>
<li>"存在多少对 <span class="math inline">\((x, y)\)</span> 满足 <span
class="math inline">\(x\in [L, R], y\in [1, n], s.t. x+d=y\)</span>"
也可以形成一个序列 <span
class="math inline">\(Z_d\)</span>，计算方法为</li>
</ul>
<p><span class="math display">\[
Z_d=\sum_{1\le i, j\le V, j-i=d}X_iY_j.
\]</span></p>
<h3 id="z_d-的快速计算"><span class="math inline">\(Z_d\)</span>
的快速计算</h3>
<p>可以将 <span class="math inline">\(X\)</span>
序列翻转，变成加法卷积：</p>
<p><span class="math display">\[
\begin{align*}
Z_d &amp;=\sum_{1\le i, j\le V, j-i=d}X_iY_j\\
    &amp;=\sum_{1\le i, j\le V, j+(V-i+1)=d+V+1}X_{V+1-(V-i+1)}Y_j\\
    &amp;=\sum_{1\le i, j\le V, j+i&#39;=d+V+1}X&#39;_{i&#39;}Y_j\\
    &amp;=(X&#39;*Y)_{d+V+1}
\end{align*}
\]</span></p>
<p>其中，<span class="math inline">\(i&#39;=V-i+1, X&#39;_k =
X_{V+1-k}\)</span>。</p>
<p>而加法卷积可以使用快速傅里叶算法在 <span
class="math inline">\(\Theta(V\log V)\)</span>
时间内计算。之后对每个询问 <span
class="math inline">\(d_i\)</span>，只需判断 <span
class="math inline">\(Z_{d_i}\)</span> 是否为 <span
class="math inline">\(0\)</span> 即可。</p>
<h3 id="算法分析">算法分析</h3>
<p>最朴素的算法为 <span class="math inline">\(O(QN)\)</span>；</p>
<p>该算法在近似率为 <span class="math inline">\(\alpha\)</span>
的情况下，共至多运行 <span class="math inline">\(O(\log_\alpha
N)\)</span> 轮区间 <span class="math inline">\([L, R]\)</span>
的查询，单次复杂度为 <span class="math inline">\(O(V\log
V+Q)\)</span>，故总复杂度为 <span class="math inline">\(O((V\log
V+Q)\log_\alpha N)\)</span>。</p>
<h1 id="集合覆盖问题">集合覆盖问题</h1>
<h2 id="问题描述">问题描述</h2>
<ul>
<li>给定 <span class="math inline">\(m\)</span> 个集合 <span
class="math inline">\(S_1, S_2, \cdots, S_m\)</span> 和 <span
class="math inline">\(k\)</span>，要求选定其中 <span
class="math inline">\(k\)</span> 个 <span class="math inline">\(S_{p_1},
S_{p_2}, \cdots, S_{p_k}\)</span>，最大化 <span
class="math inline">\(S_{p_1}\cup S_{p_2}\cup\cdots,
S_{p_k}\)</span>。</li>
<li>该问题为 NPC。</li>
</ul>
<h2 id="贪心算法">贪心算法</h2>
<p>对以下步骤进行 <span class="math inline">\(k\)</span> 轮：</p>
<ul>
<li>第 <span class="math inline">\(i\)</span> 轮，每次选择集合 <span
class="math inline">\(S_{p_i}\)</span> 最大化新增的并集大小。</li>
</ul>
<p><img src="1.png" witdh="80%"/></p>
<p>如上图，可构造出近似率不高于 <span
class="math inline">\(\displaystyle 1-(1-\frac{1}{k})^k\)</span>
的样例。</p>
<ul>
<li>(方便起见，此处近似率未取倒数，定义为 <span
class="math inline">\(\alpha=\text{Now-Sol}/OPT\)</span>)</li>
</ul>
<h2 id="近似率证明">近似率证明</h2>
<p><em>Theorem 1</em>: 该贪心算法的近似率恰为 <span
class="math inline">\(\displaystyle(1-(1-\frac{1}{k})^k)\)</span>，故该近似率估计是紧的。</p>
<p><em>Theorem 2</em>:
在某些复杂度假设下，不存在有更优近似率的多项式复杂度算法。</p>
<p>要证明 <em>Theorem 1</em>，先证明引理</p>
<p><em>Lemma</em>: 设贪心算法选择出前 <span
class="math inline">\(i-1\)</span> 个集合为 <span
class="math inline">\(S_{p_1}, S_{p_2}, \cdots,
S_{p_{i-1}}\)</span>，它们覆盖了 <span class="math inline">\(l\)</span>
个元素，则第 <span class="math inline">\(i\)</span> 轮选择的 <span
class="math inline">\(A_i\)</span> 会覆盖至少</p>
<p><span class="math display">\[
    \frac{1}{k}(OPT-l)
\]</span> 个新元素，<span class="math inline">\(OPT\)</span>
为最优解。</p>
<p><em>Proof</em>: 假设该轮贪心算法可以直接取走 <span
class="math inline">\(k\)</span> 个集合，则可以立即取到 <span
class="math inline">\(OPT\)</span> 个元素，获得至少 <span
class="math inline">\(OPT-l\)</span> 个新元素。故这 <span
class="math inline">\(k\)</span> 个中至少有一个集合有至少 <span
class="math inline">\(\frac{1}{k}(OPT-l)\)</span> 个新元素。</p>
<h3 id="近似率证明-1">近似率证明</h3>
<p><em>Theorem 1</em>: 该贪心算法的近似率恰为 <span
class="math inline">\(\displaystyle(1-(1-\frac{1}{k})^k)\)</span>，故该近似率估计是紧的。</p>
<p><em>Proof</em>:</p>
<p>设第 <span class="math inline">\(i\)</span> 轮共取了 <span
class="math inline">\(f_i\)</span> 个元素，则有 <span
class="math inline">\(f_0=0\)</span>，且</p>
<p><span class="math display">\[
f_i\ge
f_{i-1}+\frac{1}{k}(OPT-f_{i-1})=\frac{1}{k}OPT+(1-\frac{1}{k})f_{i-1}.
\]</span></p>
<p>解递推式有</p>
<p><span class="math display">\[
f_{i}\ge OPT+(1-\frac{1}{k})^k(f_0-OPT)=OPT\cdot (1-(1-\frac{1}{k})^k).
\]</span></p>
<p>故</p>
<p><span class="math display">\[
\frac{f_i}{OPT}\ge 1-(1-\frac{1}{k})^k
\]</span> 近似率为 <span class="math inline">\(\displaystyle
\alpha=1-(1-\frac{1}{k})^k\)</span>.</p>
<h1 id="参考资料">参考资料</h1>
<p>[1] 2023 ICPC Hangzhou Regional Contest.</p>
<p>[2] CS 261: A Second Course in Algorithms, note: <a
href="https://timroughgarden.org/w16/w16.html"
class="uri">https://timroughgarden.org/w16/w16.html</a></p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 15 笔记</title>
    <url>/posts/6a849f9c/</url>
    <content><![CDATA[<p>OT：在独立、覆盖和支配的基础上，形成了很多扩展的优化问题，例如最小权完美匹配问题（Minimum-Weight
Perfect Matching）、<a
href="https://en.wikipedia.org/wiki/Connected_dominating_set">最小连通支配集问题</a>等，请调研至少2种问题（其中至多1种来自上述例子，二分图最大匹配问题等仅限制原始问题输入的问题不在调研范围内），讨论适用场景，形式化描述问题，为每种问题结合例子介绍至少1种算法的设计与分析。</p>
<span id="more"></span>
<p><a href="slide/slide.html">slide</a></p>
<p>主要内容：</p>
<ol type="1">
<li>二分图最大权匹配；</li>
<li>最小 <span class="math inline">\(k\)</span>-支配集。</li>
</ol>
<h1 id="二分图最大权匹配">二分图最大权匹配</h1>
<h2 id="问题描述">问题描述</h2>
<p>给定二分图 <span class="math inline">\(G=\langle X\cup Y,
E\rangle\)</span> 和权值函数 <span class="math inline">\(w: E\to \mathbb
R\)</span>（<strong>允许负权</strong>）。求匹配 <span
class="math inline">\(I\subseteq E\)</span> 最大化</p>
<p><span class="math display">\[
cost(I)=\sum_{e\in I}w(e).
\]</span></p>
<h2 id="方法-1-最大费用最大流">方法 1: 最大费用最大流</h2>
<p>在二分图的网络流建模上，为边 <span class="math inline">\(\langle u,
v\rangle, u\in X, v\in Y\)</span> 添加代价 <span
class="math inline">\(w(( u, v))\)</span>，为 <span
class="math inline">\(\langle s, u\rangle, u\in X\)</span> 和 <span
class="math inline">\(\langle v, t\rangle, v\in Y\)</span> 添加代价
<span class="math inline">\(0\)</span>。</p>
<p>使用 SSP 求解最大费用的最大流，时间复杂度 <span
class="math inline">\(O(nmf)\)</span>，其中 <span
class="math inline">\(f=O(n)\)</span> 且 <span
class="math inline">\(m=O(n^2)\)</span>，在稠密的二分图上，最坏是 <span
class="math inline">\(O(n^4)\)</span> 的。</p>
<h2 id="方法-2-km-算法">方法 2: KM 算法</h2>
<p>KM 算法(Kuhn–Munkres Algorithm)可在 <span
class="math inline">\(O(n^3)\)</span>
时间内解决二分图最大权匹配问题。</p>
<h2 id="一类特殊二分图">一类特殊二分图</h2>
<p>在运行 KM 算法之前，假设图 <span class="math inline">\(G\)</span>
满足以下性质：</p>
<ol type="1">
<li><span class="math inline">\(G\)</span> 是完全二分图。</li>
<li><span class="math inline">\(G\)</span> 是平衡二分图。</li>
</ol>
<p>对<strong>任意二分图</strong>，可以在左部或右部补充顶点满足条件
<strong>2.</strong>；可以加入 <span class="math inline">\(0\)</span> 或
<span class="math inline">\(-\infty\)</span> 的边满足条件
<strong>1.</strong>。所以该假设是不影响一般性的。</p>
<h2 id="顶标">顶标</h2>
<ul>
<li>对于左部任意一点 <span class="math inline">\(u\in
X\)</span>，设置顶标 <span class="math inline">\(lx_u\)</span>；</li>
<li>对于右部任意一点 <span class="math inline">\(v\in
Y\)</span>，设置顶标 <span class="math inline">\(ly_v\)</span>。</li>
</ul>
<p><strong>要求</strong>：在算法运行的任意时刻，对任意边 <span
class="math inline">\((u, v)\in E, u\in X, v\in Y\)</span> 有</p>
<p><span class="math display">\[
    lx_u+ly_v\ge w((u, v)).
\]</span></p>
<h2 id="相等子图">相等子图</h2>
<p><strong>相等子图</strong> <span class="math inline">\(G&#39;=\langle
V, E&#39;\rangle\)</span> 包含原图中的所有顶点，但仅包含原图中满足</p>
<p><span class="math display">\[
lx_u+ly_v=w((u, v))
\]</span></p>
<p>的边 <span class="math inline">\((u,
v)\)</span>。可知相等子图由顶标序列决定。</p>
<p><em>Property 1</em>:
若相等子图存在完美匹配，则该完美匹配的权就是顶标和 <span
class="math inline">\(\sum_{u\in X}lx_u+\sum_{v\in Y}ly_v\)</span>.</p>
<p><em>Property 2</em>:
若相等子图存在完美匹配，则该完美匹配就是原图的<strong>最大权</strong>完美匹配。</p>
<p><em>Proof of Property 1</em>:</p>
<p>设完美匹配 <span class="math inline">\(I\)</span>（恰有 <span
class="math inline">\(|X|=|Y|=n\)</span> 条边）为 <span
class="math inline">\(\lbrace (u_i, v_i): 1\le i\le
n\rbrace\)</span>，其中 <span class="math inline">\(\lbrace u_i: 1\le
i\le n\rbrace = X\)</span>，<span class="math inline">\(\lbrace v_i:
1\le i\le n\rbrace=Y\)</span> 且互不相同。由相等子图的性质知</p>
<p><span class="math display">\[
cost(I)=\sum_{i=1}^nw((u_i,
v_i))=\sum_{i=1}^nlx_{u_i}+ly_{v_i}=\sum_{u\in X}lx_u+\sum_{v\in Y}ly_v.
\]</span></p>
<p><em>Proof of Property 2</em>:</p>
<p>显然相等子图 <span class="math inline">\(G&#39;\)</span> 的完美匹配
<span class="math inline">\(I\)</span> 是原图的完美匹配。对任意原图
<span class="math inline">\(G\)</span> 的完美匹配 <span
class="math inline">\(I&#39;=\lbrace (u_i&#39;, v_i&#39;): 1\le i\le
n\rbrace\)</span>，有</p>
<p><span class="math display">\[
cost(I&#39;)=\sum_{i=1}^nw((u&#39;_i, v&#39;_i))\le
\sum_{i=1}^nlx_{u_i}+ly_{v_i}=cost(I).
\]</span></p>
<p>故 <span class="math inline">\(I\)</span> 是 <span
class="math inline">\(G\)</span> 的最大权匹配。</p>
<h2 id="算法流程">算法流程</h2>
<p>只需求得具有完美匹配的相等子图即可。</p>
<p><em>Step 1</em>: 赋予符合条件的初始顶标 <span
class="math inline">\(lx_u\gets\max_{v\in Y}\lbrace w((u,
v))\rbrace\)</span>，<span
class="math inline">\(ly_v\gets0\)</span>。</p>
<p><em>Step 2</em>: 从一个未匹配点开始在<strong>相等子图</strong> <span
class="math inline">\(G&#39;\)</span> 中增广，即只经过 <span
class="math inline">\(lx_u+ly_v=w((u, v))\)</span> 的边 <span
class="math inline">\((u, v)\)</span>。</p>
<p><em>Step 3</em>: <strong>调整顶标</strong>，扩大相等子图 <span
class="math inline">\(G&#39;\)</span>。重复 <em>Step 2</em> 和 <em>Step
3</em> 直至 <span class="math inline">\(G&#39;\)</span> 包含恰 <span
class="math inline">\(n\)</span> 条边。</p>
<h2 id="调整顶标">调整顶标</h2>
<p>为了扩大相等子图 <span class="math inline">\(G&#39;\)</span>，在
<em>Step 2</em> 经过的交错树中，让左部点顶标全部减少 <span
class="math inline">\(s\)</span>，让右部点顶标全部增加 <span
class="math inline">\(s(s&gt; 0)\)</span>。</p>
<p>调整后，对于原图中的所有边，观察它的约束：（记 <span
class="math inline">\(u\)</span> 和 <span class="math inline">\(\hat
u\)</span> 分别为 <span class="math inline">\(X\)</span>
中在交错树和不在交错树的任意顶点，<span class="math inline">\(v\)</span>
和 <span class="math inline">\(\hat v\)</span> 同理）</p>
<ul>
<li>边 <span class="math inline">\((u, v)\)</span> 有 <span
class="math inline">\(lx&#39;_u+ly&#39;_v=lx_u-s+ly_v+s=lx_u+ly_v\)</span>，约束不变。</li>
<li>边 <span class="math inline">\((\hat u, \hat v)\)</span> 有 <span
class="math inline">\(lx&#39;_{\hat u}+ly&#39;_{\hat v}=lx_{\hat
u}+ly_{\hat v}\)</span>，约束不变。</li>
<li>边 <span class="math inline">\((u, \hat v)\)</span> 要求有 <span
class="math inline">\(lx&#39;_u+ly&#39;_{\hat v}=lx_u-s+ly_{\hat v}\ge
w((u, \hat v))\)</span>，有 <span class="math inline">\(s\le
lx_u+ly_{\hat v}-w((u, \hat v))\)</span>。</li>
<li>边 <span class="math inline">\((\hat u, v)\)</span> 有 <span
class="math inline">\(lx&#39;_{\hat u}+ly&#39;_v=lx_{\hat
u}+ly_v+s\)</span>，约束放松。</li>
</ul>
<p>综上，选择 <span class="math display">\[
s=\min_{u\in X, \hat v\in Y}\lbrace lx_u+ly_{\hat v}-w((u, \hat
v))\rbrace
\]</span></p>
<p>既可以满足约束，又可以使相应的 <span class="math inline">\(\hat
v\)</span> 加入相等子图。</p>
<h2 id="算法复杂性分析">算法复杂性分析</h2>
<p>至多扩增 <span class="math inline">\(O(n)\)</span>
次相等子图，每次进行增广(BFS)并维护顶标时间为 <span
class="math inline">\(O(n^2)\)</span>，总时间复杂度为 <span
class="math inline">\(O(n^3)\)</span>。</p>
<h1 id="最小-k-支配集">最小 <span
class="math inline">\(k\)</span>-支配集</h1>
<h2 id="问题描述-1">问题描述</h2>
<p>图 <span class="math inline">\(G=\langle V, E\rangle\)</span> 的
<span class="math inline">\(k\)</span>-支配集是点集的子集 <span
class="math inline">\(D_k\subseteq V\)</span>，使得去除 <span
class="math inline">\(V\)</span> 中任意 <span
class="math inline">\(k-1\)</span> 个顶点，剩余顶点或者在 <span
class="math inline">\(D_k\)</span> 中，或者存在邻点在 <span
class="math inline">\(D_k\)</span> 中。</p>
<p>最小支配集是 <span class="math inline">\(k=1\)</span>
时的该问题的特例。该问题是 NPH 的。</p>
<p>[2] (Foerster, 2013) 中给出了一种近似率为 <span
class="math inline">\(\ln(\Delta+k)+1&lt;\ln(\Delta)+1.7&lt;\ln
(n)+1.7\)</span> 的贪心算法。</p>
<h2 id="算法介绍">算法介绍</h2>
<p>对于某个 <span class="math inline">\(D\subseteq
V\)</span>，定义某个顶点 <span class="math inline">\(v\in V\)</span> 在
<span class="math inline">\(k\)</span>-支配集中的<strong>度</strong>
<span class="math inline">\(d_k(v, D)\)</span> 为</p>
<p><span class="math display">\[
d_k(v, D)=\begin{cases}
\min(k, |N(v)\cap D|), &amp; \text{if } v\notin D;\\
k, &amp; \text{if } v\in D.
\end{cases}
\]</span></p>
<p>即表示 “还需在 <span class="math inline">\(D\)</span> 中补充 <span
class="math inline">\(k- d_k(v, D)\)</span> 个 <span
class="math inline">\(v\)</span> 的邻点才能使得 <span
class="math inline">\(D\)</span> 在 <span
class="math inline">\(v\)</span> 处成为 <span
class="math inline">\(k\)</span>-支配集合法”。</p>
<p>定义<strong>剩余代价</strong> <span class="math inline">\(a(G,
D)\)</span> 为</p>
<p><span class="math display">\[
a(G, D)=\sum_{v\in V}[k-d_k(v, D)]=nk-\sum_{v\in V}d_k(v, D).
\]</span></p>
<p>则贪心算法则是依次迭代一系列 <span class="math inline">\(D^{(0)},
D^{(1)}, \cdots, D^{(i)}\)</span>，每次加入一个顶点，使得 <span
class="math inline">\(a(G, D)\)</span> 下降最快。</p>
<p><em>Step 1</em>: 令 <span
class="math inline">\(D^{(0)}\gets\varnothing\)</span>，<span
class="math inline">\(i\gets 0\)</span>。</p>
<p><em>Step 2</em>:</p>
<ul>
<li>选择点 <span class="math inline">\(v\in V\setminus D^{(i)}\)</span>
使得 <span class="math inline">\(a(G, D^{(i)})-a(G, D^{(i)}\cup \lbrace
v\rbrace)\)</span> 最大。</li>
<li>令 <span class="math inline">\(D^{(i+1)}\gets D^{(i)}\cup \lbrace
v\rbrace\)</span>，<span class="math inline">\(i\gets
i+1\)</span>。</li>
</ul>
<p><em>Step 3</em>: 重复 <em>Step 2</em> 直至 <span
class="math inline">\(a(G, D^{(i)})=0\)</span>，则此时 <span
class="math inline">\(D_k=D^{(i)}\)</span> 是 <span
class="math inline">\(k\)</span>-支配集。</p>
<h2 id="算法分析">算法分析</h2>
<p>该算法容易以 <span class="math inline">\(O(n(n+m))\)</span>
时间实现。为了分析近似率，我们使用以下数学结论：</p>
<p><em>Lemma</em>: 若 <span class="math inline">\(r\in \mathbb N,
r&gt;1\)</span>，且 <span class="math inline">\(b_1, b_2, \cdots, b_s\in
\mathbb N\)</span> 满足</p>
<p><span class="math display">\[
    b_v\ge \frac{1}{r}(B_s-B_{v-1}), \forall v\in\lbrace 1, 2, \cdots,
s\rbrace
\]</span></p>
<p>其中 <span class="math inline">\(B_k=\sum_{i=1}^kb_i\)</span>
为前缀和。</p>
<p>则有结论 <span
class="math inline">\(B_{\lambda}&gt;B_s-r\)</span>，对于</p>
<p><span class="math display">\[
\lambda &gt; \frac{\ln(\frac{B_s}{r})}{\ln(\frac{r}{r-1})}.
\]</span></p>
<h2 id="算法近似率">算法近似率</h2>
<p><em>Theorem</em>: 设 <span class="math inline">\(r\)</span> 是最小
<span class="math inline">\(k\)</span>-支配集的代价（即 <span
class="math inline">\(OPT\)</span>），则该贪心算法近似率为</p>
<p><span class="math display">\[
\frac{\ln(\frac{nk}{r})}{r\ln(\frac{r}{r-1})}+1.
\]</span></p>
<p><em>Corollary 1</em>: 该算法近似率为 <span class="math inline">\(\ln
(\Delta + k)+1\)</span>。</p>
<p><em>Corollary 2</em>: 该算法近似率为 <span
class="math inline">\(\ln(\Delta)+1.7&lt;\ln(n)+1.7\)</span>。</p>
<p><em>Proof for corollary</em>: 用导数易证恒等式</p>
<p><span class="math display">\[
\frac{1}{\ln(\frac{r}{r-1})}\le r(1-\frac{1}{2r}), r\ge 0.
\]</span></p>
<p>故</p>
<p><span class="math display">\[
\frac{\ln(\frac{nk}{r})}{r\ln(\frac{r}{r-1})}+1\le(1-\frac{1}{2r})\ln(\frac{nk}{r})+1&lt;\ln(\frac{nk}{r})+1
\]</span></p>
<p>因为 <span class="math inline">\(D_k\)</span> 中的每个点为 <span
class="math inline">\(a(G, D_k)\)</span> 从 <span
class="math inline">\(nk\)</span> 变化到 <span
class="math inline">\(0\)</span> 至多有 <span
class="math inline">\(\Delta+k\)</span> 的贡献（<span
class="math inline">\(k\)</span> 为自己，<span
class="math inline">\(1\)</span> 为每个邻点），故有</p>
<p><span class="math display">\[
    nk\le r(\Delta+k) \Leftrightarrow \frac{nk}{r}\le \Delta+k
\]</span></p>
<p>于是 <span class="math inline">\(\ln(\frac{nk}{r})+1\le
\ln(\Delta+k)+1\)</span> 也为该算法近似率。</p>
<p>当 <span class="math inline">\(k&gt;\Delta\)</span>，则唯一的 <span
class="math inline">\(k\)</span>-支配集是 <span
class="math inline">\(V\)</span>，贪心算法可得到最优解 <span
class="math inline">\(r=|V|\)</span>；若考虑 <span
class="math inline">\(k\le \Delta\)</span>，有</p>
<p><span class="math display">\[
\ln(\Delta+k)+1\le \ln(2\Delta)+1\le \ln(\Delta)+\ln 2 + 1 &lt;
\ln(\Delta)+1.7
\]</span></p>
<p>也为该算法近似率。</p>
<h2 id="定理的证明">定理的证明</h2>
<p><em>Theorem</em>: 设 <span class="math inline">\(r\)</span> 是最小
<span class="math inline">\(k\)</span>-支配集的代价（即 <span
class="math inline">\(OPT\)</span>），则该贪心算法近似率为</p>
<p><span class="math display">\[
\frac{\ln(\frac{nk}{r})}{r\ln(\frac{r}{r-1})}+1.
\]</span></p>
<p><em>Proof</em>: 设某个最小 <span
class="math inline">\(k\)</span>-支配集为 <span
class="math inline">\(D^*_k\)</span>。在从 <span
class="math inline">\(D^{(i-1)}\)</span> 构造 <span
class="math inline">\(D^{(i)}\)</span> 的过程中，若取 <span
class="math inline">\(D^{(i)}=D^{(i-1)}\cup D^*_k\)</span>，则 <span
class="math inline">\(a(G, D^{(i)})=0\)</span>。故在 <span
class="math inline">\(D^*_k\setminus D^{(i-1)}\)</span>
中至少存在一个顶点 <span class="math inline">\(u^{(i)}\)</span> 使得
<span class="math inline">\(a\)</span> 下降 <span
class="math inline">\(a(G, D^{(i)})/|D^*_k|=a(G,
D^{(i)})/r\)</span>。于是有</p>
<p><span class="math display">\[
a(G, D^{(i)})\le a(G, D^{(i-1)}\cup \lbrace u^{(i)}\rbrace)\le a(G,
D^{(i-1)})\left(1-\frac{1}{r}\right)
\]</span></p>
<p>取 <span class="math inline">\(B_i=nk-a(G,
D^{(i)})\)</span>，变形上式有</p>
<p><span class="math display">\[
B_i-B_{i-1}=\frac{1}{r}(nk-B_{i-1}).
\]</span></p>
<p>令 <span class="math inline">\(B_s=nk\)</span>，则由定理，在</p>
<p><span class="math display">\[
\lambda &gt;
\frac{\ln(\frac{B_s}{r})}{\ln(\frac{r}{r-1})}=\frac{\ln(\frac{nk}{r})}{\ln(\frac{r}{r-1})}
\]</span> 时有 <span
class="math inline">\(B_{\lambda}&gt;B_s-r\)</span>，即 <span
class="math inline">\(a(G, D^{(\lambda)})&lt;r\)</span>。再选至多 <span
class="math inline">\(r-1\)</span> 个点即可使得 <span
class="math inline">\(a(G, D^{(\lambda+r-1)})=0\)</span>。</p>
<p>故最终答案可取</p>
<p><span class="math display">\[
|D_k|=\left\lfloor
\frac{\ln(\frac{nk}{r})}{\ln(\frac{r}{r-1})}+1\right\rfloor+r-1=\left\lfloor
\frac{\ln(\frac{nk}{r})}{\ln(\frac{r}{r-1})}\right\rfloor+r.
\]</span></p>
<p>故近似率</p>
<p><span class="math display">\[
\alpha=\frac{|D_k|}{r}\le
\frac{\ln(\frac{nk}{r})}{r\ln(\frac{r}{r-1})}+1
\]</span></p>
<h1 id="参考资料">参考资料</h1>
<p>[1] https://blog.rijuyuezhu.top/posts/58a68c50/</p>
<p>[2] Foerster, K. T. (2013, January). Approximating fault-tolerant
domination in general graphs. In 2013 Proceedings of the Tenth Workshop
on Analytic Algorithmics and Combinatorics (ANALCO) (pp. 25-32). Society
for Industrial and Applied Mathematics.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解（三） Open Topic 16 笔记</title>
    <url>/posts/e40b987f/</url>
    <content><![CDATA[<p>OT：除米什拉-格赖斯算法和贪心算法外，边染色和点染色问题还有很多其它算法，请为每种问题调研至少1种精确算法（暴力算法不在调研范围内），结合例子介绍算法的设计与分析。</p>
<span id="more"></span>
<p><a href="slide/slide.html">slide</a></p>
<h1 id="图染色问题的两种精确算法">图染色问题的两种精确算法</h1>
<h2 id="简介">简介</h2>
<ul>
<li>最小点染色算法：动态规划 [1] (Lawler, 1976), 时间复杂度 <span
class="math inline">\(O(nm(1+\sqrt[3]{3})^n)\)</span>，约为 <span
class="math inline">\(O(nm\cdot 2.445^n)\)</span>。</li>
<li>最小边染色算法：二分图最小边染色 [2] (Schrijver, 1998)，时间复杂度
<span class="math inline">\(O(\Delta m)\)</span>。</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<h3 id="思路">思路</h3>
<p>若要对于 <span class="math inline">\(G=\langle V, E\rangle\)</span>
染色 <span class="math inline">\(\lbrace 1, 2, \cdots,
k\rbrace\)</span>，可以考虑枚举染色为 <span
class="math inline">\(k\)</span> 的顶点子集（独立集） <span
class="math inline">\(S\subseteq V\)</span>。容易得到</p>
<p><span class="math display">\[
\chi (G)=1+\min_{S}\lbrace \chi(G-S)\rbrace
\]</span></p>
<p>其中要求 <span class="math inline">\(S\subseteq V\)</span> 且 <span
class="math inline">\(S\)</span> 为 <span
class="math inline">\(G\)</span> 的独立集。</p>
<p>边界条件 <span
class="math inline">\(\chi(\varnothing)=0\)</span>。</p>
<p><em>Observation 1.</em> 贪心地，只需考虑 <span
class="math inline">\(S\)</span> 是极大独立集。</p>
<h3 id="若干结论">若干结论</h3>
<p><em>Claim 1.</em> 对于任意图 <span
class="math inline">\(G\)</span>，其大小为 <span
class="math inline">\(r\)</span> 的极大独立集数量不超过 <span
class="math inline">\(3^{r/3}\)</span>。</p>
<p><em>Claim 2.</em> 存在算法可以在 <span
class="math inline">\(O(mrk)\)</span> 时间内生成所有大小为 <span
class="math inline">\(r\)</span> 的极大独立集，<span
class="math inline">\(k\)</span> 为大小为 <span
class="math inline">\(r\)</span> 的极大独立集的数量。</p>
<p>故对于所有的 <span class="math inline">\(V&#39;\subseteq
V\)</span>，递推得到 <span
class="math inline">\(\chi(G[V&#39;])\)</span> 的时间之和线性于</p>
<p><span class="math display">\[
\sum_{r=0}^n \binom{n}{r}mr3^{r/3}\le
nm\sum_{r=0}^n\binom{n}{r}(\sqrt[3]3)^r=nm(1+\sqrt[3]3)^n.
\]</span></p>
<p>即时间复杂度为 <span
class="math inline">\(O(nm(1+\sqrt[3]3)^n)\)</span>。</p>
<h2 id="二分图最小边染色">二分图最小边染色</h2>
<h3 id="主要思路">主要思路</h3>
<ul>
<li><span class="math inline">\(\quad\)</span> 任意二分图 <span
class="math inline">\(G\)</span></li>
<li><span class="math inline">\(\to\)</span> <span
class="math inline">\(\Delta(G)\)</span>-正则二分图 <span
class="math inline">\(G&#39;\)</span></li>
<li><span class="math inline">\(\to\)</span> 对 <span
class="math inline">\(G&#39;\)</span> 进行分治染色。</li>
</ul>
<h3 id="合理性">合理性</h3>
<p>由于二分图是第一类图，故一定有 <span
class="math inline">\(\chi&#39;(G)=\Delta(G)\)</span>。只需求其 <span
class="math inline">\(\Delta(G)\)</span> 边染色。</p>
<p>将 <span class="math inline">\(G\)</span> 转化为 <span
class="math inline">\(\Delta(G)\)</span>-正则二分图 <span
class="math inline">\(G&#39;\)</span> 后，由于 <span
class="math inline">\(G&#39;\)</span> 仍然可以 <span
class="math inline">\(\Delta(G)\)</span>
边染色，故不会影响解的存在性。</p>
<h3 id="二分图-g-至正则二分图-g">二分图 <span
class="math inline">\(G\)</span> 至正则二分图 <span
class="math inline">\(G&#39;\)</span></h3>
<ul>
<li>若在 <span class="math inline">\(G\)</span> 左部 <span
class="math inline">\(X\)</span> 存在 <span class="math inline">\(u,
v\in X\)</span>，满足 <span class="math inline">\(d(u)+d(v)\le
\Delta(G)\)</span>，可以将点 <span class="math inline">\(u,v\)</span>
合并，直至不存在；</li>
<li>对于右部，同理。</li>
<li>再对于 <span class="math inline">\(d(v)&lt;\Delta(G)\)</span> 的点
<span class="math inline">\(v\)</span>，向另一部未满的点随意连边。</li>
</ul>
<h3 id="分治染色">分治染色</h3>
<p>对于 <span class="math inline">\(k\)</span>-正则二分图 <span
class="math inline">\(G&#39;\)</span> 进行染色，分为两种情况</p>
<ul>
<li>若 <span class="math inline">\(k\)</span> 为偶数，可以对 <span
class="math inline">\(G&#39;\)</span> 进行欧拉划分，得到两个 <span
class="math inline">\(\frac{k}{2}\)</span>-正则二分图，分治进行染色</li>
<li>若 <span class="math inline">\(k\)</span> 为奇数，可以先求 <span
class="math inline">\(G&#39;\)</span> 的一个完美匹配进行染色，则归约到
<span class="math inline">\(k-1\)</span> 为偶数的情况。</li>
</ul>
<p><em>Theorem.</em> 存在 <span class="math inline">\(O(km)\)</span>
的求 <span
class="math inline">\(k\)</span>-正则二分图完美匹配的算法。[2]</p>
<p>则该分治算法的复杂度为</p>
<p><span class="math display">\[
\begin{aligned}
T(2k, 2m)&amp;=2T(k, m)+O(m)\\
T(2k+1, 2m)&amp;=2T(k, m)+O(km)
\end{aligned}
\]</span></p>
<p>解得 <span class="math inline">\(T(k, m)=O(km)\)</span>.</p>
<h1 id="参考文献">参考文献</h1>
<p>[1] Lawler, E. L. (1976). A note on the complexity of the chromatic
number problem. Information Processing Letters, 5(3), 66-67.</p>
<p>[2] Schrijver, A. (1998). Bipartite edge coloring in O(Δm) time. SIAM
Journal on Computing, 28(3), 841-846.</p>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
      </tags>
  </entry>
  <entry>
    <title>Fix CS:APP Attack Lab Segmentation Fault on Newest Ubuntu 22.04</title>
    <url>/posts/db646f34/</url>
    <content><![CDATA[<p>In the 3rd Lab of CS:APP: <a
href="https://csapp.cs.cmu.edu/3e/labs.html">Attack Lab</a>, the
distributed binary <code>ctarget</code> is too old and it cannot
normally run on today's Ubuntu 22.04. I tried to analyze the problem and
raise a resolution for that.</p>
<p><a
href="https://stackoverflow.com/questions/77568098/csapp-attack-lab-phase1-segmentation-fault-on-ubuntu22-04">Related
stack overflow question</a>.</p>
<span id="more"></span>
<h1 id="description">Description</h1>
<p>When running <code>./ctarget -q</code> on my Ubuntu 22.04, it skips
the input and raises a Segmentation Fault. Using gdb, I found that it is
due to an instruction in <code>__vfprintf_internal</code> of my
<code>glibc</code>, namely <code>movaps %xmm1, 0x10(%rsp)</code>. This
instruction needs its memory operand <code>0x10(%rsp)</code>
corresponding an address divisible by 16. I guess that due to the
compiling of <code>ctarget</code> is on a old convention, where the size
of function frame is not strictly required to be a multiple of 16. I
tried to manually modify the low bits of <code>%rsp</code> through gdb,
and it eliminates the SIGSEGV, confirming my guessing.</p>
<h1 id="fix-the-problem">Fix the problem</h1>
<p>In the <a
href="https://stackoverflow.com/questions/77568098/csapp-attack-lab-phase1-segmentation-fault-on-ubuntu22-04">Stack
overflow reply</a>, I try to add an interface to make
<code>printf</code> family "adaptive" to the alignment of
<code>%rsp</code>. But it does not work quite well throughout the
experiment. Instead, in this blog, I will use a naive self-made version
printf family and <code>LD_PRELOAD</code> to fix that.</p>
<h2 id="get-self-made-printf.so">Get self-made
<code>printf.so</code></h2>
<p>First of all, we can find a naive printf implementation (For me, I
use the programming homework in <a
href="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/">NJU
PA</a>). Then we can compile it to be a shared library(suppose the
source file is named <code>printf.c</code>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -shared -fPIC -o printf.so printf.c</span><br></pre></td></tr></table></figure>
<p>Notice that we shall provide interface <code>__printf_chk</code> and
<code>__sprintf_chk</code>.</p>
<p>I provide a compiled shared library here: <a
href="printf.so">printf.so</a>.</p>
<h2
id="use-the-ld_preload-to-substitute-the-default-glibc-shared-library">Use
the <code>LD_PRELOAD</code> to substitute the default glibc shared
library</h2>
<p>Put <code>printf.so</code> in the same directory of
<code>ctarget</code>, then use command</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ LD_PRELOAD=./printf.so ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>And it works!</p>
<p>Also, to set <code>LD_PRELOAD</code> in gdb, we can use</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set environment LD_PRELOAD=./printf.so</span><br><span class="line">set args -q</span><br></pre></td></tr></table></figure>
<p>Amazing! <code>ctarget</code> can be normally run on Ubuntu 22.04
now!</p>
]]></content>
      <categories>
        <category>Computer System</category>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Computer Science</tag>
        <tag>Computer System</tag>
      </tags>
  </entry>
  <entry>
    <title>Find subgroups of Sn - A program method</title>
    <url>/posts/53a893c7/</url>
    <content><![CDATA[<p>It is tedious to enumerate all of the subgroups of a symmetric group,
such as <span class="math inline">\(S_4\)</span>. And I wrote a program
to automate it.</p>
<span id="more"></span>
<p>This is one of the problem I met in the book <em>Abstract Algebra -
Theory and Applications, 2018, Thomas Judson</em>:</p>
<p><em>CHAPTER 5. List all of the subgroups of <span
class="math inline">\(S_4\)</span>.</em></p>
<p>Well, though this problem is quite easy (but heavily tedious), I
would like to find a method that automate this task. Then I use the
algorithm as follows:</p>
<ul>
<li>Get distinct <span class="math inline">\(\langle g\rangle\)</span>
for <span class="math inline">\(g\in S_n\)</span>.</li>
<li>All of the subgroups contains several cyclic groups. Then I use
<span class="math inline">\(O(2^m)\)</span> (where <span
class="math inline">\(m\)</span> is the number of distinct cyclic
subgroups of <span class="math inline">\(S_n\)</span>) to enumerate
which cyclic subgroups are necessarily inside a new group we want to
generate.</li>
<li>Then we need to combine these cyclic group to get the bigger group
(and we require that it is as small as possible to avoid missing
solutions). This could be done to use <span
class="math inline">\(X=A_1\cup A_2\cup\cdots A_k\)</span> at the
beginning, and repeat <span class="math inline">\(X:=XX\)</span> until
it converges.</li>
</ul>
<p>And the C++ code is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pn: Denote a permutation of size n.</span></span><br><span class="line"><span class="comment"> * elements in range [0, n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> size_type = std::vector&lt;<span class="type">int</span>&gt;::size_type;</span><br><span class="line">  <span class="built_in">Pn</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;i) : <span class="built_in">n</span>(i.<span class="built_in">size</span>()), <span class="built_in">p</span>(i) &#123;&#125;</span><br><span class="line">  <span class="function">size_type <span class="title">get_n</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Pn &amp;a, <span class="type">const</span> Pn &amp;b);</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Pn &amp;a, <span class="type">const</span> Pn &amp;b);</span><br><span class="line">  <span class="keyword">friend</span> Pn <span class="keyword">operator</span> * (<span class="type">const</span> Pn &amp;a, <span class="type">const</span> Pn &amp;b);</span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="type">const</span> Pn &amp;x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Pn &amp;a, <span class="type">const</span> Pn &amp;b) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(a.n == b.n);</span><br><span class="line">  <span class="keyword">for</span> (Pn::size_type i = <span class="number">0</span>; i != a.n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a.p[i] != b.p[i])</span><br><span class="line">      <span class="keyword">return</span> a.p[i] &lt; b.p[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Pn &amp;a, <span class="type">const</span> Pn &amp;b) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(a.n == b.n);</span><br><span class="line">  <span class="keyword">for</span> (Pn::size_type i = <span class="number">0</span>; i != a.n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a.p[i] != b.p[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Pn <span class="keyword">operator</span> * (<span class="type">const</span> Pn &amp;a, <span class="type">const</span> Pn &amp;b) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(a.n == b.n);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(a.n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (Pn::size_type i = <span class="number">0</span>; i != a.n; ++i)</span><br><span class="line">    ret[i] = a.p[b.p[i]];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pn</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="type">const</span> Pn &amp;x) &#123;</span><br><span class="line">  std::set&lt;<span class="type">int</span>&gt; outputed;</span><br><span class="line">  <span class="type">bool</span> isoutput = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (Pn::size_type i = <span class="number">0</span>; i != x.<span class="built_in">get_n</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.p[i] == (<span class="type">int</span>)i || outputed.<span class="built_in">count</span>(i))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> now = i;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!outputed.<span class="built_in">count</span>(now)) &#123;</span><br><span class="line">      outputed.<span class="built_in">insert</span>(now);</span><br><span class="line">      os &lt;&lt; now + <span class="number">1</span>;</span><br><span class="line">      now = x.p[now];</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    isoutput = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isoutput)</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(1)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pn <span class="title">Pn_identity</span><span class="params">(Pn::size_type n)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; id;</span><br><span class="line">  <span class="keyword">for</span> (Pn::size_type i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">    id.<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pn</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Gn: a subgroup of Sn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> size_type = Pn::size_type;</span><br><span class="line">  <span class="keyword">using</span> iterator = std::set&lt;Pn&gt;::iterator;</span><br><span class="line">  <span class="keyword">using</span> const_iterator = std::set&lt;Pn&gt;::const_iterator;</span><br><span class="line">  <span class="built_in">Gn</span>(size_type n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line">  <span class="function">size_type <span class="title">get_n</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">get_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> eles.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Pn &amp;x)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Gn &amp;x)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> eles.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> eles.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> eles.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> eles.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::set&lt;Pn&gt; eles;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Gn <span class="title">gen_all</span><span class="params">(size_type n)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Gn <span class="title">gen_cycle</span><span class="params">(Pn g)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Gn &amp;a, <span class="type">const</span> Gn &amp;b);</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Gn &amp;a, <span class="type">const</span> Gn &amp;b);</span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="type">const</span> Gn &amp;x);</span><br><span class="line">  <span class="keyword">friend</span> Gn <span class="keyword">operator</span> * (<span class="type">const</span> Gn &amp;a, <span class="type">const</span> Gn &amp;b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gn::insert</span><span class="params">(<span class="type">const</span> Pn &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(n == x.<span class="built_in">get_n</span>());</span><br><span class="line">  eles.<span class="built_in">emplace</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gn::insert</span><span class="params">(<span class="type">const</span> Gn &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(n == x.<span class="built_in">get_n</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : x)</span><br><span class="line">    <span class="built_in">insert</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gen_all_perms</span><span class="params">(Gn::size_type n, Gn::size_type steps, std::set&lt;Pn&gt; &amp;eles,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;<span class="type">int</span>&gt; &amp;used, std::vector&lt;<span class="type">int</span>&gt; &amp;now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (steps == n) &#123;</span><br><span class="line">    eles.<span class="built_in">insert</span>(now);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Gn::size_type i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">      now.<span class="built_in">push_back</span>(i);</span><br><span class="line">      used[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">gen_all_perms</span>(n, steps + <span class="number">1</span>, eles, used, now);</span><br><span class="line">      used[i] = <span class="number">0</span>;</span><br><span class="line">      now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Gn <span class="title">gen_all</span><span class="params">(Gn::size_type n)</span> </span>&#123;</span><br><span class="line">  <span class="function">Gn <span class="title">ret</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(n)</span>, now</span>;</span><br><span class="line">  <span class="built_in">gen_all_perms</span>(n, <span class="number">0</span>, ret.eles, used, now);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Gn <span class="title">gen_id</span><span class="params">(Gn::size_type n)</span> </span>&#123;</span><br><span class="line">  <span class="function">Gn <span class="title">ret</span><span class="params">(n)</span></span>;</span><br><span class="line">  ret.<span class="built_in">insert</span>(<span class="built_in">Pn_identity</span>(n));</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Gn <span class="title">gen_cycle</span><span class="params">(Pn g0)</span> </span>&#123;</span><br><span class="line">  <span class="function">Gn <span class="title">ret</span><span class="params">(g<span class="number">0.</span>get_n())</span></span>;</span><br><span class="line">  Pn g = <span class="built_in">Pn_identity</span>(g<span class="number">0.</span><span class="built_in">get_n</span>());</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> test = ret.eles.<span class="built_in">insert</span>(g);</span><br><span class="line">    <span class="keyword">if</span> (!test.second)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    g = g * g0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Gn &amp;a, <span class="type">const</span> Gn &amp;b) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(a.n == b.n);</span><br><span class="line">  <span class="keyword">if</span> (a.eles.<span class="built_in">size</span>() != b.eles.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> a.eles.<span class="built_in">size</span>() &lt; b.eles.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(), j = b.<span class="built_in">begin</span>();</span><br><span class="line">      i != a.<span class="built_in">end</span>() &amp;&amp; j != b.<span class="built_in">end</span>(); ++i, ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*i == *j)) &#123;</span><br><span class="line">      <span class="keyword">return</span> *i &lt; *j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Gn &amp;a, <span class="type">const</span> Gn &amp;b) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(a.n == b.n);</span><br><span class="line">  <span class="keyword">if</span> (a.eles.<span class="built_in">size</span>() != b.eles.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(), j = b.<span class="built_in">begin</span>();</span><br><span class="line">      i != a.<span class="built_in">end</span>() &amp;&amp; j != b.<span class="built_in">end</span>(); ++i, ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*i == *j)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Gn <span class="keyword">operator</span> * (<span class="type">const</span> Gn &amp;a, <span class="type">const</span> Gn &amp;b) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(a.n == b.n);</span><br><span class="line">  <span class="function">Gn <span class="title">ret</span><span class="params">(a.n)</span></span>;</span><br><span class="line">  ret.<span class="built_in">insert</span>(a);</span><br><span class="line">  ret.<span class="built_in">insert</span>(b);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Gn lst = ret, <span class="built_in">now</span>(a.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x : ret)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;y : ret)</span><br><span class="line">        now.<span class="built_in">insert</span>(x * y);</span><br><span class="line">    ret = now;</span><br><span class="line">    <span class="keyword">if</span> (ret == lst)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="type">const</span> Gn &amp;x) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : x)</span><br><span class="line">    os &lt;&lt; v &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate all of the subgroups of size n.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> size_type = Pn::size_type;</span><br><span class="line">  <span class="keyword">using</span> iterator = std::set&lt;Gn&gt;::iterator;</span><br><span class="line">  <span class="keyword">using</span> const_iterator = std::set&lt;Gn&gt;::const_iterator;</span><br><span class="line">  <span class="built_in">SubSn</span>(size_type n);</span><br><span class="line">  <span class="function">size_type <span class="title">gen_n</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> subs.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> subs.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> subs.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> subs.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::set&lt;Gn&gt; subs;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="type">const</span> SubSn &amp;x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubSn_gen</span><span class="params">(<span class="type">const</span> std::set&lt;Gn&gt;::iterator beg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::set&lt;Gn&gt;::iterator end,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::set&lt;Gn&gt; &amp;subs, Gn now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = beg; it != end; ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> nxt = now * *it;</span><br><span class="line">    <span class="keyword">auto</span> nxtbg = it; ++nxtbg;</span><br><span class="line">    subs.<span class="built_in">insert</span>(nxt);</span><br><span class="line">    <span class="built_in">SubSn_gen</span>(nxtbg, end, subs, nxt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">SubSn::<span class="built_in">SubSn</span>(size_type n) : <span class="built_in">n</span>(n) &#123;</span><br><span class="line">  Gn all = <span class="built_in">gen_all</span>(n);</span><br><span class="line">  std::set&lt;Gn&gt; set_initial;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : all)</span><br><span class="line">    set_initial.<span class="built_in">insert</span>(<span class="built_in">gen_cycle</span>(v));</span><br><span class="line">  Gn identity_group = <span class="built_in">gen_id</span>(n);</span><br><span class="line">  subs.<span class="built_in">insert</span>(identity_group);</span><br><span class="line">  <span class="built_in">SubSn_gen</span>(set_initial.<span class="built_in">begin</span>(), set_initial.<span class="built_in">end</span>(), subs, identity_group);</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="type">const</span> SubSn &amp;x) &#123;</span><br><span class="line">  SubSn::size_type last_order = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">get_size</span>() != last_order) &#123;</span><br><span class="line">      os &lt;&lt; <span class="string">&quot;Order &quot;</span> &lt;&lt; v.<span class="built_in">get_size</span>() &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">      last_order = v.<span class="built_in">get_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">SubSn <span class="title">S</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; S;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The output (needs ~30s) is</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Order 1:</span><br><span class="line">&#123;(1), &#125;</span><br><span class="line">Order 2:</span><br><span class="line">&#123;(1), (34), &#125;</span><br><span class="line">&#123;(1), (23), &#125;</span><br><span class="line">&#123;(1), (24), &#125;</span><br><span class="line">&#123;(1), (12), &#125;</span><br><span class="line">&#123;(1), (12)(34), &#125;</span><br><span class="line">&#123;(1), (13), &#125;</span><br><span class="line">&#123;(1), (13)(24), &#125;</span><br><span class="line">&#123;(1), (14), &#125;</span><br><span class="line">&#123;(1), (14)(23), &#125;</span><br><span class="line">Order 3:</span><br><span class="line">&#123;(1), (234), (243), &#125;</span><br><span class="line">&#123;(1), (123), (132), &#125;</span><br><span class="line">&#123;(1), (124), (142), &#125;</span><br><span class="line">&#123;(1), (134), (143), &#125;</span><br><span class="line">Order 4:</span><br><span class="line">&#123;(1), (34), (12), (12)(34), &#125;</span><br><span class="line">&#123;(1), (23), (14), (14)(23), &#125;</span><br><span class="line">&#123;(1), (24), (13), (13)(24), &#125;</span><br><span class="line">&#123;(1), (12)(34), (13)(24), (14)(23), &#125;</span><br><span class="line">&#123;(1), (12)(34), (1324), (1423), &#125;</span><br><span class="line">&#123;(1), (1234), (13)(24), (1432), &#125;</span><br><span class="line">&#123;(1), (1243), (1342), (14)(23), &#125;</span><br><span class="line">Order 6:</span><br><span class="line">&#123;(1), (34), (23), (234), (243), (24), &#125;</span><br><span class="line">&#123;(1), (34), (13), (134), (143), (14), &#125;</span><br><span class="line">&#123;(1), (23), (12), (123), (132), (13), &#125;</span><br><span class="line">&#123;(1), (24), (12), (124), (142), (14), &#125;</span><br><span class="line">Order 8:</span><br><span class="line">&#123;(1), (34), (12), (12)(34), (13)(24), (1324), (1423), (14)(23), &#125;</span><br><span class="line">&#123;(1), (23), (12)(34), (1243), (1342), (13)(24), (14), (14)(23), &#125;</span><br><span class="line">&#123;(1), (24), (12)(34), (1234), (13), (13)(24), (1432), (14)(23), &#125;</span><br><span class="line">Order 12:</span><br><span class="line">&#123;(1), (234), (243), (12)(34), (123), (124), (132), (134), (13)(24), (142), (143), (14)(23), &#125;</span><br><span class="line">Order 24:</span><br><span class="line">&#123;(1), (34), (23), (234), (243), (24), (12), (12)(34), (123), (1234), (1243), (124), (132), (1342), (13), (134), (13)(24), (1324), (1432), (142), (143), (14), (1423), (14)(23), &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Course Note</category>
        <category>Problem Solving</category>
      </categories>
      <tags>
        <tag>Maths</tag>
        <tag>Computer Science</tag>
        <tag>Problem Solving</tag>
        <tag>Abstract Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>Play with Distrobox!</title>
    <url>/posts/10c49eb6/</url>
    <content><![CDATA[<p><a href="https://github.com/89luca89/distrobox/">Distrobox</a> is a
powerful tool which enables us to run multiple linux distributions and
versions simultaneously, and switch among them seemlessly. In addition
to the basic features provided by distrobox, I write some more scripts
to make it easier to use.</p>
<span id="more"></span>
<h1 id="basic-usage">Basic usage</h1>
<h2 id="create-a-containerdistrobox">Create a container(distrobox)</h2>
<p>See the <a href="https://github.com/89luca89/distrobox/">official
repository</a> to install and use it. For example, I can use</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@rjyz-linux:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">distrobox create -n u22 -i ubuntu:22.04                                                                                                  130 ↵ ✭</span></span><br><span class="line">Creating &#x27;u22&#x27; using image ubuntu:22.04	[ OK ]</span><br><span class="line">Distrobox &#x27;u22&#x27; successfully created.</span><br><span class="line">To enter, run:</span><br><span class="line"></span><br><span class="line">distrobox enter u22</span><br><span class="line"></span><br><span class="line">[rijuyuezhu@rjyz-linux:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">distrobox enter u22                                                                                                                            ✭</span></span><br><span class="line">Starting container...                   	[ OK ]</span><br><span class="line">Installing basic packages...            	[ OK ]</span><br><span class="line">Setting up devpts mounts...             	[ OK ]</span><br><span class="line">...</span><br><span class="line">Container Setup Complete!</span><br></pre></td></tr></table></figure>
<p>And now I get into the container.</p>
<p><strong>Some properties to notice:</strong></p>
<ul>
<li>Many parts of the filesystem are shared between the container(u22)
and host, including <code>/dev</code>, <code>/tmp</code>,
<code>/home</code>, etc. However, Some other places, such as
<code>/etc</code>, <code>/usr</code>, <code>/opt</code> are not shared.
Hence, some programs can be effortlessly run in the container (those
installed locally, e.g. anaconda), but some cannot (those installed by
system-wide package manager like apt).</li>
<li>To access the host's filesystem from containers, use the
<code>/run/host</code> directory, which mounts the host's root
directory.</li>
</ul>
<h2 id="export-apps-bins-to-outside">Export apps &amp; bins to
outside</h2>
<p>Use <a
href="https://github.com/89luca89/distrobox/blob/main/docs/usage/distrobox-export.md"><code>distrobox export</code></a>
to export an app (<code>*.desktop</code> file) or a binary file from a
container out to the host. <a
href="https://github.com/89luca89/distrobox/blob/main/docs/usage/distrobox-export.md">The
tutorial</a> is clear enough, so I won't repeat it here. An example of
using this command could be find at <a href="/posts/3296c668/" title="Install mailmaster via distrobox on other Linux distributions">another blog</a> of mine.</p>
<p>The official tutorial is quite useful and I recommend you to read it.
Also, it provides some <a
href="https://github.com/89luca89/distrobox/blob/main/docs/useful_tips.md">useful
tips</a> to play with distrobox.</p>
<h1 id="my-advanced-configurations">My advanced configurations</h1>
<h2 id="distinguish-inout-prompt">Distinguish in/out prompt</h2>
<p>It could be quite confusing to distinguish between host and
container, since we are using the same username, the same hostname, the
same shell and the same configuration file, and sadly, the same shell
prompt between them. It's necessary to make some changes to the
prompt.</p>
<p>Since I prefer using <a href="https://ohmyz.sh/">oh my zsh</a>, I try
to modify its theme. A tutorial to modify zsh theme could be found <a
href="https://blog.carbonfive.com/writing-zsh-themes-a-quickref/">here</a>.
Previously, I use the omz theme <code>kphoen</code>, and I create my own
theme <code>kphoen-my</code> on its basis. Firstly copy the
<code>kphoen</code> theme to <code>kphoen-my</code>:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@rjyz-linux:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">cp</span> ~/.oh-my-zsh/themes/kphoen.zsh-theme ~/.oh-my-zsh/custom/themes/kphoen-my.zsh-theme</span></span><br><span class="line">[rijuyuezhu@rjyz-linux:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">vim ~/.oh-my-zsh/custom/themes/kphoen-my.zsh-theme</span></span><br></pre></td></tr></table></figure>
<p>Then I modify <code>kphoen-my.zsh-theme</code> as follows</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kphoen-my.zsh-theme</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ZSH_MYTHEME_CONDAENV</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;CONDA_DEFAULT_ENV:-&#125;</span>&quot;</span> &amp;&amp; <span class="string">&quot;<span class="variable">$&#123;CONDA_DEFAULT_ENV&#125;</span>&quot;</span> != base ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;(<span class="variable">$&#123;CONDA_DEFAULT_ENV&#125;</span>) &quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ZSH_MYTHEME_MACHINE</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;CONTAINER_ID:-&#125;</span>&quot;</span> &amp;&amp; ( -e /run/.containerenv || -e /.dockerenv ) ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;%&#123;<span class="variable">$fg</span>[cyan]%&#125;<span class="variable">$&#123;CONTAINER_ID&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;%&#123;<span class="variable">$fg</span>[magenta]%&#125;%m%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ZSH_MYTHEME_SHLVL</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> show_SHLVL=<span class="variable">$&#123;SHLVL&#125;</span></span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;CONTAINER_ID:-&#125;</span>&quot;</span> &amp;&amp; ( -e /run/.containerenv || -e /.dockerenv ) ]]; <span class="keyword">then</span></span><br><span class="line">    (( show_SHLVL-- ))</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;show_SHLVL&#125;</span>&quot;</span> -gt 1 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;%&#123;<span class="variable">$fg</span>[yellow]%&#125;(<span class="variable">$&#123;show_SHLVL&#125;</span>)%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROMPT=<span class="string">&#x27;[%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@$(ZSH_MYTHEME_MACHINE)$(ZSH_MYTHEME_SHLVL):%&#123;$fg[blue]%&#125;%~%&#123;$reset_color%&#125;$(git_prompt_info)] $(ZSH_MYTHEME_CONDAENV)</span></span><br><span class="line"><span class="string">%# &#x27;</span></span><br><span class="line"></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="string">&quot; on %&#123;<span class="variable">$fg</span>[green]%&#125;&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="string">&quot;%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=<span class="string">&quot;&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># display exitcode on the right when &gt;0</span></span><br><span class="line">ZSH_MYTHEME_RETURNCODE=<span class="string">&quot;%(?..%&#123;<span class="variable">$fg</span>[red]%&#125;%? ↵%&#123;<span class="variable">$reset_color</span>%&#125;)&quot;</span></span><br><span class="line"></span><br><span class="line">RPROMPT=<span class="string">&#x27;$&#123;ZSH_MYTHEME_RETURNCODE&#125;$(git_prompt_status)%&#123;$reset_color%&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">ZSH_THEME_GIT_PROMPT_ADDED=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[green]%&#125; ✚&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_MODIFIED=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[blue]%&#125; ✹&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DELETED=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[red]%&#125; ✖&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_RENAMED=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[magenta]%&#125; ➜&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_UNMERGED=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[yellow]%&#125; ═&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_UNTRACKED=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[cyan]%&#125; ✭&quot;</span></span><br></pre></td></tr></table></figure>
<p>To view its effect, when at host the prompt is <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@rjyz-linux:~ on main] </span><br><span class="line"><span class="meta prompt_">%</span></span><br></pre></td></tr></table></figure> where
<code>rjyz-linux</code> is the hostname. When in the container the
prompt is <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@u22:~] </span><br><span class="line"><span class="meta prompt_">% </span></span><br></pre></td></tr></table></figure> where <code>u22</code> is the container id. And
I give container id and hostname different colors.</p>
<p>The crux to manage to do this modification is to notice that, when
inside a container, the environment variable <code>CONTAINER_ID</code>
is set to be the container id.</p>
<h2 id="seemlessly-switch">Seemlessly switch</h2>
<p>When using <code>distrobox enter</code> to go from host to container,
<code>$PWD</code> will be preserved; however, when using
<code>exit</code> to go from container to host, it rewinds to the
directory where you entered the container. To make it seemlessly switch,
I write a script. Put the following script in <code>~/.zshrc</code> or
<code>~/.bashrc</code> and ensure that your host and container share
that.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># distrobox</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;CONTAINER_ID:-&#125;</span>&quot;</span> &amp;&amp; ( -e /run/.containerenv || -e /.dockerenv ) ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># inside container</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">command</span> -v distrobox-host-exec &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">de</span></span>() &#123;</span><br><span class="line">            <span class="comment"># the path is a subdirectory of /home</span></span><br><span class="line">            <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;DISTROBOX_CHGDIR_FILE:-&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">                -e <span class="string">&quot;<span class="variable">$&#123;DISTROBOX_CHGDIR_FILE&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">                <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> =~ <span class="string">&quot;^<span class="subst">$(realpath /home)</span>*&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">pwd</span> &gt; <span class="string">&quot;<span class="variable">$&#123;DISTROBOX_CHGDIR_FILE&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            <span class="built_in">exit</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#----------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#                                                                #</span></span><br><span class="line">        <span class="comment">#   The commented part below will be use later in the tutorial   #</span></span><br><span class="line">        <span class="comment">#                                                                #</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># function dh() &#123;</span></span><br><span class="line">        <span class="comment">#     if [[ $# -eq 0 ]]; then</span></span><br><span class="line">        <span class="comment">#         echo &quot;Usage: dh &lt;command&gt;&quot; &gt;&amp;2</span></span><br><span class="line">        <span class="comment">#         return 127</span></span><br><span class="line">        <span class="comment">#     fi</span></span><br><span class="line">        <span class="comment">#     distrobox-host-exec zsh -ic &quot;$*&quot;</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line">        <span class="comment"># if [ -n &quot;$&#123;ZSH_VERSION:-&#125;&quot; ]; then</span></span><br><span class="line">        <span class="comment">#     function command_not_found_handler() &#123;</span></span><br><span class="line">        <span class="comment">#         dh &quot;$@&quot;</span></span><br><span class="line">        <span class="comment">#     &#125;</span></span><br><span class="line">        <span class="comment"># else</span></span><br><span class="line">        <span class="comment">#     function command_not_found_handle() &#123;</span></span><br><span class="line">        <span class="comment">#         dh &quot;$&#123;@&#125;&quot;</span></span><br><span class="line">        <span class="comment">#     &#125;</span></span><br><span class="line">        <span class="comment"># fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># outside container</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">command</span> -v distrobox &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">de</span></span>() &#123;</span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">enter_container</span></span>() &#123;</span><br><span class="line">                <span class="built_in">local</span> tmpfile=<span class="string">&quot;<span class="subst">$(mktemp /tmp/distrobox.XXXXXX)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                DISTROBOX_CHGDIR_FILE=<span class="string">&quot;<span class="variable">$&#123;tmpfile&#125;</span>&quot;</span> distrobox enter <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$&#123;tmpfile&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">local</span> <span class="built_in">dir</span>=<span class="string">&quot;<span class="subst">$(cat $&#123;tmpfile&#125;)</span>&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;dir:-&#125;</span>&quot;</span> &amp;&amp; -d <span class="string">&quot;<span class="variable">$&#123;dir:-&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span></span><br><span class="line">                    <span class="keyword">fi</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">                <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$&#123;tmpfile&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$#</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">local</span> default_container=<span class="string">&quot;u22&quot;</span></span><br><span class="line">                enter_container <span class="string">&quot;<span class="variable">$&#123;default_container&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                enter_container <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>This enables us to use <code>de</code> to switch between host and
container seemlessly<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> , and it will preserve
<code>$PWD</code> <strong>if <code>$PWD</code> is a subdirectory of
<code>/home</code></strong>. This requirement prohibits confusing
situations where you are in a directory that is not shared between host
and container.</p>
<p>An example:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@rjyz-linux:~/Playground] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">de</span></span><br><span class="line">[rijuyuezhu@u22:~/Playground] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="built_in">test</span> &amp;&amp; <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br><span class="line">[rijuyuezhu@u22:~/Playground/test] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">de</span></span><br><span class="line">[rijuyuezhu@rjyz-linux:~/Playground/test] </span><br><span class="line"><span class="meta prompt_">% </span></span><br></pre></td></tr></table></figure>
<h2 id="execute-host-commands-directly-in-container">Execute host
commands directly in container</h2>
<p>Distrobox provides an interesting mechanism to run host commands from
container. The official tutorial lies <a
href="https://github.com/89luca89/distrobox/blob/main/docs/posts/execute_commands_on_host.md">here</a>.
Firstly, install <a href="https://flatpak.org/">flatpak</a> on the
<strong>host</strong>. Then, when inside container, and you want to run
host commands, simply run <code>distrobox-host-exec &lt;cmd&gt;</code>.
For example,</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@u22:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">distrobox-host-exec <span class="built_in">cat</span> /etc/os-release</span></span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 24.04 LTS&quot;</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION_ID=&quot;24.04&quot;</span><br><span class="line">VERSION=&quot;24.04 LTS (Noble Numbat)&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>EXTREMELY IMPORTANT</strong> thing to notice: the command
runs on the host system directly, instead of "borrowing" binary from the
host. Hence, as you see, the command above prints my host's
information(Ubuntu 24.04), instead of the container's(Ubuntu 22.04).
However, in most cases, this is not a problem: the host and container
share the same <code>/home</code> directory. But remember this to avoid
unexpected results.</p>
<p>Also, notice that environment variables are not preserved in most
cases.</p>
</blockquote>
<p>The <a
href="https://github.com/89luca89/distrobox/blob/main/docs/posts/execute_commands_on_host.md">official
tutorial</a> also provides an interesting method to run host commands
seemlessly in container. It uses the
<code>command_not_found_handle(r?)</code>(zsh has one more
<code>r</code>) mechanism in bash/zsh. When the command is not found in
container, bash/zsh will call the function
<code>command_not_found_handle(r?)</code>. Hence we can use it to
forward the corresponding command to host, as shown in the commented
part in above script. The complement part is as follows:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># distrobox</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;CONTAINER_ID:-&#125;</span>&quot;</span> &amp;&amp; ( -e /run/.containerenv || -e /.dockerenv ) ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># inside container</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">command</span> -v distrobox-host-exec &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">de</span></span>() &#123;</span><br><span class="line">            <span class="comment"># the path is a subdirectory of /home</span></span><br><span class="line">            <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;DISTROBOX_CHGDIR_FILE:-&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">                -e <span class="string">&quot;<span class="variable">$&#123;DISTROBOX_CHGDIR_FILE&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">                <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> =~ <span class="string">&quot;^<span class="subst">$(realpath /home)</span>*&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">pwd</span> &gt; <span class="string">&quot;<span class="variable">$&#123;DISTROBOX_CHGDIR_FILE&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            <span class="built_in">exit</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">dh</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$#</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Usage: dh &lt;command&gt;&quot;</span> &gt;&amp;2</span><br><span class="line">                <span class="built_in">return</span> 127</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            distrobox-host-exec zsh -ic <span class="string">&quot;$*&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;ZSH_VERSION:-&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">command_not_found_handler</span></span>() &#123;</span><br><span class="line">                dh <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">command_not_found_handle</span></span>() &#123;</span><br><span class="line">                dh <span class="string">&quot;<span class="variable">$&#123;@&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># outside container</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">command</span> -v distrobox &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">de</span></span>() &#123;</span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">enter_container</span></span>() &#123;</span><br><span class="line">                <span class="built_in">local</span> tmpfile=<span class="string">&quot;<span class="subst">$(mktemp /tmp/distrobox.XXXXXX)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                DISTROBOX_CHGDIR_FILE=<span class="string">&quot;<span class="variable">$&#123;tmpfile&#125;</span>&quot;</span> distrobox enter <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$&#123;tmpfile&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">local</span> <span class="built_in">dir</span>=<span class="string">&quot;<span class="subst">$(cat $&#123;tmpfile&#125;)</span>&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;dir:-&#125;</span>&quot;</span> &amp;&amp; -d <span class="string">&quot;<span class="variable">$&#123;dir:-&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span></span><br><span class="line">                    <span class="keyword">fi</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">                <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$&#123;tmpfile&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$#</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">local</span> default_container=<span class="string">&quot;u22&quot;</span></span><br><span class="line">                enter_container <span class="string">&quot;<span class="variable">$&#123;default_container&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                enter_container <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>Now you can use <code>dh</code> to run host commands in container.
Also, when the command cannot be found in container, it will be
forwarded to the host. For example, <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[rijuyuezhu@u22:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">env</span> node</span></span><br><span class="line">env: ‘node’: No such file or directory</span><br><span class="line">[rijuyuezhu@u22:~] </span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">node</span></span><br><span class="line">Welcome to Node.js v18.19.1.</span><br><span class="line">Type &quot;.help&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt; </span></span><br></pre></td></tr></table></figure> I do not have
<code>node</code> installed in the container, but I can use
<code>node</code> command in the container to make it run at host.</p>
<p>Some may argue that this is not good - we do not know which command
is run in the container and which is run at host. However, this is not a
problem, since we can use tools like <a
href="https://github.com/zsh-users/zsh-syntax-highlighting"><code>zsh-syntax-highlighting</code></a>
to distinguish those commands that can be found in the container and
those cannot. Also, this mechanism is only used for interactive shells
(since we put it in <code>~/.zshrc</code> or <code>~/.bashrc</code>),
and it has no effect on shell scripts.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>When entering a container from host, you can use one
argument to indicate which container to use. Otherwise the script uses
the default, hardcoded in the script(<code>u22</code> here)<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker/Podman</tag>
      </tags>
  </entry>
  <entry>
    <title>Run &#39;code&#39; from remote and open VSCode locally to view</title>
    <url>/posts/50171005/</url>
    <content><![CDATA[<p>VSCode CLI <code>code &lt;dir/file&gt;</code> is extremely convenient
to use. It will open a VSCode session from the terminal. When using
sshed terminal at remote, we do want to use such convenience. This
tutorial will show how to run <code>code</code> from remote, then VSCode
that runs locally will open the remote directory.</p>
<span id="more"></span>
<h1 id="prerequisition">Prerequisition</h1>
<ul>
<li>VSCode and Remote SSH extension installed</li>
<li>SSH connection to the remote server</li>
</ul>
<h1 id="tutorial">Tutorial</h1>
<h2 id="prepare-scripts">Prepare scripts</h2>
<p>Put the following scripts in a Path-reachable directory:</p>
<p>Script name: <code>code</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> process=$(<span class="built_in">echo</span> <span class="variable">$HOME</span>/.vscode-server/cli/servers/*/server/bin/remote-cli/code(*oc[1]N))</span><br><span class="line"><span class="built_in">local</span> config_dir=<span class="variable">$HOME</span>/.config/setcode</span><br><span class="line"><span class="built_in">local</span> ipc_file=<span class="variable">$&#123;config_dir&#125;</span>/ipc</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;config_dir&#125;</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;VSCODE_IPC_HOOK_CLI&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">if</span> [[ -e <span class="variable">$&#123;ipc_file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">export</span> VSCODE_IPC_HOOK_CLI=$(<span class="built_in">cat</span> <span class="variable">$&#123;ipc_file&#125;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;No running vscode server found&quot;</span> &gt;&amp;2</span><br><span class="line">		<span class="built_in">exit</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="variable">$&#123;process&#125;</span> <span class="variable">$@</span> --new-window</span><br></pre></td></tr></table></figure></p>
<p>Script name: <code>setcode</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> config_dir=<span class="variable">$HOME</span>/.config/setcode</span><br><span class="line"><span class="built_in">local</span> ipc_file=<span class="variable">$&#123;config_dir&#125;</span>/ipc</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;config_dir&#125;</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;VSCODE_IPC_HOOK_CLI&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;No running vscode server found&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;VSCODE_IPC_HOOK_CLI&#125;</span> &gt; <span class="variable">$&#123;ipc_file&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="workflow">Workflow</h2>
<ul>
<li>Every time you want to use <code>code</code> from remote, firstly
run VSCode to connect to the remote manually, and use the VSCode
terminal to run <code>setcode</code>. Then you shall put this window in
the background.</li>
</ul>
<p><img src="1.png" width="70%"/></p>
<ul>
<li>Then you can ssh using normal terminal. When you want to open a
remote directory, simply run <code>code &lt;dir/file&gt;</code> at
remote terminal. You can run this command multiple times to open
multiple directories, as long as the initial <code>setcode</code> VSCode
window is not closed.</li>
</ul>
<p><img src="2.png" width="70%"/></p>
<h2 id="references">References</h2>
<p><a
href="https://stackoverflow.com/questions/62201080/is-it-possible-to-use-the-code-command-in-sshed-terminal-to-open-vs-code-on-l/68090934"
class="uri">https://stackoverflow.com/questions/62201080/is-it-possible-to-use-the-code-command-in-sshed-terminal-to-open-vs-code-on-l/68090934</a></p>
<p><strong>PS.</strong> The method mentioned in the above reference
works badly for me. It is hard to judge which socket shall I use. So I
write a <code>setcode</code> script to set the socket manually.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Way to Expose GUI from Docker Container</title>
    <url>/posts/e2d2247c/</url>
    <content><![CDATA[<p>Docker containers play an important role in modern software
development. Having a CLI access to the container is common, but
sometimes we need to expose a GUI from the docker container. Here is a
tutorial.</p>
<span id="more"></span>
<h1 id="tutorial">Tutorial</h1>
<h2 id="recap-cli-access">Recap: CLI Access</h2>
<p>Normally, we use the docker flag <code>-it</code> (interactive &amp;
tty) to access a tty of the container, which provides us a CLI access to
the container. For example, we can run a Ubuntu 22.04 image with the
command</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="comment"># create a docker container from image `ubuntu:22.04`</span></span><br><span class="line">$ docker run \</span><br><span class="line">    -it \</span><br><span class="line">    -name <span class="built_in">test</span> \</span><br><span class="line">    ubuntu:22.04</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># later on, we can attach to the container</span></span><br><span class="line">$ docker attach <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h2 id="gui-access">GUI Access</h2>
<p>We share the X11 socket between the host and the container to enable
GUI access. This could be achieved by the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run \</span><br><span class="line">    -it \</span><br><span class="line">    -e <span class="string">&quot;DISPLAY=<span class="variable">$DISPLAY</span>&quot;</span> \</span><br><span class="line">    -v /tmp/.X11-unix/:/tmp/.X11-unix \</span><br><span class="line">    -v <span class="string">&quot;<span class="variable">$&#123;XAUTHORITY:-<span class="variable">$HOME</span>/.Xauthority&#125;</span>:/root/.Xauthority:rw&quot;</span> \</span><br><span class="line">    --name <span class="built_in">test</span> \</span><br><span class="line">    ubuntu:22.04</span><br></pre></td></tr></table></figure>
<p>Then the GUI application can be run in the container, exposing the
GUI to the outside. For example, the Kate editor:</p>
<p><img src="1.png" width="70%" /></p>
<p>(The hostname of the container will be shown in the title bar.)</p>
<h1 id="some-extensions">Some Extensions</h1>
<h2 id="vnc-server">VNC Server</h2>
<p>Another way to expose the GUI is to use a VNC server. See <a
href="https://medium.com/@gustav0.lewin/how-to-make-a-docker-container-with-vnc-access-f607958141ae"
class="uri">https://medium.com/@gustav0.lewin/how-to-make-a-docker-container-with-vnc-access-f607958141ae</a>.</p>
<h1 id="references">References</h1>
<ol type="1">
<li><a
href="https://stackoverflow.com/questions/44429394/x11-forwarding-of-a-gui-app-running-in-docker"
class="uri">https://stackoverflow.com/questions/44429394/x11-forwarding-of-a-gui-app-running-in-docker</a></li>
<li><a href="https://dzone.com/articles/docker-x11-client-via-ssh"
class="uri">https://dzone.com/articles/docker-x11-client-via-ssh</a></li>
<li><a href="https://github.com/sickcodes/Docker-OSX/tree/master"
class="uri">https://github.com/sickcodes/Docker-OSX/tree/master</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker/Podman</tag>
      </tags>
  </entry>
  <entry>
    <title>Install mailmaster via distrobox on other Linux distributions</title>
    <url>/posts/3296c668/</url>
    <content><![CDATA[<p><a href="https://dashi.163.com/">NetEase Mailmaster(网易邮箱大师 in
Chinese)</a> is a mail integrated management platform developed by
Netease. It provides a <code>.deb</code> package for Ubuntu 22.04.
However, for other distributions and versions, installing it with
correct dependencies is a bit toublesome. Using containers is a common
way to handle this issue. <a
href="https://github.com/89luca89/distrobox/">Distrobox</a> provides
fantastic device compatibility between the container and the host, and
thus is extremely suitable for GUI application containers.</p>
<span id="more"></span>
<h1 id="installing-distrobox">Installing distrobox</h1>
<p>To install distrobox, see the <a
href="https://github.com/89luca89/distrobox/">official installation
guide</a>.</p>
<h1 id="create-a-ubuntu-22.04-container-for-mailmaster">Create a Ubuntu
22.04 container for mailmaster</h1>
<p>Firstly, we shall notice that, mailmaster will be installed in the
container under the directory <code>/opt/mailmaster/</code>. However,
the <code>/opt</code> directory will not be shared by default distrobox
configuration. Hence we add an extra volume command to map the host's
<code>/opt</code> directory to the container's <code>/opt</code>, as
shown below. This helps ensuring that mailmaster runs normally
(otherwise, some functionalities, such as opening the associated file,
will not work).</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(host)$ </span><span class="language-bash">distrobox create \</span></span><br><span class="line"><span class="language-bash">    -n mailmaster-u22 \</span></span><br><span class="line"><span class="language-bash">    --no-entry \</span></span><br><span class="line"><span class="language-bash">    --volume /opt/mailmaster:/opt/mailmaster:ro \</span></span><br><span class="line"><span class="language-bash">    -i ubuntu:22.04</span></span><br></pre></td></tr></table></figure>
<h1 id="install-the-.deb">Install the .deb</h1>
<p>After that, enter the container, and install the downloaded package
from <a href="https://dashi.163.com/">NetEase mailmaster official
website</a>.</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(host)$ </span><span class="language-bash">distrobox enter mailmaster-u22</span></span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">mail.deb</span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">sudo</span> dpkg -i mail.deb</span></span><br><span class="line">Error: Read-only file system</span><br></pre></td></tr></table></figure>
<p>However, we find it goes wrong, since <code>/opt/mailmaster</code> is
read-only. Even if we use <code>:rw</code> flag above to make it
writable, we have not enough permissions to write to
<code>/opt/mailmaster</code>.</p>
<blockquote>
<p>This is because, <code>podman</code>, the default container runtime
of distrobox, runs in rootless mode by default, and the
<code>sudo</code> inside the container is a disguised one. We cannot use
<code>sudo</code> in the container to get root permissions on the
host.</p>
</blockquote>
<h1 id="a-workaround">A workaround</h1>
<p>A workaround is to use another directory with full permission to
"replace" <code>/opt</code> for a while. For example, we could use mount
to let <code>~/tmpdir</code> mounted to <code>/opt</code>:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">mkdir</span> ~/tmpdir</span></span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">sudo</span> mount --<span class="built_in">bind</span> ~/tmpdir /opt</span></span><br></pre></td></tr></table></figure>
<p>Then we can install the package:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">sudo</span> dpkg -i mail.deb</span></span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install -f</span></span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install lsb-release zenity qtbase5-dev</span></span><br></pre></td></tr></table></figure>
<p>And now mailmaster could be run normally: <figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash">/opt/mailmaster/launch.sh</span></span><br></pre></td></tr></table></figure></p>
<p>However, we do not want a strange <code>~/tmpdir</code> in our home
directory, and we shall make use of the mapping
<code>/opt/mailmaster/:/opt/mailmaster/:ro</code> we added before. This
can be achieved by moving the directory with true <code>sudo</code> on
the host, and then we <code>umount</code> the original binding in the
container. <figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_">(host)$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mv</span> ~/tmpdir/mailmaster /opt/</span></span><br><span class="line"><span class="meta prompt_">(host)$ </span><span class="language-bash">distrobox enter mailmaster-u22</span></span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">sudo</span> umount /opt</span></span><br><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash"><span class="built_in">rmdir</span> ~/tmpdir</span></span><br></pre></td></tr></table></figure></p>
<p>Now everything works well!</p>
<h1 id="export-the-app">Export the app</h1>
<p>And finally, we use <code>distrobox-export</code> to export our app
to host:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">(mailmaster-u22)$ </span><span class="language-bash">distrobox-export -el none --app mailmaster</span></span><br></pre></td></tr></table></figure>
<p>Then a desktop file is generated at
<code>~/.local/share/applications/</code> and we can run mailmaster from
your desktop menu!</p>
<h1 id="further-reading">Further Reading</h1>
<p>Distrobox is quite useful and powerful, not only for exporting GUI
applications, but also for developing and testing. For example, if you
want to use <a href="https://archlinux.org/">archlinux</a> without the
risk of breaking the system when updating, it is a good choice to create
a archlinux container and install the latest packages you like by using
distrobox.</p>
<p>For more advanced usage, you can check out the <a
href="https://github.com/89luca89/distrobox/">official
documentation</a>. I also write another blog <a href="/posts/10c49eb6/" title="Play with Distrobox!">here</a> to show my
advanced usage of distrobox.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker/Podman</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Compilation Introduction</title>
    <url>/posts/54261af8/</url>
    <content><![CDATA[<p>This article introduces the basic concepts of AI compilation,
including its workflow, and its applications such as PyTorch, TVM, and
MLIR.</p>
<span id="more"></span>
<h1 id="ai-compilation-introduction"><strong>AI Compilation
Introduction</strong></h1>
<h2 id="ai-compilation-designs">AI Compilation Designs</h2>
<p>AI Compilers transform a <em>computation graph</em> into low-level
code (e.g. LLVM-IR, SPIR-V, MLIR) which can be interpreted or further
compiled for a <em>target device</em>. An AI Compiler typically consists
of the following parts.</p>
<figure>
<img src="aicompiler.drawio.svg" width=100% />
<figcaption>
<p>
Figure 1: AI Compiler Routine
</p>
</figcaption>
</figure>
<p>There are three levels of optimization in AI compilers:</p>
<dl>
<dt>Graph-Level Optimization.</dt>
<dd>
<p>The computation graph is optimized by operating on the graph
structure, such as removing redundant nodes (operators), fusing nodes,
and applying graph-level transformations.</p>
</dd>
<dt>Operator-Level Optimization.</dt>
<dd>
<p>An operator can be optimized by applying transformations to the
for-loops, such as loop unrolling, loop tiling, and loop fusion.</p>
</dd>
<dt>ISA-Level Optimization.</dt>
<dd>
<p>The backend generates code that leverages special instructions on the
target device, such as SIMD instructions, tensor instructions, and other
hardware accelerator-specific instructions.</p>
</dd>
</dl>
<h3 id="great-articles">Great Articles</h3>
<ul>
<li>Awesome Tensor Compilers: <a
href="https://github.com/merrymercy/awesome-tensor-compilers"
class="uri">https://github.com/merrymercy/awesome-tensor-compilers</a></li>
</ul>
<h2 id="pytorch-infrastructure">PyTorch Infrastructure</h2>
<p>By default, PyTorch uses its eager execution mode to describe a
model, where the computation graph is dynamically constructed and
executed, and is referred to as a <em>dynamic graph</em>.</p>
<p>PyTorch provides several ways to convert the dynamic graph to a
<em>static graph</em> for AI compilation.</p>
<h3 id="torchscript">TorchScript</h3>
<p><strong>TorchScript</strong> (deprecated) is a method to convert the
dynamic graph to a static graph using a Python-like language.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCell</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCell, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, h</span>):</span><br><span class="line">        new_h = torch.tanh(<span class="variable language_">self</span>.linear(x) + h)</span><br><span class="line">        <span class="keyword">return</span> new_h, new_h</span><br><span class="line"></span><br><span class="line">my_cell = MyCell()</span><br><span class="line">x, h = torch.rand(<span class="number">3</span>, <span class="number">4</span>), torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;my_cell: \n&quot;</span>, my_cell, <span class="string">&quot;\n&quot;</span>, my_cell(x, h), <span class="string">&quot;\n&quot;</span>, my_cell.graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Way 1: tracing the model</span></span><br><span class="line">traced_cell = torch.jit.trace(my_cell, (x, h))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n\ntraced_cell: \n&quot;</span>, traced_cell, <span class="string">&quot;\n&quot;</span>, traced_cell(x, h), <span class="string">&quot;\n&quot;</span>, traced_cell.graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Way 2: scripting the model</span></span><br><span class="line">scripted_cell = torch.jit.script(my_cell)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n\nscripted_cell: \n&quot;</span>, scripted_cell, <span class="string">&quot;\n&quot;</span>, scripted_cell(x, h), <span class="string">&quot;\n&quot;</span>, scripted_cell.graph)</span><br></pre></td></tr></table></figure>
<p>This outputs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_cell:</span><br><span class="line"> MyCell(</span><br><span class="line">  (linear): Linear(in_features=4, out_features=4, bias=True)</span><br><span class="line">)</span><br><span class="line"> (tensor([[0.0229, 0.3737, 0.6648, 0.7164],</span><br><span class="line">        [0.6495, 0.6735, 0.4847, 0.3583],</span><br><span class="line">        [0.2359, 0.4631, 0.9131, 0.4446]], grad_fn=&lt;TanhBackward0&gt;), tensor([[0.0229, 0.3737, 0.6648, 0.7164],</span><br><span class="line">        [0.6495, 0.6735, 0.4847, 0.3583],</span><br><span class="line">        [0.2359, 0.4631, 0.9131, 0.4446]], grad_fn=&lt;TanhBackward0&gt;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">traced_cell:</span><br><span class="line"> MyCell(</span><br><span class="line">  original_name=MyCell</span><br><span class="line">  (linear): Linear(original_name=Linear)</span><br><span class="line">)</span><br><span class="line"> (tensor([[0.0229, 0.3737, 0.6648, 0.7164],</span><br><span class="line">        [0.6495, 0.6735, 0.4847, 0.3583],</span><br><span class="line">        [0.2359, 0.4631, 0.9131, 0.4446]], grad_fn=&lt;TanhBackward0&gt;), tensor([[0.0229, 0.3737, 0.6648, 0.7164],</span><br><span class="line">        [0.6495, 0.6735, 0.4847, 0.3583],</span><br><span class="line">        [0.2359, 0.4631, 0.9131, 0.4446]], grad_fn=&lt;TanhBackward0&gt;))</span><br><span class="line"> graph(%self.1 : __torch__.MyCell,</span><br><span class="line">      %x : Float(3, 4, strides=[4, 1], requires_grad=0, device=cpu),</span><br><span class="line">      %h : Float(3, 4, strides=[4, 1], requires_grad=0, device=cpu)):</span><br><span class="line">  %linear : __torch__.torch.nn.modules.linear.Linear = prim::GetAttr[name=&quot;linear&quot;](%self.1)</span><br><span class="line">  %20 : Tensor = prim::CallMethod[name=&quot;forward&quot;](%linear, %x)</span><br><span class="line">  %11 : int = prim::Constant[value=1]() # /pwd/main.py:9:0</span><br><span class="line">  %12 : Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu) = aten::add(%20, %h, %11) # /pwd/main.py:90</span><br><span class="line">  %13 : Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu) = aten::tanh(%12) # /pwd/main.py:9:0</span><br><span class="line">  %14 : (Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu), Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu)) = prim::TupleConstruct(%13, %13)</span><br><span class="line">  return (%14)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scripted_cell:</span><br><span class="line"> RecursiveScriptModule(</span><br><span class="line">  original_name=MyCell</span><br><span class="line">  (linear): RecursiveScriptModule(original_name=Linear)</span><br><span class="line">)</span><br><span class="line"> (tensor([[0.0229, 0.3737, 0.6648, 0.7164],</span><br><span class="line">        [0.6495, 0.6735, 0.4847, 0.3583],</span><br><span class="line">        [0.2359, 0.4631, 0.9131, 0.4446]], grad_fn=&lt;TanhBackward0&gt;), tensor([[0.0229, 0.3737, 0.6648, 0.7164],</span><br><span class="line">        [0.6495, 0.6735, 0.4847, 0.3583],</span><br><span class="line">        [0.2359, 0.4631, 0.9131, 0.4446]], grad_fn=&lt;TanhBackward0&gt;))</span><br><span class="line"> graph(%self : __torch__.___torch_mangle_3.MyCell,</span><br><span class="line">      %x.1 : Tensor,</span><br><span class="line">      %h.1 : Tensor):</span><br><span class="line">  %7 : int = prim::Constant[value=1]()</span><br><span class="line">  %linear : __torch__.torch.nn.modules.linear.___torch_mangle_2.Linear = prim::GetAttr[name=&quot;linear&quot;](%self)</span><br><span class="line">  %5 : Tensor = prim::CallMethod[name=&quot;forward&quot;](%linear, %x.1) # /pwd/main.py:9:27</span><br><span class="line">  %8 : Tensor = aten::add(%5, %h.1, %7) # /pwd/main.py:9:27</span><br><span class="line">  %new_h.1 : Tensor = aten::tanh(%8) # /pwd/main.py:9:16</span><br><span class="line">  %12 : (Tensor, Tensor) = prim::TupleConstruct(%new_h.1, %new_h.1)</span><br><span class="line">  return (%12)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>Trace</strong> (<code>torch.jit.trace</code>) is a way to
convert the dynamic graph to a static graph by tracing the model with a
set of inputs. However, some control flows cannot be traced. For
example,</p>
<pre><code>class MyDecisionGate(torch.nn.Module):
   def forward(self, x):
       if x.sum() &gt; 0:
           return x
       else:
           return -x</code></pre></li>
<li><p><strong>Script</strong> (<code>torch.jit.script</code>) is a way
to convert the dynamic graph to a static graph by using a Python-like
language. It can handle control flows, but it requires the model to be
written in a subset of Python.</p></li>
</ul>
<h3 id="torch-fx">Torch FX</h3>
<p><strong>Torch FX</strong> is a tool for modifying the computational
graph. Some optimizations, such as operator fusion, can be applied to
the graph using this tool. Also, Torch FX supports
<code>torch.fx.Graph</code>, which is a way to represent the computation
graph in a more flexible way (it is like a call graph!).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.fx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.param = torch.nn.Parameter(torch.rand(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="variable language_">self</span>.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.topk(</span><br><span class="line">            torch.<span class="built_in">sum</span>(<span class="variable language_">self</span>.linear(x + <span class="variable language_">self</span>.linear.weight).relu(), dim=-<span class="number">1</span>), <span class="number">3</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = MyModule()</span><br><span class="line">gm = torch.fx.symbolic_trace(m)</span><br><span class="line"></span><br><span class="line">gm.graph.print_tabular()</span><br></pre></td></tr></table></figure>
<p>This outputs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode         name           target                                                   args                kwargs</span><br><span class="line">-------------  -------------  -------------------------------------------------------  ------------------  -----------</span><br><span class="line">placeholder    x              x                                                        ()                  &#123;&#125;</span><br><span class="line">get_attr       linear_weight  linear.weight                                            ()                  &#123;&#125;</span><br><span class="line">call_function  add            &lt;built-in function add&gt;                                  (x, linear_weight)  &#123;&#125;</span><br><span class="line">call_module    linear         linear                                                   (add,)              &#123;&#125;</span><br><span class="line">call_method    relu           relu                                                     (linear,)           &#123;&#125;</span><br><span class="line">call_function  sum_1          &lt;built-in method sum of type object at 0x7dc9e439af60&gt;   (relu,)             &#123;&#x27;dim&#x27;: -1&#125;</span><br><span class="line">call_function  topk           &lt;built-in method topk of type object at 0x7dc9e439af60&gt;  (sum_1, 3)          &#123;&#125;</span><br><span class="line">output         output         output                                                   (topk,)             &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="torch-compile-and-torch-dynamo">Torch Compile and Torch
Dynamo</h3>
<ul>
<li><p>Torch Compile (<code>torch.compile</code>) provides a high-level
API to compile PyTorch models into static graphs just in time. It uses
Torch Dynamo as the backend to generate the static graph.</p></li>
<li><p>Torch Dynamo, different from TorchScript and Torch FX, uses JIT
to compile the <em>bytecode</em> of the model to a static graph. When
some operations in the computational graph generations are hard to
compile without further information, Torch Dynamo could break the whole
generation into several smaller graphs and compile them one by one,
leaving the barrier unchanged.</p></li>
<li><p>Torch Dynamo provides a way to compile the model to Torch FX
Graph, under the circumstance that NO barriers (as mentioned above) are
met.</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="meta">@torch.compile</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCell</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCell, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, h</span>):</span><br><span class="line">        new_h = torch.tanh(<span class="variable language_">self</span>.linear(x) + h)</span><br><span class="line">        <span class="keyword">return</span> new_h, new_h</span><br><span class="line"></span><br><span class="line">my_cell = MyCell()</span><br><span class="line">x, h = torch.rand(<span class="number">3</span>, <span class="number">4</span>), torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(my_cell(x, h))</span><br></pre></td></tr></table></figure>
<h3 id="great-articles-1">Great Articles</h3>
<ul>
<li>PyTorch Official Tutorial: <a href="https://pytorch.org/tutorials/"
class="uri">https://pytorch.org/tutorials/</a></li>
</ul>
<h2 id="tvm-tensor-virtual-machine">TVM (Tensor Virtual Machine)</h2>
<h3 id="concepts">Concepts</h3>
<p>TVM compiles deep learning models (Computation Graph) into various
hardware device instruction sets (with minimal runtime). It receives
<strong>models</strong> from PyTorch, TensorFlow, ONNX etc., and
compiles them for various target <strong>devices</strong>.</p>
<figure>
<img src="tvm_overall_flow.svg" width=70% />
<figcaption>
<p>
Figure 2: TVM working flow
</p>
</figcaption>
</figure>
<figure>
<img src="tvm_compile_rt.png" width=70% />
<figcaption>
<p>
Figure 3: TVM compilation and runtime
</p>
</figcaption>
</figure>
<h3 id="running-example">Running Example</h3>
<p>Given a simple MLP model (here we use TVM frontend to describe the
model; in practice, one can use PyTorch or other frameworks to define
it):<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tvm</span><br><span class="line"><span class="keyword">from</span> tvm <span class="keyword">import</span> relax</span><br><span class="line"><span class="keyword">from</span> tvm.relax.frontend <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLPModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MLPModel, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">        <span class="variable language_">self</span>.relu1 = nn.ReLU()</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.fc1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.relu1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>Then we manually instruct TVM to generate an <em>IRModule</em>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mod, param_spec = MLPModel().export_tvm(</span><br><span class="line">    spec=&#123;<span class="string">&quot;forward&quot;</span>: &#123;<span class="string">&quot;x&quot;</span>: nn.spec.Tensor((<span class="number">1</span>, <span class="number">784</span>), <span class="string">&quot;float32&quot;</span>)&#125;&#125;</span><br><span class="line">)</span><br><span class="line">mod.show()</span><br></pre></td></tr></table></figure>
<p>The module is in the following form, showing the entire computation
graph:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from tvm.script import ir as I</span></span><br><span class="line"><span class="comment"># from tvm.script import relax as R</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@I.ir_module</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>:</span><br><span class="line"><span class="meta">    @R.function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x: R.Tensor(<span class="params">(<span class="params"><span class="number">1</span>, <span class="number">784</span></span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc1_weight: R.Tensor(<span class="params">(<span class="params"><span class="number">256</span>, <span class="number">784</span></span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc1_bias: R.Tensor(<span class="params">(<span class="params"><span class="number">256</span>,</span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc2_weight: R.Tensor(<span class="params">(<span class="params"><span class="number">10</span>, <span class="number">256</span></span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc2_bias: R.Tensor(<span class="params">(<span class="params"><span class="number">10</span>,</span>), dtype=<span class="string">&quot;float32&quot;</span></span>)</span>) -&gt; R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>):</span><br><span class="line">        R.func_attr(&#123;<span class="string">&quot;num_input&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="keyword">with</span> R.dataflow():</span><br><span class="line">            permute_dims: R.Tensor((<span class="number">784</span>, <span class="number">256</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.permute_dims(fc1_weight, axes=<span class="literal">None</span>)</span><br><span class="line">            matmul: R.Tensor((<span class="number">1</span>, <span class="number">256</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.matmul(x, permute_dims, out_dtype=<span class="string">&quot;void&quot;</span>)</span><br><span class="line">            add: R.Tensor((<span class="number">1</span>, <span class="number">256</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.add(matmul, fc1_bias)</span><br><span class="line">            relu: R.Tensor((<span class="number">1</span>, <span class="number">256</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.nn.relu(add)</span><br><span class="line">            permute_dims1: R.Tensor((<span class="number">256</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.permute_dims(fc2_weight, axes=<span class="literal">None</span>)</span><br><span class="line">            matmul1: R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.matmul(relu, permute_dims1, out_dtype=<span class="string">&quot;void&quot;</span>)</span><br><span class="line">            add1: R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.add(matmul1, fc2_bias)</span><br><span class="line">            gv: R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = add1</span><br><span class="line">            R.output(gv)</span><br><span class="line">        <span class="keyword">return</span> gv</span><br></pre></td></tr></table></figure>
<p>Then optimization passes are applied to the IRModule in a pipelined
manner. A library dispatch can be applied, and auto-tuning can be used
to find the best configuration for the target device. For example, the
following example fuses <code>nn.Linear</code> and <code>nn.ReLU</code>
and rewrites them into a <code>call_dps_packed</code> function for
CUBLAS library.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import cublas pattern</span></span><br><span class="line"><span class="keyword">import</span> tvm.relax.backend.cuda.cublas <span class="keyword">as</span> _cublas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a new pass for CUBLAS dispatch</span></span><br><span class="line"><span class="meta">@tvm.transform.module_pass(<span class="params">opt_level=<span class="number">0</span>, name=<span class="string">&quot;CublasDispatch&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CublasDispatch</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transform_module</span>(<span class="params">self, mod: IRModule, _ctx: tvm.transform.PassContext</span>) -&gt; IRModule:</span><br><span class="line">        <span class="comment"># Get interested patterns</span></span><br><span class="line">        patterns = [relax.backend.get_pattern(<span class="string">&quot;cublas.matmul_transposed_bias_relu&quot;</span>)]</span><br><span class="line">        <span class="comment"># Note in real-world cases, we usually get all patterns</span></span><br><span class="line">        <span class="comment"># patterns = relax.backend.get_patterns_with_prefix(&quot;cublas&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Fuse ops by patterns and then run codegen</span></span><br><span class="line">        mod = relax.transform.FuseOpsByPattern(patterns, annotate_codegen=<span class="literal">True</span>)(mod)</span><br><span class="line">        mod = relax.transform.RunCodegen()(mod)</span><br><span class="line">        <span class="keyword">return</span> mod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mod = CublasDispatch()(mod)</span><br><span class="line">mod.show()</span><br></pre></td></tr></table></figure>
<p>And the IRModule is transformed into the following form:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from tvm.script import ir as I</span></span><br><span class="line"><span class="comment"># from tvm.script import relax as R</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@I.ir_module</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>:</span><br><span class="line">    I.module_attrs(&#123;<span class="string">&quot;external_mods&quot;</span>: [metadata[<span class="string">&quot;runtime.Module&quot;</span>][<span class="number">0</span>]]&#125;)</span><br><span class="line"><span class="meta">    @R.function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x: R.Tensor(<span class="params">(<span class="params"><span class="number">1</span>, <span class="number">784</span></span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc1_weight: R.Tensor(<span class="params">(<span class="params"><span class="number">256</span>, <span class="number">784</span></span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc1_bias: R.Tensor(<span class="params">(<span class="params"><span class="number">256</span>,</span>), dtype=<span class="string">&quot;float32&quot;</span></span>), fc2_weight: R.Tensor(<span class="params">(<span class="params"><span class="number">10</span>, <span class="number">256</span></span>), dtype=<span class="string">&quot;float32&quot;</span></span>)</span>) -&gt; R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>):</span><br><span class="line">        R.func_attr(&#123;<span class="string">&quot;num_input&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="keyword">with</span> R.dataflow():</span><br><span class="line">            lv = R.call_dps_packed(<span class="string">&quot;fused_relax_permute_dims_relax_matmul_relax_add_relax_nn_relu_cublas&quot;</span>, (fc1_weight, x, fc1_bias), out_sinfo=R.Tensor((<span class="number">1</span>, <span class="number">256</span>), dtype=<span class="string">&quot;float32&quot;</span>))</span><br><span class="line">            permute_dims1: R.Tensor((<span class="number">256</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.permute_dims(fc2_weight, axes=<span class="literal">None</span>)</span><br><span class="line">            matmul1: R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = R.matmul(lv, permute_dims1, out_dtype=<span class="string">&quot;void&quot;</span>)</span><br><span class="line">            gv: R.Tensor((<span class="number">1</span>, <span class="number">10</span>), dtype=<span class="string">&quot;float32&quot;</span>) = matmul1</span><br><span class="line">            R.output(gv)</span><br><span class="line">        <span class="keyword">return</span> gv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata omitted. Use show_meta=True in script() method to show it.</span></span><br></pre></td></tr></table></figure>
<p>Additionally, auto-tuning (using a machine learning algorithm to find
optimal solutions) is available:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = tvm.cuda(<span class="number">0</span>)</span><br><span class="line">target = tvm.target.Target.from_device(device)</span><br><span class="line">trials = <span class="number">2000</span></span><br><span class="line"><span class="keyword">with</span> target, tempfile.TemporaryDirectory() <span class="keyword">as</span> tmp_dir:</span><br><span class="line">    mod = tvm.ir.transform.Sequential(</span><br><span class="line">        [</span><br><span class="line">            relax.get_pipeline(<span class="string">&quot;zero&quot;</span>),</span><br><span class="line">            relax.transform.MetaScheduleTuneTIR(work_dir=tmp_dir, max_trials_global=trials),</span><br><span class="line">            relax.transform.MetaScheduleApplyDatabase(work_dir=tmp_dir),</span><br><span class="line">        ]</span><br><span class="line">    )(mod)</span><br><span class="line"></span><br><span class="line">mod.show()</span><br></pre></td></tr></table></figure>
<p>Finally, after extensive optimization, the compilation continues and
the final code is generated. A TVM runtime supports loads the code and
runs it on the target device.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate optimized code (which can be saved and loaded)</span></span><br><span class="line">target = tvm.target.Target(<span class="string">&quot;llvm&quot;</span>)</span><br><span class="line">ex = relax.build(mod, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run VM (at the device side)</span></span><br><span class="line">device = tvm.cpu()</span><br><span class="line">vm = relax.VirtualMachine(ex, device)</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">1</span>, <span class="number">784</span>).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">tvm_data = tvm.nd.array(data, device=device)</span><br><span class="line">params = [np.random.rand(*param.shape).astype(<span class="string">&quot;float32&quot;</span>) <span class="keyword">for</span> _, param <span class="keyword">in</span> param_spec]</span><br><span class="line">params = [tvm.nd.array(param, device=device) <span class="keyword">for</span> param <span class="keyword">in</span> params]</span><br><span class="line"><span class="built_in">print</span>(vm[<span class="string">&quot;forward&quot;</span>](tvm_data, *params).numpy())</span><br></pre></td></tr></table></figure>
<h3 id="great-articles-2">Great Articles</h3>
<ul>
<li><p>TVM official documentation: <a href="https://tvm.apache.org/docs"
class="uri">https://tvm.apache.org/docs</a></p></li>
<li><p>Tutorial of TVM (in Chinese): <a
href="https://zhuanlan.zhihu.com/p/532873577"
class="uri">https://zhuanlan.zhihu.com/p/532873577</a></p></li>
</ul>
<h2 id="mlir-multi-level-intermediate-representation">MLIR (Multi-Level
Intermediate Representation)</h2>
<h3 id="concepts-1">Concepts</h3>
<p>To support DSLs (including those for AI compilation) and represent
many application/device-specific objects, a single centralized IR - LLVM
IR</p>
<ul>
<li>is insufficient. MLIR is designed to address this problem. It has a
<strong>discrete</strong>, <strong>hierarchical</strong> and
<strong>extensible</strong> definition, where many <em>dialects</em> can
be defined to represent different levels of abstraction and different
domains.</li>
</ul>
<figure>
<img src="mlir_dialects.png" width=100% />
<figcaption>
<p>
Figure 4: MLIR Dialects
</p>
</figcaption>
</figure>
<h3 id="great-articles-3">Great Articles</h3>
<ul>
<li><p>MLIR learning path (in Chinese): <a
href="https://www.zhihu.com/question/435109274"
class="uri">https://www.zhihu.com/question/435109274</a></p></li>
<li><p>MLIR inspiration (in Chinese): <a
href="https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir"
class="uri">https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir</a></p></li>
<li><p>How TVM is different from MLIR: <a
href="https://stackoverflow.com/questions/65288033/how-tvm-is-different-from-mlir"
class="uri">https://stackoverflow.com/questions/65288033/how-tvm-is-different-from-mlir</a></p></li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Example from <a href="https://tvm.apache.org/docs/"
class="uri">https://tvm.apache.org/docs/</a><a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Artificial Intelligence</category>
        <category>Compilation</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence</tag>
        <tag>Compilation</tag>
        <tag>PyTorch</tag>
        <tag>TVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SGLang Meets DeepSeek</title>
    <url>/posts/2e93e0b4/</url>
    <content><![CDATA[<p>This post introduces SGLang, an inference system designed to optimize
large language model (LLM) deployment. We focus on:</p>
<ol type="1">
<li>SGLang’s workflow and its distribution setup (e.g., PP/TP/DP
constraints);</li>
<li>DeepSeek’s inference challenges on SGLang and how DP Attention
optimization addresses them.</li>
</ol>
<span id="more"></span>
<h2 id="sglang-distribution-setup-wo-dp-attention">SGLang Distribution
Setup (w/o <em>DP Attention</em>)</h2>
<h3 id="overview">Overview</h3>
<p>The SGLang<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> distribution setup can be summerized
as follows:</p>
<ul>
<li>NO PP support;</li>
<li>DP&gt;1 is not supported on multiple nodes<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. In
fact, DP will be <a
href="https://docs.sglang.ai/backend/server_arguments.html#data-parallelism">deprecated</a>
in the future. SGLang suggests SGLang Router for DP (an orchestrator
written in Rust);</li>
<li>TP % nnodes == 0.</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> (</span><br><span class="line">    <span class="variable language_">self</span>.tp_size % <span class="variable language_">self</span>.nnodes == <span class="number">0</span></span><br><span class="line">), <span class="string">&quot;tp_size must be divisible by number of nodes&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> (</span><br><span class="line">    <span class="variable language_">self</span>.dp_size &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="variable language_">self</span>.nnodes != <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.enable_dp_attention</span><br><span class="line">), <span class="string">&quot;multi-node data parallel is not supported unless dp attention!&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="configurations">Configurations</h3>
<p>The following figures show the structure for different parallel
configurations in SGLang.</p>
<figure>
<img src="1.png" width=70% />
<figcaption>
Figure 1. TP=1, DP=1, nnodes=1
</figcaption>
</figure>
<hr />
<figure>
<img src="2.png" width=70% />
<figcaption>
Figure 2. TP=2, DP=1, nnodes=1
</figcaption>
</figure>
<hr />
<figure>
<img src="3.png" width=70% />
<figcaption>
Figure 3. TP=4, DP=1, nnodes=2
</figcaption>
</figure>
<hr />
<figure>
<img src="4.png" width=70% />
<figcaption>
Figure 4. TP=2, DP=2, nnodes=1
</figcaption>
</figure>
<hr />
<h2 id="dp-attention-optimization">DP Attention Optimization</h2>
<h3 id="tp-in-llama-3">TP in Llama 3</h3>
<p>Before introducing the <em>DP Attention</em> optimization, let's
first investigate how TP is implemented in Llama 3.</p>
<ul>
<li><code>word_embedding</code>: vocab parallel;</li>
<li><code>positional_embedding</code>: replicate;</li>
<li><code>attn</code>: parallel on head dim;</li>
<li><code>mlp</code>: parallel on column then row.</li>
</ul>
<p>Llama 3 attn can be implemented as follows. For convenience, we omit
RoPE and use MHA. Notice that the size of <em>every</em> matrix is
reduced by <code>tp</code> times. Also, the KV cache size is reduced by
<code>tp</code> times.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, hidden_states</span>):</span><br><span class="line">    <span class="comment"># hidden_states: (bs, seq_len, hidden_dim)</span></span><br><span class="line">    q, k, v = qkv_proj(hidden_states).view(bs, seq_len,</span><br><span class="line">        head_num/tp, <span class="number">3</span>*head_dim).split().transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># qkv_proj on tp: (hidden_dim, 3*head_num*head_dim/tp)</span></span><br><span class="line">    <span class="comment"># &#123;q,k,v&#125;: (bs, head_num/tp, seq_len, head_dim)</span></span><br><span class="line">    save_kvcache(k, v) <span class="comment"># Reduce `tp`x KV cache size</span></span><br><span class="line">    attn_weights = matmul(q, k.transpose(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    attn_weights = softmax(attn_weights, dim=-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># attn_weights: (bs, head_num/tp, seq_len, seq_len)</span></span><br><span class="line">    attn_output = matmul(attn_weights, v)</span><br><span class="line">    attn_output = attn_output.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># attn_output: (bs, seq_len, head_num/tp, head_dim)</span></span><br><span class="line">    attn_output = attn_output.reshape(bs, seq_len, -<span class="number">1</span>)\</span><br><span class="line">        .all_reduce()</span><br><span class="line">    <span class="comment"># attn_output: (bs, seq_len, hidden_dim)</span></span><br><span class="line">    attn_output = <span class="variable language_">self</span>.o_proj(attn_output)</span><br><span class="line">    <span class="keyword">return</span> attn_output, attn_weights</span><br></pre></td></tr></table></figure>
<p>MLP in Llama 3 is paralleled based on column then row
dispatching.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.gate_up_proj = MergedColumnParallelLinear(...)</span><br><span class="line"><span class="variable language_">self</span>.down_proj = RowParallelLinear(...)</span><br><span class="line"><span class="variable language_">self</span>.act_fn = SiluAndMul()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    gate_up, _ = <span class="variable language_">self</span>.gate_up_proj(x)</span><br><span class="line">    x = <span class="variable language_">self</span>.act_fn(gate_up)</span><br><span class="line">    x, _ = <span class="variable language_">self</span>.down_proj(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="problems-of-tp-in-deepseek">Problems of TP in DeepSeek</h3>
<p>However, the TP implementation in Llama 3 is not optimal for
DeepSeek. This is because</p>
<ul>
<li><p><code>mla_attn</code>:</p>
<ul>
<li><p>Latent of size <code>(1, kv_lora_rank + qk_rope_head_dim)</code>
for each token shall be saved. This cannot be divided along with the
num_head dim — KV cache size cannot be reduced;</p></li>
<li><p>Some params (e.g. <code>q_a_proj</code>,
<code>kv_a_proj_with_mqa</code>) cannot be paralleled — parameter
duplications.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.q_a_proj = ReplicatedLinear(...)</span><br><span class="line"><span class="variable language_">self</span>.q_b_proj = ColumnParallelLinear(...)</span><br><span class="line"><span class="variable language_">self</span>.kv_b_proj = ColumnParallelLinear(...)</span><br><span class="line"><span class="variable language_">self</span>.o_proj = RowParallelLinear(...)</span><br><span class="line"><span class="variable language_">self</span>.kv_a_proj_with_mqa = ReplicatedLinear(...)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><code>moe_mlp</code>:</p>
<ul>
<li>Expert parallel (EP) is better than TP, since each of the experts is
small.</li>
</ul></li>
</ul>
<h3 id="sglang-dp-attention-for-deepseek-v3">SGLang <em>DP
Attention</em> for DeepSeek V3</h3>
<p><em>DP Attention</em> intends to solve the above problems<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a> in <code>mla_attn</code>. The
parallel policy becomes:</p>
<ul>
<li><code>word_embedding</code>: replicate</li>
<li><code>positional_embedding</code>: replicate</li>
<li><code>attn</code>: parallel on batch size (independent
requests)</li>
</ul>
<figure>
<img src="5.png" width=70% />
<figcaption>
Figure 5. DP Attention
</figcaption>
</figure>
<p>Its configuration requirement is:</p>
<ul>
<li>1 &lt; AttnDP ≤ TP and TP % AttnDP = 0. This is because SGLang
supports DP+TP attention.</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> (</span><br><span class="line">    <span class="variable language_">self</span>.dp_size &gt; <span class="number">1</span></span><br><span class="line">), <span class="string">&quot;Please set a dp-size &gt; 1. You can use 1 &lt; dp-size &lt;= tp-size &quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="variable language_">self</span>.tp_size % <span class="variable language_">self</span>.dp_size == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>And some concrete configurations is shown below:</p>
<figure>
<img src="6.png" width=70% />
<figcaption>
Figure 6. TP=2, AttnDP=2, nnodes=1
</figcaption>
</figure>
<hr/>
<figure>
<img src="7.png" width=70% />
<figcaption>
Figure 7. TP=4, AttnDP=2, nnodes=1
</figcaption>
</figure>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://github.com/sgl-project/sglang"
class="uri">https://github.com/sgl-project/sglang</a>, on tag
v0.4.4_post4<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>When using <em>DP Attention</em>, DP has another meaning
in SGLang. We use the word “AttnDP” instead of “DP” when enabling <em>DP
Attention</em> for clarity (In fact, the canonical “DP” is always 1 in
such situations). When using the word “DP”, we mean the canonical “DP”
and <em>DP Attention</em> is disabled.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>See also <a
href="https://zhuanlan.zhihu.com/p/15280741714"
class="uri">https://zhuanlan.zhihu.com/p/15280741714</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Artificial Intelligence</category>
        <category>LLM</category>
        <category>Inference</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence</tag>
        <tag>LLM</tag>
        <tag>SGLang</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>(SPR) OSDI25 2502.04563 WaferLLM</title>
    <url>/posts/2cae1698/</url>
    <content><![CDATA[<p><a href="https://github.com/MeshInfra/WaferLLM">Original Repo</a>; <a
href="https://github.com/System-Paper-Reproduce/OSDI25-2502.04563-WaferLLM">SPR
Repo</a>; <a href="https://arxiv.org/abs/2502.04563">arXiv</a>.</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>SPR</category>
        <category>OSDI25</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Computer System</tag>
        <tag>Artificial Intelligence</tag>
        <tag>LLM</tag>
        <tag>SPR</tag>
      </tags>
  </entry>
</search>
